This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
app/(admin)/admin/layout.tsx
app/(admin)/admin/page.tsx
app/(admin)/admin/projects/[projectId]/page.tsx
app/(admin)/admin/projects/[projectId]/review/page.tsx
app/(admin)/admin/projects/layout.tsx
app/(admin)/admin/projects/page.tsx
app/(admin)/components/admin-nav.tsx
app/(admin)/components/projects/CreateProjectDialog.tsx
app/(admin)/components/projects/details/AddMEmberDialog.tsx
app/(admin)/components/projects/details/ProjectImages.tsx
app/(admin)/components/projects/details/ProjectMembers.tsx
app/(admin)/components/projects/details/ProjectOverview.tsx
app/(admin)/components/projects/details/ProjectSettings.tsx
app/(admin)/components/projects/details/UploadImagesDialog.tsx
app/(admin)/components/projects/ProjectCard.tsx
app/(admin)/components/projects/ProjectChart.tsx
app/(admin)/components/projects/ProjectHeader.tsx
app/(admin)/components/projects/ProjectList.tsx
app/(admin)/components/projects/ProjectOverview.tsx
app/(admin)/components/projects/ProjectStats.tsx
app/(admin)/components/projects/RecentActivity.tsx
app/(admin)/components/SecurityLogPage.tsx
app/(admin)/components/SidePanel.tsx
app/(auth)/components/FormFields.tsx
app/(auth)/components/LoginForm.tsx
app/(auth)/login/loading.tsx
app/(auth)/login/page.tsx
app/(dashboard)/components/editor/Annotation.tsx
app/(dashboard)/components/editor/AnnotationToolbar.tsx
app/(dashboard)/components/editor/AutoSaveIndicator.tsx
app/(dashboard)/components/editor/ClassAsignDialog.tsx
app/(dashboard)/components/editor/HelpDialog.tsx
app/(dashboard)/components/editor/ImageMover.tsx
app/(dashboard)/components/editor/LabelSidebar.tsx
app/(dashboard)/components/editor/PaginationTool.tsx
app/(dashboard)/components/editor/PhotoViewer.tsx
app/(dashboard)/components/editor/StatusInfo.tsx
app/(dashboard)/components/navbar.tsx
app/(dashboard)/components/project-card.tsx
app/(dashboard)/components/project-details/filter-chip.tsx
app/(dashboard)/components/project-details/project-detail-images.tsx
app/(dashboard)/components/project-details/SubmitProjectBtn.tsx
app/(dashboard)/components/project-grid.tsx
app/(dashboard)/components/project-header.tsx
app/(dashboard)/dashboard/[ProjectId]/editor/page.tsx
app/(dashboard)/dashboard/[ProjectId]/page.tsx
app/(dashboard)/dashboard/layout.tsx
app/(dashboard)/dashboard/page.tsx
app/globals.css
app/layout.tsx
eslint.config.mjs
lib/actions/auth.ts
lib/apis/admins.ts
lib/apis/annotations.ts
lib/apis/auth.ts
lib/apis/config.ts
lib/apis/images.ts
lib/apis/logs.ts
lib/apis/projects.ts
lib/apis/users.ts
lib/context/auth.tsx
lib/context/page-data-context.tsx
lib/types/admins.ts
lib/types/annotations.ts
lib/types/auth.ts
lib/types/editor.ts
lib/types/logs.ts
lib/types/project-detail.ts
lib/types/project.ts
lib/types/projects.ts
lib/types/users.ts
lib/utils.ts
lib/utils/color.ts
lib/utils/validation.ts
middleware.ts
next.config.ts
package.json
postcss.config.mjs
public/next.svg
public/vercel.svg
README.md
tailwind.config.ts
tsconfig.json

================================================================
Files
================================================================

================
File: app/(admin)/admin/layout.tsx
================
// app/(admin)/layout.tsx
export default async function AdminLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return <>{children}</>;
}

================
File: app/(admin)/admin/page.tsx
================
// app/(admin)/page.tsx
import { Toaster } from "sonner";
import SecurityLogsPage from "../components/SecurityLogPage";
import { getCurrentUser } from "@/lib/apis/auth";
import { redirect } from "next/navigation";
import { UserRole } from "@/lib/types/auth";
import { AdminNavbar } from "../components/admin-nav";

export default async function AdminPage() {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  // Prevent regular users from accessing admin dashboard
  if (user.role !== UserRole.ADMIN) {
    redirect("/dashboard");
  }

  return (
    <>
      <div className="min-h-screen bg-gray-100">
        <AdminNavbar user={user} />
        <main className="container mx-auto px-4 py-8">
          <Toaster richColors closeButton position="top-center" />
          <SecurityLogsPage />{" "}
        </main>
      </div>
    </>
  );
}

================
File: app/(admin)/admin/projects/[projectId]/page.tsx
================
// app/(admin)/admin/projects/[projectId]/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { getProjectDetails } from "@/lib/apis/projects";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import type { Project } from "@/lib/types/project";
import { Skeleton } from "@/components/ui/skeleton";
import { ProjectHeader } from "@/app/(admin)/components/projects/ProjectHeader";
import { ProjectOverview } from "@/app/(admin)/components/projects/details/ProjectOverview";
import { ProjectMembers } from "@/app/(admin)/components/projects/details/ProjectMembers";
import { ProjectImages } from "@/app/(admin)/components/projects/details/ProjectImages";
import { ProjectSettings } from "@/app/(admin)/components/projects/details/ProjectSettings";
import { toast } from "sonner";

export default function ProjectDetailsPage() {
  const params = useParams();
  const projectId = params.projectId as string;
  const [project, setProject] = useState<Project | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchProject() {
      if (!projectId) {
        setError("Project ID is missing");
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        console.log("Fetching project with ID:", projectId);
        
        const data = await getProjectDetails(projectId);
        console.log("Project details response:", data);
        
        if (!data) {
          setError("Project not found");
        } else {
          setProject(data);
          setError(null);
        }
      } catch (error) {
        console.error("Failed to load project:", error);
        setError(error instanceof Error ? error.message : "Failed to load project");
        toast.error("Error loading project details");
      } finally {
        setLoading(false);
      }
    }

    fetchProject();
  }, [projectId]);

  if (loading) {
    return (
      <div className="space-y-8">
        <Skeleton className="h-20 w-full" />
        <Skeleton className="h-[600px] w-full" />
      </div>
    );
  }

  if (error || !project) {
    return (
      <div className="p-6 bg-red-50 rounded-lg text-red-800">
        <h2 className="text-2xl font-bold mb-2">Project not found</h2>
        <p>{error || "Failed to load project details"}</p>
        <p className="mt-4 text-sm">Project ID: {projectId}</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <ProjectHeader project={project} />

      <Tabs defaultValue="overview" className="space-y-6">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="members">Members</TabsTrigger>
          <TabsTrigger value="images">Images</TabsTrigger>
          <TabsTrigger value="settings">Settings</TabsTrigger>
        </TabsList>

        <TabsContent value="overview">
          <ProjectOverview project={project} />
        </TabsContent>

        <TabsContent value="members">
          <ProjectMembers project={project} />
        </TabsContent>

        <TabsContent value="images">
          <ProjectImages project={project} />
        </TabsContent>

        <TabsContent value="settings">
          <ProjectSettings 
            project={project} 
            onUpdate={(updatedProject) => setProject(updatedProject)} 
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}

================
File: app/(admin)/admin/projects/[projectId]/review/page.tsx
================
// app/(admin)/admin/projects/[projectId]/review/page.tsx
"use client";

import { useCallback, useEffect, useState } from "react";
import { useParams, useRouter } from "next/navigation";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import { usePageData } from "@/lib/context/page-data-context";
import {
  getClasses,
  getAnnotations,
  updateAnnotations,
} from "@/lib/apis/annotations";
import type { Annotation, AnnotationState } from "@/lib/types/annotations";
import PhotoViewer from "@/app/(dashboard)/components/editor/PhotoViewer";
import { getImage } from "@/lib/apis/images";
import { getAuthToken } from "@/lib/actions/auth";

export default function AdminReviewPage() {
  const params = useParams();
  const projectId = params.projectId as string;
  const router = useRouter();
  
  const { editorData } = usePageData();
  const [isLoading, setIsLoading] = useState(true);
  const [annotationClasses, setAnnotationClasses] = useState<string[]>([]);
  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [isOfficeUser, setIsOfficeUser] = useState(false);
  const [imageUrl, setImageUrl] = useState<string>("");
  const [annotationState, setAnnotationState] = useState<AnnotationState>({
    annotations: [],
    isAnnotated: false,
  });
  const [token, setToken] = useState<string | null>(null);

  // Navigate back if no editor data
  useEffect(() => {
    if (!editorData) {
      router.replace(`/admin/projects/${projectId}`);
    } else {
      const init = async () => {
        try {
          const authToken = await getAuthToken();
          setToken(authToken ?? null);
        } catch (error) {
          console.error("Error initializing:", error);
          toast.error("Failed to get auth token");
        }
      };
      init();
    }
  }, [editorData, router, projectId]);

  // Fetch image data
  const fetchImage = useCallback(async () => {
    if (!editorData || !token) return;

    const controller = new AbortController();
    let objectUrl = "";

    try {
      const currentImageId = editorData.imageIds[currentImageIndex];
      setImageUrl(""); // Clear previous image URL

      const imageData = await getImage(
        editorData.userId,
        editorData.projectId,
        currentImageId
      );

      // Check if component is still mounted (controller not aborted)
      if (controller.signal.aborted) return;

      const response = await fetch(imageData.url, {
        headers: { Authorization: `Bearer ${token}` },
        signal: controller.signal,
      });

      if (!response.ok) throw new Error("Failed to load image");

      const blob = await response.blob();
      objectUrl = URL.createObjectURL(blob);
      setImageUrl(objectUrl);
    } catch (error) {
      if (!controller.signal.aborted) {
        // Only show error if not aborted
        toast.error("Failed to load image", {
          description: error instanceof Error ? error.message : "Unknown error",
        });
        console.error("Error loading image:", error);
      }
    }

    return () => {
      controller.abort();
      if (objectUrl) URL.revokeObjectURL(objectUrl);
    };
  }, [editorData, currentImageIndex, token]);

  // Fetch classes and annotations
  const fetchClasses = useCallback(async () => {
    if (!editorData) return;

    try {
      const { classes, isOfficeUser: isOffice } = await getClasses(
        editorData.userId,
        editorData.projectId
      );
      setAnnotationClasses(classes);
      setIsOfficeUser(isOffice);
    } catch (error) {
      toast.error("Failed to load annotation classes");
      console.error("Error loading classes:", error);
    }
  }, [editorData]);

  const fetchAnnotations = useCallback(async () => {
    if (!editorData) return;

    try {
      const currentImageId = editorData.imageIds[currentImageIndex];
      const annotations = await getAnnotations(
        editorData.userId,
        editorData.projectId,
        currentImageId
      );
      setAnnotationState(annotations);
    } catch (error) {
      toast.error("Failed to load annotations");
      console.error("Error loading annotations:", error);
    }
  }, [editorData, currentImageIndex]);

  useEffect(() => {
    if (!editorData || !token) return;

    const loadData = async () => {
      setIsLoading(true);
      try {
        await Promise.all([fetchImage(), fetchClasses(), fetchAnnotations()]);
      } catch (error) {
        console.error("Error loading data:", error);
        toast.error("Failed to load data");
      } finally {
        setIsLoading(false);
      }
    };

    void loadData();
  }, [fetchImage, fetchClasses, fetchAnnotations, editorData, token]);

  // Save annotations handler
  const handleSaveAnnotations = useCallback(
    async (annotations: Annotation[], customClass?: string) => {
      if (!editorData) return;

      try {
        const currentImageId = editorData.imageIds[currentImageIndex];
        await updateAnnotations(
          editorData.userId,
          editorData.projectId,
          currentImageId,
          annotations,
          customClass
        );

        setAnnotationState((prev) => ({
          ...prev,
          annotations,
          isAnnotated: annotations.length > 0,
        }));

        toast.success("Annotations saved successfully");
      } catch (error) {
        toast.error("Failed to save annotations");
        console.error("Error saving annotations:", error);
      }
    },
    [editorData, currentImageIndex]
  );

  // Navigation handlers
  const handleNext = useCallback(() => {
    if (!editorData) return;
    if (currentImageIndex < editorData.imageIds.length - 1) {
      setCurrentImageIndex((prev) => prev + 1);
    }
  }, [editorData, currentImageIndex]);

  const handlePrevious = useCallback(() => {
    if (currentImageIndex > 0) {
      setCurrentImageIndex((prev) => prev - 1);
    }
  }, [currentImageIndex]);

  if (!editorData || isLoading || !imageUrl) {
    return (
      <div className="h-screen w-full flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="w-8 h-8 animate-spin text-primary" />
          <p className="text-muted-foreground">Loading editor...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen w-full">
      <PhotoViewer
        currentImageId={editorData.imageIds[currentImageIndex]}
        annotationState={annotationState}
        availableClasses={annotationClasses}
        isOfficeUser={isOfficeUser}
        imageUrl={imageUrl}
        onSave={handleSaveAnnotations}
        onNext={handleNext}
        onPrevious={handlePrevious}
        onBack={() => router.back()}
        currentIndex={currentImageIndex}
        totalImages={editorData.imageIds.length}
        hasPrevious={currentImageIndex > 0}
        hasNext={currentImageIndex < editorData.imageIds.length - 1}
        isAdmin={true} // Pass this prop to enable admin-specific UI
        projectId={editorData.projectId} // Pass this from editorData
      />
    </div>
  );
}

================
File: app/(admin)/admin/projects/layout.tsx
================
// app/(admin)/admin/projects/layout.tsx
import { Breadcrumb } from "@/components/ui/breadcrumb";
import { AdminNavbar } from "../../components/admin-nav";
import { getCurrentUser } from "@/lib/apis/auth";
import { redirect } from "next/navigation";
import { UserRole } from "@/lib/types/auth";
import { PageDataProvider } from "@/lib/context/page-data-context";

export default async function AdminProjectsLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  // Prevent regular users from accessing admin dashboard
  if (user.role !== UserRole.ADMIN) {
    redirect("/dashboard");
  }

  return (
    <PageDataProvider>
    <div className="min-h-screen bg-gray-50">
      <AdminNavbar user={user} />
      <div className="container mx-auto px-4 py-6">
        <Breadcrumb />
        {children}
      </div>
    </div>
    </PageDataProvider>
  );
}

================
File: app/(admin)/admin/projects/page.tsx
================
// app/(admin)/admin/projects/page.tsx
"use client";

import { useState } from "react";
import { TabsContent, Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Plus } from "lucide-react";
import { ProjectsOverview } from "../../components/projects/ProjectOverview";
import { ProjectsList } from "../../components/projects/ProjectList";
import { CreateProjectDialog } from "../../components/projects/CreateProjectDialog";

export default function AdminProjectsPage() {
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold tracking-tight">Projects</h1>
        <Button onClick={() => setIsCreateDialogOpen(true)}>
          <Plus className="h-4 w-4 mr-2" />
          Create Project
        </Button>
      </div>

      {/* Main Content */}
      <Tabs defaultValue="overview" className="space-y-6">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="list">All Projects</TabsTrigger>
          <TabsTrigger value="archive">Archive</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <ProjectsOverview />
        </TabsContent>

        <TabsContent value="list">
          <ProjectsList />
        </TabsContent>

        <TabsContent value="archive">
          <ProjectsList showArchived />
        </TabsContent>
      </Tabs>

      <CreateProjectDialog 
        open={isCreateDialogOpen} 
        onOpenChange={setIsCreateDialogOpen} 
      />
    </div>
  );
}

================
File: app/(admin)/components/admin-nav.tsx
================
"use client";

import { UserInfo } from "@/lib/types/auth";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { LucideShieldAlert, Users2, ScrollText, Folder } from "lucide-react";
import {
  NavigationMenu,
  NavigationMenuItem,
  NavigationMenuLink,
  NavigationMenuList,
  navigationMenuTriggerStyle,
} from "@/components/ui/navigation-menu";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";
import { logout } from "@/lib/actions/auth";

interface AdminNavbarProps {
  user: UserInfo;
}

export function AdminNavbar({ user }: AdminNavbarProps) {
  const pathname = usePathname();
  const isSuperAdmin = user.isSuperAdmin;

  const getGreeting = () => {
    const hour = new Date().getHours();
    if (hour >= 5 && hour < 12) return "Good morning";
    if (hour >= 12 && hour < 17) return "Good afternoon";
    if (hour >= 17 && hour < 21) return "Good evening";
    return "Good night";
  };

  const navItems = [
    {
      name: "Logs",
      href: "/admin",
      icon: ScrollText,
    },
    {
      name: "Users",
      href: "/admin/users",
      icon: Users2,
    },
    {
      name: "Projects",
      href: "/admin/projects",
      icon: Folder,
    },
    ...(isSuperAdmin
      ? [
          {
            name: "Admins",
            href: "/admin/admins",
            icon: LucideShieldAlert,
          },
        ]
      : []),
  ];

  console.log(user);

  return (
    <header className="sticky top-0 z-50 w-full border-b border-gray-200 bg-white/75 backdrop-blur-sm">
      <div className="container flex h-16 items-center justify-between px-4">
        {/* Greeting */}
        <div className="flex items-center gap-2">
          <span className="text-lg font-medium">
            {getGreeting()}, <span className="text-primary">{user.username}</span>
          </span>
        </div>

        {/* Navigation */}
        <NavigationMenu className="hidden md:flex">
          <NavigationMenuList>
            {navItems.map((item) => (
              <NavigationMenuItem key={item.name}>
                <Link href={item.href} legacyBehavior passHref>
                  <NavigationMenuLink
                    className={cn(
                      navigationMenuTriggerStyle(),
                      "h-9 px-4 py-2",
                      pathname === item.href
                        ? "bg-accent text-accent-foreground"
                        : ""
                    )}
                  >
                    <item.icon className="mr-2 h-4 w-4" />
                    {item.name}
                  </NavigationMenuLink>
                </Link>
              </NavigationMenuItem>
            ))}
          </NavigationMenuList>
        </NavigationMenu>

        {/* Logout */}
        <form action={logout}>
          <Button
            type="submit"
            variant="ghost"
            suppressHydrationWarning={true}
            className="px-4 text-gray-500 hover:text-gray-900"
          >
            Logout
          </Button>
        </form>
      </div>
    </header>
  );
}

================
File: app/(admin)/components/projects/CreateProjectDialog.tsx
================
// app/(admin)/components/projects/CreateProjectDialog.tsx
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { toast } from "sonner";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { createProject } from "@/lib/apis/projects";
import { AnnotationFormat, ProjectStatus } from "@/lib/types/project";

const formSchema = z.object({
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  modelFormat: z.nativeEnum(AnnotationFormat),
  allowCustomClasses: z.boolean().default(false),
  requireReview: z.boolean().default(true),
  autoDistribute: z.boolean().default(true),
  classes: z.array(z.string()).min(1, "At least one class is required"),
});

type FormValues = z.infer<typeof formSchema>;

interface CreateProjectDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
}

export function CreateProjectDialog({
  open,
  onOpenChange,
}: CreateProjectDialogProps) {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [classes, setClasses] = useState<string[]>([]);
  const [newClass, setNewClass] = useState("");

  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      modelFormat: AnnotationFormat.YOLO,
      allowCustomClasses: false,
      requireReview: true,
      autoDistribute: true,
      classes: [],
    },
  });

  async function onSubmit(values: FormValues) {
    setIsSubmitting(true);
    try {
      await createProject({
        name: values.name,
        description: values.description,
        settings: {
          modelFormat: values.modelFormat,
          allowCustomClasses: values.allowCustomClasses,
          requireReview: values.requireReview,
          autoDistribute: values.autoDistribute,
        },
        classes: values.classes,
        status: ProjectStatus.DRAFT,
        totalImages: 1, // Set a default value greater than 0 to pass validation
        members: [], // Include the required members property
      });

      toast.success("Project created successfully");
      onOpenChange(false);
      form.reset();
      setClasses([]);
    } catch (error) {
      console.error("Error creating project:", error);
      toast.error("Failed to create project");
    } finally {
      setIsSubmitting(false);
    }
  }

  const handleAddClass = () => {
    if (newClass.trim() && !classes.includes(newClass.trim())) {
      const updatedClasses = [...classes, newClass.trim()];
      setClasses(updatedClasses);
      form.setValue("classes", updatedClasses);
      setNewClass("");
    }
  };

  const handleRemoveClass = (classToRemove: string) => {
    const updatedClasses = classes.filter((c) => c !== classToRemove);
    setClasses(updatedClasses);
    form.setValue("classes", updatedClasses);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader>
          <DialogTitle>Create New Project</DialogTitle>
          <DialogDescription>
            Set up a new annotation project with your desired configuration.
          </DialogDescription>
        </DialogHeader>

        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Project Name</FormLabel>
                  <FormControl>
                    <Input placeholder="Enter project name" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Description</FormLabel>
                  <FormControl>
                    <Textarea
                      placeholder="Enter project description"
                      className="resize-none"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="modelFormat"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Annotation Format</FormLabel>
                  <Select
                    onValueChange={field.onChange}
                    defaultValue={field.value}
                  >
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Select format" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      <SelectItem value={AnnotationFormat.YOLO}>
                        YOLO
                      </SelectItem>
                      <SelectItem value={AnnotationFormat.COCO}>
                        COCO
                      </SelectItem>
                      <SelectItem value={AnnotationFormat.PASCAL_VOC}>
                        Pascal VOC
                      </SelectItem>
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <div className="space-y-2">
              <FormLabel>Classes</FormLabel>
              <div className="flex gap-2">
                <Input
                  value={newClass}
                  onChange={(e) => setNewClass(e.target.value)}
                  placeholder="Add a class"
                  onKeyPress={(e) => e.key === "Enter" && handleAddClass()}
                />
                <Button
                  type="button"
                  variant="secondary"
                  onClick={handleAddClass}
                >
                  Add
                </Button>
              </div>
              <div className="flex flex-wrap gap-2 mt-2">
                {classes.map((cls) => (
                  <div
                    key={cls}
                    className="bg-secondary px-2 py-1 rounded-md flex items-center gap-2"
                  >
                    <span>{cls}</span>
                    <button
                      type="button"
                      onClick={() => handleRemoveClass(cls)}
                      className="text-red-500 hover:text-red-700"
                    >
                      Ã—
                    </button>
                  </div>
                ))}
              </div>
              {form.formState.errors.classes && (
                <p className="text-sm text-red-500">
                  {form.formState.errors.classes.message}
                </p>
              )}
            </div>

            <div className="pt-6 space-x-2 flex items-center justify-end">
              <Button
                type="button"
                variant="outline"
                onClick={() => onOpenChange(false)}
                disabled={isSubmitting}
              >
                Cancel
              </Button>
              <Button type="submit" disabled={isSubmitting}>
                {isSubmitting && (
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                )}
                Create Project
              </Button>
            </div>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}

================
File: app/(admin)/components/projects/details/AddMEmberDialog.tsx
================
import { useEffect, useState, useCallback } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import { toast } from "sonner";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
  FormDescription,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import {
  addProjectMember,
  updateMemberAllocation,
  getAllUsers,
} from "@/lib/apis/projects";
import { Slider } from "@/components/ui/slider";
import { Switch } from "@/components/ui/switch";
import { ProjectMember } from "@/lib/types/project";

// Form schema for selecting a user
const userSelectionSchema = z.object({
  userId: z.string().min(1, "User is required"),
});

// Form schema for allocation
const allocationSchema = z.object({
  distributions: z.array(
    z.object({
      userId: z.string(),
      name: z.string(),
      allocationPercentage: z.number().min(0).max(100),
    })
  ),
  smartDistribute: z.boolean().default(false),
});

type UserSelectionFormValues = z.infer<typeof userSelectionSchema>;
type AllocationFormValues = z.infer<typeof allocationSchema>;

interface AddMemberDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  projectId: string;
  currentMembers: ProjectMember[];
  onMembersUpdated: () => void;
}

interface User {
  username: string;
  isLocked: boolean;
}

export function AddMemberDialog({
  open,
  onOpenChange,
  projectId,
  currentMembers,
  onMembersUpdated,
}: AddMemberDialogProps) {
  const [step, setStep] = useState<"select-user" | "allocate">("select-user");
  const [isLoading, setIsLoading] = useState(false);
  const [usersLoading, setUsersLoading] = useState(true);
  const [availableUsers, setAvailableUsers] = useState<User[]>([]);
  const [selectedUser, setSelectedUser] = useState<string | null>(null);
  const [distributions, setDistributions] = useState<
    AllocationFormValues["distributions"]
  >([]);

  // Form for user selection
  const userSelectionForm = useForm<UserSelectionFormValues>({
    resolver: zodResolver(userSelectionSchema),
    defaultValues: {
      userId: "",
    },
  });

  // Form for allocation
  const allocationForm = useForm<AllocationFormValues>({
    resolver: zodResolver(allocationSchema),
    defaultValues: {
      distributions: [],
      smartDistribute: true,
    },
  });

  // Load users that are not already project members
  const loadAvailableUsers = useCallback(async () => {
    setUsersLoading(true);
    try {
      // Use the API service to fetch all users
      const users = await getAllUsers();

      // Filter out users that are already project members
      const existingMemberIds = currentMembers.map((member) => member.userId);
      const filteredUsers = users.filter(
        (user: User) =>
          !existingMemberIds.includes(user.username) && !user.isLocked
      );

      setAvailableUsers(filteredUsers);
    } catch (error) {
      console.error("Failed to load users:", error);
      toast.error("Failed to load users");
    } finally {
      setUsersLoading(false);
    }
  }, [currentMembers]);

  // Handle smart distribution
  const handleSmartDistribute = useCallback(
    (customDistributions?: AllocationFormValues["distributions"]) => {
      const distributionsToUse =
        customDistributions || allocationForm.getValues().distributions;
      const memberCount = distributionsToUse.length;
      if (memberCount === 0) return;

      // Equal distribution among all members
      const equalPercentage = Math.floor(100 / memberCount);
      const remaining = 100 - equalPercentage * memberCount;

      // Create new distribution array with equal percentages
      const newDistributions = distributionsToUse.map((dist, index) => ({
        ...dist,
        allocationPercentage: equalPercentage + (index < remaining ? 1 : 0),
      }));

      // Update form
      setDistributions(newDistributions);
      allocationForm.setValue("distributions", newDistributions);
    },
    [allocationForm]
  );

  // Load available users when dialog opens
  useEffect(() => {
    if (open) {
      setStep("select-user");
      userSelectionForm.reset();
      allocationForm.reset({ distributions: [], smartDistribute: true });
      setSelectedUser(null);
      loadAvailableUsers();
    }
  }, [open, userSelectionForm, allocationForm, loadAvailableUsers]);

  // Prepare allocation data when user is selected
  useEffect(() => {
    if (selectedUser && step === "allocate") {
      // Create new distributions array with current members + new member
      const newDistributions = [
        ...currentMembers.map((member) => ({
          userId: member.userId,
          name: member.userId, // Use userId as name if we don't have actual names
          allocationPercentage: member.allocationPercentage,
        })),
        {
          userId: selectedUser,
          name: selectedUser, // Use userId as name if we don't have actual names
          allocationPercentage: 0, // Start with 0%
        },
      ];

      // Update form
      setDistributions(newDistributions);
      allocationForm.setValue("distributions", newDistributions);

      // If smart distribute is enabled, recalculate allocations
      if (allocationForm.getValues("smartDistribute")) {
        handleSmartDistribute(newDistributions);
      }
    }
  }, [
    selectedUser,
    step,
    currentMembers,
    allocationForm,
    handleSmartDistribute,
  ]);

  // Handle manual slider changes
  const handleSliderChange = useCallback(
    (userId: string, value: number[]) => {
      const newValue = value[0];

      // Get current distributions
      const currentDistributions = [
        ...allocationForm.getValues().distributions,
      ];

      // Find the distribution to update
      const indexToUpdate = currentDistributions.findIndex(
        (d) => d.userId === userId
      );
      if (indexToUpdate === -1) return;

      // Calculate difference to distribute among others
      const oldValue = currentDistributions[indexToUpdate].allocationPercentage;
      const difference = newValue - oldValue;

      if (difference === 0) return;

      // Update the selected distribution
      currentDistributions[indexToUpdate].allocationPercentage = newValue;

      // Adjust other distributions proportionally
      const otherDistributions = currentDistributions.filter(
        (_, i) => i !== indexToUpdate
      );
      const totalOtherPercentage = otherDistributions.reduce(
        (sum, dist) => sum + dist.allocationPercentage,
        0
      );

      if (totalOtherPercentage > 0) {
        // Adjust other distributions proportionally to maintain total of 100%
        otherDistributions.forEach((dist) => {
          const weight = dist.allocationPercentage / totalOtherPercentage;
          const newPercentage = Math.max(
            0,
            dist.allocationPercentage - difference * weight
          );
          const index = currentDistributions.findIndex(
            (d) => d.userId === dist.userId
          );
          if (index !== -1) {
            currentDistributions[index].allocationPercentage =
              Math.round(newPercentage);
          }
        });
      }

      // Ensure total is exactly 100%
      const total = currentDistributions.reduce(
        (sum, dist) => sum + dist.allocationPercentage,
        0
      );

      if (total !== 100) {
        // Find the distribution with the largest allocation and adjust it
        const indexToAdjust = currentDistributions
          .map((dist, i) => ({ value: dist.allocationPercentage, index: i }))
          .sort((a, b) => b.value - a.value)[0].index;

        currentDistributions[indexToAdjust].allocationPercentage += 100 - total;
      }

      // Update form
      setDistributions(currentDistributions);
      allocationForm.setValue("distributions", currentDistributions);
    },
    [allocationForm]
  );

  // Handle user selection submission
  const onUserSelectionSubmit = useCallback(
    (values: UserSelectionFormValues) => {
      setSelectedUser(values.userId);
      setStep("allocate");
    },
    []
  );

  // Handle allocation submission
  const onAllocationSubmit = useCallback(
    async (values: AllocationFormValues) => {
      if (!selectedUser) return;

      setIsLoading(true);
      try {
        // Prepare member allocations
        const memberAllocations = values.distributions.map((dist) => ({
          userId: dist.userId,
          allocationPercentage: dist.allocationPercentage,
        }));

        // Add the new member using the API service
        await addProjectMember(
          projectId,
          selectedUser,
          memberAllocations.find((m) => m.userId === selectedUser)
            ?.allocationPercentage || 0
        );

        // Update existing member allocations
        for (const member of currentMembers) {
          const newAllocation = memberAllocations.find(
            (m) => m.userId === member.userId
          );
          if (
            newAllocation &&
            newAllocation.allocationPercentage !== member.allocationPercentage
          ) {
            await updateMemberAllocation(
              projectId,
              member.userId,
              newAllocation.allocationPercentage
            );
          }
        }

        toast.success("Member added and allocations updated successfully");
        onMembersUpdated();
        onOpenChange(false);
      } catch (error) {
        console.error("Failed to add member:", error);
        toast.error("Failed to add member");
      } finally {
        setIsLoading(false);
      }
    },
    [selectedUser, projectId, currentMembers, onMembersUpdated, onOpenChange]
  );

  // When smart distribute toggle changes
  const handleSmartDistributeToggle = useCallback(
    (checked: boolean) => {
      allocationForm.setValue("smartDistribute", checked);
      if (checked) {
        handleSmartDistribute();
      }
    },
    [allocationForm, handleSmartDistribute]
  );

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[500px]">
        {step === "select-user" ? (
          <>
            <DialogHeader>
              <DialogTitle>Add Project Member</DialogTitle>
              <DialogDescription>
                Select a user to add to this project
              </DialogDescription>
            </DialogHeader>

            <Form {...userSelectionForm}>
              <form
                onSubmit={userSelectionForm.handleSubmit(onUserSelectionSubmit)}
                className="space-y-4"
              >
                <FormField
                  control={userSelectionForm.control}
                  name="userId"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Select User</FormLabel>
                      <Select
                        disabled={usersLoading}
                        onValueChange={field.onChange}
                        defaultValue={field.value}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue
                              placeholder={
                                usersLoading
                                  ? "Loading users..."
                                  : "Select a user"
                              }
                            />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          {availableUsers.map((user) => (
                            <SelectItem
                              key={user.username}
                              value={user.username}
                            >
                              {user.username}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <DialogFooter>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => onOpenChange(false)}
                  >
                    Cancel
                  </Button>
                  <Button type="submit" disabled={usersLoading}>
                    {usersLoading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Loading...
                      </>
                    ) : (
                      "Next"
                    )}
                  </Button>
                </DialogFooter>
              </form>
            </Form>
          </>
        ) : (
          <>
            <DialogHeader>
              <DialogTitle>Distribute Task Allocation</DialogTitle>
              <DialogDescription>
                Adjust how work is distributed among team members
              </DialogDescription>
            </DialogHeader>

            <Form {...allocationForm}>
              <form
                onSubmit={allocationForm.handleSubmit(onAllocationSubmit)}
                className="space-y-6"
              >
                <FormField
                  control={allocationForm.control}
                  name="smartDistribute"
                  render={({ field }) => (
                    <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3">
                      <div className="space-y-0.5">
                        <FormLabel>Smart Distribution</FormLabel>
                        <FormDescription>
                          Automatically balance work between team members
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={handleSmartDistributeToggle}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <div className="space-y-4">
                  <div className="flex justify-between text-sm font-medium">
                    <span>Team Member</span>
                    <span>Allocation %</span>
                  </div>

                  {distributions.map((dist) => (
                    <div key={dist.userId} className="space-y-2">
                      <div className="flex justify-between items-center">
                        <span className="font-medium">
                          {dist.userId === selectedUser
                            ? `${dist.name} (New)`
                            : dist.name}
                        </span>
                        <span className="font-medium text-primary">
                          {dist.allocationPercentage}%
                        </span>
                      </div>
                      <div className="flex gap-4 items-center">
                        <Slider
                          value={[dist.allocationPercentage]}
                          min={0}
                          max={100}
                          step={1}
                          onValueChange={(value) =>
                            handleSliderChange(dist.userId, value)
                          }
                          disabled={allocationForm.getValues("smartDistribute")}
                          className="flex-1"
                        />
                        <Input
                          type="number"
                          min={0}
                          max={100}
                          value={dist.allocationPercentage}
                          onChange={(e) => {
                            const value = parseInt(e.target.value);
                            if (!isNaN(value)) {
                              handleSliderChange(dist.userId, [value]);
                            }
                          }}
                          disabled={allocationForm.getValues("smartDistribute")}
                          className="w-16"
                        />
                      </div>
                    </div>
                  ))}
                </div>

                <DialogFooter>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => setStep("select-user")}
                    disabled={isLoading}
                  >
                    Back
                  </Button>
                  <Button type="submit" disabled={isLoading}>
                    {isLoading ? (
                      <>
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        Saving...
                      </>
                    ) : (
                      "Save Allocations"
                    )}
                  </Button>
                </DialogFooter>
              </form>
            </Form>
          </>
        )}
      </DialogContent>
    </Dialog>
  );
}

================
File: app/(admin)/components/projects/details/ProjectImages.tsx
================
// app/(admin)/components/projects/details/ProjectImages.tsx
import { useState } from "react";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertCircle,
  ImageIcon,
  MoreVertical,
  Search,
  Upload,
} from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import type { Project } from "@/lib/types/project";
import { UploadImagesDialog } from "./UploadImagesDialog";
import { Annotation } from "@/lib/types/annotations";
import { useRouter } from "next/navigation";
import { usePageData } from "@/lib/context/page-data-context";
import { toast } from "sonner";

interface ProjectImage {
  id: string;
  metadata: {
    originalName: string;
    lastModified: Date;
  };
  status:
    | "pending"
    | "in_progress"
    | "completed"
    | "review_pending"
    | "changes_requested";
  assignedTo: string;
  annotations: Annotation[];
}

// Update the Project interface to include images
interface ExtendedProject extends Project {
  images?: ProjectImage[];
}

// Update the component props
interface ProjectImagesProps {
  project: ExtendedProject;
}

export function ProjectImages({ project }: ProjectImagesProps) {
  const router = useRouter();
  const [isUploadOpen, setIsUploadOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [filter, setFilter] = useState("all");
  const { setEditorData } = usePageData();

  const statusColors: Record<ProjectImage["status"], string> = {
    pending: "bg-yellow-100 text-yellow-800",
    in_progress: "bg-blue-100 text-blue-800",
    completed: "bg-green-100 text-green-800",
    review_pending: "bg-purple-100 text-purple-800",
    changes_requested: "bg-red-100 text-red-800",
  };

  const handleReviewImages = () => {
    // Get all image IDs
    const imageIds = project.images?.map((image) => image.id) || [];

    if (imageIds.length === 0) {
      toast.error("No images available to review");
      return;
    }

    // Find the user for these images - typically get from the first image
    const userId =
      project.images?.[0]?.assignedTo || project.members[0]?.userId;

    if (!userId) {
      toast.error("No user found for these images");
      return;
    }

    // Set editor data with all images
    setEditorData({
      imageIds: imageIds,
      userId: userId,
      projectId: project.id,
      clickedImageId: imageIds[0],
    });

    // Navigate to the review page
    router.push(`/admin/projects/${project.id}/review`);
  };

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-medium">Project Images</h3>
          <p className="text-sm text-muted-foreground">
            Manage and monitor image annotations
          </p>
        </div>
        <div className="flex gap-2">
          <Button onClick={() => setIsUploadOpen(true)}>
            <Upload className="h-4 w-4 mr-2" />
            Upload Images
          </Button>
          <Button variant="outline" onClick={handleReviewImages}>
            <AlertCircle className="h-4 w-4 mr-2" />
            Review Annotations
          </Button>
        </div>
      </div>

      <div className="flex items-center gap-4">
        <div className="flex-1">
          <Label htmlFor="search" className="sr-only">
            Search
          </Label>
          <div className="relative">
            <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              id="search"
              placeholder="Search images..."
              className="pl-8"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
            />
          </div>
        </div>
        <Select value={filter} onValueChange={setFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Images</SelectItem>
            <SelectItem value="pending">Pending</SelectItem>
            <SelectItem value="completed">Completed</SelectItem>
            <SelectItem value="review_pending">Review Pending</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Image</TableHead>
              <TableHead>Assigned To</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Last Updated</TableHead>
              <TableHead>Annotations</TableHead>
              <TableHead></TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {project.images?.map((image: ProjectImage) => (
              <TableRow key={image.id}>
                <TableCell>
                  <div className="flex items-center gap-2">
                    <div className="w-10 h-10 bg-gray-100 rounded flex items-center justify-center">
                      {/* Thumbnail placeholder */}
                      <ImageIcon className="h-6 w-6 text-gray-400" />
                    </div>
                    <span className="font-medium">
                      {image.metadata.originalName}
                    </span>
                  </div>
                </TableCell>
                <TableCell>{image.assignedTo || "Unassigned"}</TableCell>
                <TableCell>
                  <Badge className={statusColors[image.status]}>
                    {image.status.replace(/_/g, " ")}
                  </Badge>
                </TableCell>
                <TableCell>
                  {formatDistanceToNow(new Date(image.metadata.lastModified), {
                    addSuffix: true,
                  })}
                </TableCell>
                <TableCell>{image.annotations?.length || 0}</TableCell>
                <TableCell>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm">
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem>Reassign</DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      <UploadImagesDialog
        open={isUploadOpen}
        onOpenChange={setIsUploadOpen}
        projectId={project.id}
      />
    </div>
  );
}

================
File: app/(admin)/components/projects/details/ProjectMembers.tsx
================
// app/(admin)/components/projects/details/ProjectMembers.tsx
import { useState, useCallback } from "react";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Progress } from "@/components/ui/progress";
import { UserPlus, MoreVertical, BarChart, Trash2, Loader2 } from "lucide-react";
import { formatDistanceToNow } from "date-fns";
import type { Project } from "@/lib/types/project";
import { AddMemberDialog } from "./AddMEmberDialog";
import { removeProjectMember } from "@/lib/apis/projects";
import { toast } from "sonner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";

interface ProjectMembersProps {
  project: Project;
}

export function ProjectMembers({ project }: ProjectMembersProps) {
  const [isAddMemberOpen, setIsAddMemberOpen] = useState(false);
  const [memberToRemove, setMemberToRemove] = useState<string | null>(null);
  const [isRemoving, setIsRemoving] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);

  const handleMembersUpdated = useCallback(() => {
    // Force refresh by incrementing the key
    setRefreshKey(prev => prev + 1);
  }, []);

  const handleRemoveMember = useCallback(async () => {
    if (!memberToRemove) return;

    setIsRemoving(true);
    try {
      await removeProjectMember(project.id, memberToRemove);
      toast.success("Member removed successfully");
      handleMembersUpdated();
    } catch (error) {
      console.error("Failed to remove member:", error);
      toast.error("Failed to remove member");
    } finally {
      setIsRemoving(false);
      setMemberToRemove(null);
    }
  }, [memberToRemove, project.id, handleMembersUpdated]);

  const getCompletionPercentage = (member: typeof project.members[0]) => {
    if (!member.assignedImages.length) return 0;
    return (member.completedImages.length / member.assignedImages.length) * 100 || 0;
  };

  // Calculate total allocation to ensure it adds up to 100%
  const totalAllocation = project.members.reduce(
    (sum, member) => sum + member.allocationPercentage, 
    0
  );

  return (
    <>
      <div className="space-y-6">
        <div className="flex items-center justify-between">
          <div>
            <h3 className="text-lg font-medium">Project Members</h3>
            <p className="text-sm text-muted-foreground">
              Manage members and their task allocations
            </p>
          </div>
          <Button onClick={() => setIsAddMemberOpen(true)}>
            <UserPlus className="h-4 w-4 mr-2" />
            Add Member
          </Button>
        </div>

        {totalAllocation !== 100 && project.members.length > 0 && (
          <div className="p-4 bg-amber-50 border border-amber-200 rounded-lg text-amber-800">
            <p className="flex items-center">
              <BarChart className="h-4 w-4 mr-2" />
              <span>
                Total allocation is {totalAllocation}%. For optimal task distribution, total should be 100%.
              </span>
            </p>
          </div>
        )}

        <div className="grid gap-4">
          {project.members.length === 0 ? (
            <div className="p-8 text-center bg-gray-50 rounded-lg">
              <p className="text-muted-foreground">
                No members assigned to this project yet. Add members to begin assigning tasks.
              </p>
            </div>
          ) : (
            project.members.map((member) => (
              <Card key={`${member.userId}-${refreshKey}`}>
                <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
                  <div className="flex items-center space-x-4">
                    <Avatar>
                      <AvatarFallback>
                        {member.userId.slice(0, 2).toUpperCase()}
                      </AvatarFallback>
                    </Avatar>
                    <div>
                      <CardTitle>{member.userId}</CardTitle>
                      <CardDescription>
                        {member.lastActivity
                          ? `Last active ${formatDistanceToNow(member.lastActivity, {
                              addSuffix: true,
                            })}`
                          : "No recent activity"}
                      </CardDescription>
                    </div>
                  </div>
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm">
                        <MoreVertical className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem 
                        className="text-red-600 cursor-pointer"
                        onClick={() => setMemberToRemove(member.userId)}
                      >
                        <Trash2 className="h-4 w-4 mr-2" />
                        Remove Member
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </CardHeader>
                <CardContent>
                  <div className="space-y-2">
                    <div className="flex items-center justify-between text-sm">
                      <div className="flex items-center gap-4">
                        <span>Task Completion</span>
                        <span className="font-medium">
                          {member.completedImages.length} / {member.assignedImages.length} images
                        </span>
                      </div>
                      <span className="font-medium">
                        {Math.round(getCompletionPercentage(member))}%
                      </span>
                    </div>
                    <Progress value={getCompletionPercentage(member)} />
                    <div className="flex justify-between text-sm text-muted-foreground">
                      <span className="font-medium text-primary">Allocation: {member.allocationPercentage}%</span>
                      <span>Time Spent: {member.timeSpent} minutes</span>
                    </div>
                  </div>
                </CardContent>
              </Card>
            ))
          )}
        </div>
      </div>

      <AddMemberDialog
        open={isAddMemberOpen}
        onOpenChange={setIsAddMemberOpen}
        projectId={project.id}
        currentMembers={project.members}
        onMembersUpdated={handleMembersUpdated}
      />

      <AlertDialog open={!!memberToRemove} onOpenChange={(isOpen) => !isOpen && setMemberToRemove(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Remove Team Member</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to remove this member from the project? 
              Their unfinished tasks will be redistributed among remaining team members.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isRemoving}>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleRemoveMember} 
              disabled={isRemoving}
              className="bg-red-600 hover:bg-red-700"
            >
              {isRemoving ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Removing...
                </>
              ) : (
                "Remove Member"
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

================
File: app/(admin)/components/projects/details/ProjectOverview.tsx
================
// app/(admin)/components/projects/details/ProjectOverview.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Progress } from "@/components/ui/progress";
import { ProjectStats } from "../ProjectStats";
import type { Project } from "@/lib/types/project";
import { ProjectsChart } from "../ProjectChart";

interface ProjectOverviewProps {
  project: Project;
}

export function ProjectOverview({ project }: ProjectOverviewProps) {
  const stats = {
    total: 1,
    active: project.status === 'active' ? 1 : 0,
    completed: project.status === 'completed' ? 1 : 0,
    totalImages: project.totalImages,
    completedAnnotations: project.stats.completedImages,
    reviewPending: project.stats.completedImages - project.stats.approvedImages
  };

  const completionRate = (project.stats.completedImages / project.totalImages) * 100;
  const approvalRate = (project.stats.approvedImages / project.totalImages) * 100;

  return (
    <div className="space-y-6">
      <ProjectStats loading={false} error={null} stats={stats} />

      <div className="grid gap-6 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Progress Overview</CardTitle>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span>Completion Rate</span>
                <span className="font-medium">{Math.round(completionRate)}%</span>
              </div>
              <Progress value={completionRate} />
            </div>

            <div className="space-y-2">
              <div className="flex justify-between text-sm">
                <span>Approval Rate</span>
                <span className="font-medium">{Math.round(approvalRate)}%</span>
              </div>
              <Progress value={approvalRate} className="bg-blue-100" />
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Progress Trend</CardTitle>
          </CardHeader>
          <CardContent>
            <ProjectsChart loading={false} projects={[project]} />
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: app/(admin)/components/projects/details/ProjectSettings.tsx
================
// app/(admin)/components/projects/details/ProjectSettings.tsx
import { useState } from "react";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import * as z from "zod";
import { toast } from "sonner";
import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormDescription,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Project, AnnotationFormat } from "@/lib/types/project";
import { updateProject } from "@/lib/apis/projects";

const formSchema = z.object({
  name: z.string().min(1, "Project name is required"),
  description: z.string().optional(),
  modelFormat: z.nativeEnum(AnnotationFormat),
  allowCustomClasses: z.boolean(),
  requireReview: z.boolean(),
  autoDistribute: z.boolean(),
  classes: z.string(), // Now expecting a comma-separated string
});

interface ProjectSettingsProps {
  project: Project;
  onUpdate: (project: Project) => void;
}

export function ProjectSettings({ project, onUpdate }: ProjectSettingsProps) {
  const [isSaving, setIsSaving] = useState(false);

  const form = useForm<z.infer<typeof formSchema>>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: project.name,
      description: project.description || "",
      modelFormat: project.settings.modelFormat,
      allowCustomClasses: project.settings.allowCustomClasses,
      requireReview: project.settings.requireReview,
      autoDistribute: project.settings.autoDistribute,
      classes: project.classes.join(", "), // Join with comma and space
    },
  });

  async function onSubmit(values: z.infer<typeof formSchema>) {
    setIsSaving(true);
    try {
      // Split the comma-separated classes string into an array
      const classesArray = values.classes
        .split(",")
        .map((c) => c.trim())
        .filter((c) => c.length > 0);

      const updateData = {
        name: values.name,
        description: values.description,
        settings: {
          modelFormat: values.modelFormat,
          allowCustomClasses: values.allowCustomClasses,
          requireReview: values.requireReview,
          autoDistribute: values.autoDistribute,
        },
        classes: classesArray,
      };

      const success = await updateProject(project.id, updateData);

      if (success) {
        // Create an updated project object to pass to onUpdate
        const updatedProject: Project = {
          ...project,
          name: values.name,
          description: values.description,
          settings: {
            ...project.settings,
            modelFormat: values.modelFormat,
            allowCustomClasses: values.allowCustomClasses,
            requireReview: values.requireReview,
            autoDistribute: values.autoDistribute,
          },
          classes: classesArray,
        };

        onUpdate(updatedProject);
        toast.success("Settings updated successfully");
      } else {
        throw new Error("Failed to update project");
      }
    } catch (err) {
      console.error("Failed to update settings:", err);
      toast.error("Failed to update settings");
    } finally {
      setIsSaving(false);
    }
  }

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <CardTitle>Project Settings</CardTitle>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              <FormField
                control={form.control}
                name="name"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Project Name</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Description</FormLabel>
                    <FormControl>
                      <Textarea {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="classes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Annotation Classes</FormLabel>
                    <FormControl>
                      <Input
                        {...field}
                        placeholder="Car, Truck, Pedestrian, Bicycle"
                      />
                    </FormControl>
                    <FormDescription>
                      Enter classes separated by commas
                    </FormDescription>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <FormField
                control={form.control}
                name="modelFormat"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Annotation Format</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Select format" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        <SelectItem value={AnnotationFormat.YOLO}>
                          YOLO
                        </SelectItem>
                        <SelectItem value={AnnotationFormat.COCO}>
                          COCO
                        </SelectItem>
                        <SelectItem value={AnnotationFormat.PASCAL_VOC}>
                          Pascal VOC
                        </SelectItem>
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <div className="space-y-4">
                <FormField
                  control={form.control}
                  name="allowCustomClasses"
                  render={({ field }) => (
                    <FormItem className="flex items-center justify-between rounded-lg border p-4">
                      <div className="space-y-0.5">
                        <FormLabel>Allow Custom Classes</FormLabel>
                        <FormDescription>
                          Let annotators add new classes during annotation
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={field.onChange}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="requireReview"
                  render={({ field }) => (
                    <FormItem className="flex items-center justify-between rounded-lg border p-4">
                      <div className="space-y-0.5">
                        <FormLabel>Require Review</FormLabel>
                        <FormDescription>
                          Require admin review for completed annotations
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={field.onChange}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="autoDistribute"
                  render={({ field }) => (
                    <FormItem className="flex items-center justify-between rounded-lg border p-4">
                      <div className="space-y-0.5">
                        <FormLabel>Auto-distribute Tasks</FormLabel>
                        <FormDescription>
                          Automatically distribute tasks based on allocation
                          percentages
                        </FormDescription>
                      </div>
                      <FormControl>
                        <Switch
                          checked={field.value}
                          onCheckedChange={field.onChange}
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />
              </div>

              <Button type="submit" disabled={isSaving}>
                {isSaving ? "Saving..." : "Save Changes"}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: app/(admin)/components/projects/details/UploadImagesDialog.tsx
================
// app/(admin)/components/projects/details/UploadImagesDialog.tsx
import { useState, useRef } from "react";
import { toast } from "sonner";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { Upload, X, FileImage, Loader2 } from "lucide-react";
import { cn } from "@/lib/utils";
import { uploadProjectImages } from "@/lib/apis/projects";

interface UploadImagesDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  projectId: string;
  onImagesUploaded?: () => void;
}

interface UploadFile extends File {
  preview?: string;
  progress?: number;
  error?: string;
}

export function UploadImagesDialog({
  open,
  onOpenChange,
  projectId,
  onImagesUploaded,
}: UploadImagesDialogProps) {
  const [files, setFiles] = useState<UploadFile[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFiles = Array.from(event.target.files || []).map((file) => ({
      ...file,
      preview: URL.createObjectURL(file),
      progress: 0,
    }));
    setFiles((prev) => [...prev, ...selectedFiles]);
  };

  const removeFile = (file: UploadFile) => {
    setFiles((prev) => prev.filter((f) => f !== file));
    if (file.preview) {
      URL.revokeObjectURL(file.preview);
    }
  };

  const uploadFiles = async () => {
    setIsUploading(true);
    try {
      // Use the API service to upload images
      const success = await uploadProjectImages('', projectId, files);
      
      if (success) {
        toast.success(`Successfully uploaded ${files.length} images`);
        // Call the callback to refresh the images list
        if (onImagesUploaded) {
          onImagesUploaded();
        }
        onOpenChange(false);
        setFiles([]);
      } else {
        throw new Error("Upload failed");
      }
    } catch (error) {
      console.error("Upload error:", error);
      toast.error("Failed to upload images");
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px]">
        <DialogHeader>
          <DialogTitle>Upload Images</DialogTitle>
          <DialogDescription>
            Upload images for annotation. Supports JPG, PNG formats.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div
            className={cn(
              "border-2 border-dashed rounded-lg p-8 text-center",
              "hover:border-primary/50 transition-colors duration-200",
              "cursor-pointer"
            )}
            onClick={() => fileInputRef.current?.click()}
          >
            <input
              type="file"
              ref={fileInputRef}
              className="hidden"
              multiple
              accept="image/*"
              onChange={handleFileSelect}
            />
            <div className="flex flex-col items-center gap-2">
              <Upload className="h-8 w-8 text-muted-foreground" />
              <p className="text-sm font-medium">
                Click to upload or drag and drop
              </p>
              <p className="text-xs text-muted-foreground">
                Supported formats: JPG, PNG
              </p>
            </div>
          </div>

          {files.length > 0 && (
            <div className="space-y-2">
              {files.map((file, index) => (
                <div
                  key={index}
                  className="flex items-center gap-4 p-2 border rounded-lg"
                >
                  <FileImage className="h-8 w-8 text-blue-500" />
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium truncate">{file.name}</p>
                    <Progress value={file.progress} className="h-1" />
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    className="text-red-500 hover:text-red-700"
                    onClick={() => removeFile(file)}
                    disabled={isUploading}
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}

          <div className="flex justify-end gap-2">
            <Button
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={isUploading}
            >
              Cancel
            </Button>
            <Button
              onClick={uploadFiles}
              disabled={files.length === 0 || isUploading}
            >
              {isUploading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Uploading...
                </>
              ) : (
                <>Upload {files.length} files</>
              )}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}

================
File: app/(admin)/components/projects/ProjectCard.tsx
================
// app/(admin)/components/projects/ProjectCard.tsx
import { Card, CardHeader, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import { Button } from "@/components/ui/button";
import { MoreVertical, Users, Image as ImageIcon, Clock } from "lucide-react";
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuTrigger 
} from "@/components/ui/dropdown-menu";
import type { Project } from "@/lib/types/project";
import { formatDistanceToNow } from "date-fns";

interface ProjectCardProps {
  project: Project;
  onClick: () => void;
}

export function ProjectCard({ project, onClick }: ProjectCardProps) {
  const progressPercentage = Math.round(
    (project.stats.completedImages / project.totalImages) * 100
  );

  const statusColors = {
    active: "bg-green-100 text-green-800",
    completed: "bg-blue-100 text-blue-800",
    archived: "bg-gray-100 text-gray-800",
    draft: "bg-yellow-100 text-yellow-800"
  };

  return (
    <Card className="hover:shadow-lg transition-shadow duration-200 cursor-pointer" onClick={onClick}>
      <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
        <div className="space-y-1">
          <h3 className="font-semibold text-lg">{project.name}</h3>
          <Badge variant="secondary" className={statusColors[project.status]}>
            {project.status.charAt(0).toUpperCase() + project.status.slice(1)}
          </Badge>
        </div>
        <DropdownMenu>
          <DropdownMenuTrigger asChild onClick={e => e.stopPropagation()}>
            <Button variant="ghost" size="sm">
              <MoreVertical className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem>View Details</DropdownMenuItem>
            <DropdownMenuItem>Manage Members</DropdownMenuItem>
            <DropdownMenuItem>Archive Project</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </CardHeader>

      <CardContent>
        {project.description && (
          <p className="text-sm text-muted-foreground line-clamp-2 mb-4">
            {project.description}
          </p>
        )}

        <div className="space-y-4">
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-1.5">
              <Users className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm font-medium">
                {project.members?.length || 0} Members
              </span>
            </div>
            <div className="flex items-center gap-1.5">
              <ImageIcon className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm font-medium">
                {project.totalImages} Images
              </span>
            </div>
          </div>

          <div className="space-y-2">
            <div className="flex justify-between text-sm">
              <span>Progress</span>
              <span className="font-medium">{progressPercentage}%</span>
            </div>
            <Progress value={progressPercentage} />
          </div>
        </div>
      </CardContent>

      <CardFooter>
        <div className="flex items-center gap-1.5 text-sm text-muted-foreground">
          <Clock className="h-4 w-4" />
          Last active {formatDistanceToNow(project.stats.lastActivity, { addSuffix: true })}
        </div>
      </CardFooter>
    </Card>
  );
}

================
File: app/(admin)/components/projects/ProjectChart.tsx
================
// app/(admin)/components/projects/ProjectsChart.tsx
"use client";

import { useMemo } from "react";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import type { Project } from "@/lib/types/project";
import { Skeleton } from "@/components/ui/skeleton";

interface ProjectsChartProps {
  loading: boolean;
  projects: Project[];
}

export function ProjectsChart({ loading, projects }: ProjectsChartProps) {
  const chartData = useMemo(() => {
    const last7Days = [...Array(7)].map((_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - i);
      return date.toISOString().split('T')[0];
    }).reverse();

    return last7Days.map(date => {
      const dayStats = projects.reduce((acc, project) => {
        // Count annotations completed on this date
        const completedToday = project.stats.completedImages;
        const approvedToday = project.stats.approvedImages;

        return {
          completed: acc.completed + completedToday,
          approved: acc.approved + approvedToday
        };
      }, { completed: 0, approved: 0 });

      return {
        date,
        completed: dayStats.completed,
        approved: dayStats.approved
      };
    });
  }, [projects]);

  if (loading) {
    return <Skeleton className="h-[350px] w-full" />;
  }

  return (
    <ResponsiveContainer width="100%" height={350}>
      <LineChart data={chartData}>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis 
          dataKey="date" 
          tickFormatter={(value) => new Date(value).toLocaleDateString()} 
        />
        <YAxis />
        <Tooltip 
          labelFormatter={(value) => new Date(value).toLocaleDateString()}
        />
        <Line 
          type="monotone" 
          dataKey="completed" 
          stroke="#2563eb" 
          name="Completed"
        />
        <Line 
          type="monotone" 
          dataKey="approved" 
          stroke="#16a34a" 
          name="Approved"
        />
      </LineChart>
    </ResponsiveContainer>
  );
}

================
File: app/(admin)/components/projects/ProjectHeader.tsx
================
// app/(admin)/components/projects/ProjectHeader.tsx
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { 
  ArrowLeft, 
  MoreVertical, 
  Archive, 
  Trash2 
} from "lucide-react";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import type { Project } from "@/lib/types/project";

interface ProjectHeaderProps {
  project: Project;
}

export function ProjectHeader({ project }: ProjectHeaderProps) {
  const router = useRouter();

  const statusColors = {
    active: "bg-green-100 text-green-800",
    completed: "bg-blue-100 text-blue-800",
    archived: "bg-gray-100 text-gray-800",
    draft: "bg-yellow-100 text-yellow-800"
  };

  return (
    <div className="flex items-center justify-between">
      <div className="flex items-center gap-4">
        <Button
          variant="ghost"
          size="sm"
          onClick={() => router.back()}
        >
          <ArrowLeft className="h-4 w-4 mr-2" />
          Back
        </Button>

        <div>
          <h1 className="text-2xl font-bold">{project.name}</h1>
          <div className="flex items-center gap-2 mt-1">
            <Badge className={statusColors[project.status]}>
              {project.status.charAt(0).toUpperCase() + project.status.slice(1)}
            </Badge>
            <span className="text-sm text-muted-foreground">
              Created {new Date(project.createdAt).toLocaleDateString()}
            </span>
          </div>
        </div>
      </div>

      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button variant="ghost" size="icon">
            <MoreVertical className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end">
          <DropdownMenuItem className="text-muted-foreground">
            <Archive className="h-4 w-4 mr-2" />
            Archive Project
          </DropdownMenuItem>
          <DropdownMenuItem className="text-red-600">
            <Trash2 className="h-4 w-4 mr-2" />
            Delete Project
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
    </div>
  );
}

================
File: app/(admin)/components/projects/ProjectList.tsx
================
// app/(admin)/components/projects/ProjectList.tsx
import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { getAllProjects } from "@/lib/apis/projects";
import type { Project } from "@/lib/types/project";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Skeleton } from "@/components/ui/skeleton";
import { ProjectCard } from "./ProjectCard";
import { toast } from "sonner";

interface ProjectsListProps {
  showArchived?: boolean;
}

export function ProjectsList({ showArchived = false }: ProjectsListProps) {
  const router = useRouter();
  const [loading, setLoading] = useState(true);
  const [projects, setProjects] = useState<Project[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState("lastActivity");

  useEffect(() => {
    async function fetchProjects() {
      try {
        setLoading(true);
        const data = await getAllProjects();
        
        // Log what we get from the API to debug
        console.log("Projects from API:", data);
        
        setProjects(data.projects);
      } catch (err) {
        console.error("Failed to load projects:", err);
        toast.error("Failed to load projects");
      } finally {
        setLoading(false);
      }
    }

    fetchProjects();
  }, [showArchived]);

  // Filter and sort projects
  const filteredProjects = projects
    .filter(p => {
      // Filter by status (archived or not)
      const statusMatch = showArchived 
        ? p.status === 'archived' 
        : p.status !== 'archived';
      
      // Filter by search query
      const searchMatch = p.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        p.description?.toLowerCase().includes(searchQuery.toLowerCase());
      
      return statusMatch && searchMatch;
    })
    .sort((a, b) => {
      switch (sortBy) {
        case "name":
          return a.name.localeCompare(b.name);
        case "createdAt":
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        case "lastActivity":
          return new Date(b.stats.lastActivity).getTime() - new Date(a.stats.lastActivity).getTime();
        default:
          return 0;
      }
    });

  if (loading) {
    return (
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {[...Array(6)].map((_, i) => (
          <Skeleton key={i} className="h-[200px] rounded-lg" />
        ))}
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Filters */}
      <div className="flex items-center gap-4">
        <Input
          placeholder="Search projects..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="max-w-sm"
        />
        <Select
          value={sortBy}
          onValueChange={setSortBy}
        >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Sort by" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="name">Name</SelectItem>
            <SelectItem value="createdAt">Created Date</SelectItem>
            <SelectItem value="lastActivity">Last Activity</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {filteredProjects.length === 0 ? (
        <div className="p-8 text-center bg-gray-50 rounded-lg">
          <p className="text-muted-foreground">
            {searchQuery 
              ? "No projects found matching your search" 
              : showArchived 
                ? "No archived projects found" 
                : "No active projects found"}
          </p>
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {filteredProjects.map((project) => (
            <ProjectCard
              key={project.id}
              project={project}
              onClick={() => router.push(`/admin/projects/${project.id}`)}
            />
          ))}
        </div>
      )}
    </div>
  );
}

================
File: app/(admin)/components/projects/ProjectOverview.tsx
================
// app/(admin)/components/projects/ProjectOverview.tsx
import { useEffect, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { getAllProjects } from "@/lib/apis/projects";
import type { Project } from "@/lib/types/project";
import { ProjectsChart } from "./ProjectChart";
import { ProjectStats } from "./ProjectStats";
import { RecentActivity } from "./RecentActivity";

export function ProjectsOverview() {
  const [loading, setLoading] = useState(true);
  const [projects, setProjects] = useState<Project[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchProjects() {
      try {
        setLoading(true);
        const data = await getAllProjects();
        setProjects(data.projects);
        setError(null);
      } catch (err) {
        setError("Failed to load projects");
        console.error("Error fetching projects:", err);
      } finally {
        setLoading(false);
      }
    }

    fetchProjects();
  }, []);

  // Calculate overall stats
  const stats = {
    total: projects.length,
    active: projects.filter(p => p.status === 'active').length,
    completed: projects.filter(p => p.status === 'completed').length,
    totalImages: projects.reduce((acc, p) => acc + p.totalImages, 0),
    completedAnnotations: projects.reduce((acc, p) => acc + p.stats.completedImages, 0),
    reviewPending: projects.reduce(
      (acc, p) => acc + (p.stats.completedImages - p.stats.approvedImages), 
      0
    ),
  };

  return (
    <div className="space-y-8">
      {/* Stats Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        <ProjectStats 
          loading={loading} 
          error={error} 
          stats={stats} 
        />
      </div>

      {/* Charts and Analytics */}
      <div className="grid gap-4 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Annotation Progress</CardTitle>
          </CardHeader>
          <CardContent>
            <ProjectsChart 
              loading={loading} 
              projects={projects} 
            />
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Recent Activity</CardTitle>
          </CardHeader>
          <CardContent>
            <RecentActivity 
              loading={loading} 
              projects={projects} 
            />
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: app/(admin)/components/projects/ProjectStats.tsx
================
// app/(admin)/components/projects/ProjectStats.tsx
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";
import { Folder, Image as ImageIcon, CheckCircle } from "lucide-react";

interface ProjectStatsProps {
  loading: boolean;
  error: string | null;
  stats: {
    total: number;
    active: number;
    completed: number;
    totalImages: number;
    completedAnnotations: number;
    reviewPending: number;
  };
}

export function ProjectStats({ loading, error, stats }: ProjectStatsProps) {
  if (loading) {
    return (
      <>
        {[...Array(6)].map((_, i) => (
          <Skeleton key={i} className="h-[120px] rounded-lg" />
        ))}
      </>
    );
  }

  if (error) {
    return (
      <div className="col-span-full p-4 bg-red-50 text-red-700 rounded-lg">
        {error}
      </div>
    );
  }

  const statCards = [
    {
      title: "Total Projects",
      value: stats.total,
      icon: Folder,
      description: `${stats.active} active, ${stats.completed} completed`
    },
    {
      title: "Total Images",
      value: stats.totalImages,
      icon: ImageIcon,
      description: "Across all projects"
    },
    {
      title: "Completed Annotations",
      value: stats.completedAnnotations,
      icon: CheckCircle,
      description: `${stats.reviewPending} pending review`
    }
  ];

  return (
    <>
      {statCards.map((stat, i) => (
        <Card key={i}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">
              {stat.title}
            </CardTitle>
            <stat.icon className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stat.value}</div>
            <p className="text-xs text-muted-foreground">
              {stat.description}
            </p>
          </CardContent>
        </Card>
      ))}
    </>
  );
}

================
File: app/(admin)/components/projects/RecentActivity.tsx
================
// app/(admin)/components/projects/RecentActivity.tsx
import { useMemo } from "react";
import { formatDistanceToNow } from "date-fns";
import type { Project } from "@/lib/types/project";
import { Skeleton } from "@/components/ui/skeleton";
import { ScrollArea } from "@/components/ui/scroll-area";

interface RecentActivityProps {
  loading: boolean;
  projects: Project[];
}

export function RecentActivity({ loading, projects }: RecentActivityProps) {
  const activities = useMemo(() => {
    return projects
      .map((project) => ({
        projectId: project.id,
        projectName: project.name,
        activity: "Last updated",
        timestamp: project.stats.lastActivity,
        details: `${project.stats.completedImages} images completed`,
      }))
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, 10);
  }, [projects]);

  if (loading) {
    return (
      <div className="space-y-4">
        {[...Array(5)].map((_, i) => (
          <Skeleton key={i} className="h-[60px] w-full" />
        ))}
      </div>
    );
  }

  return (
    <ScrollArea className="h-[400px] pr-4">
      <div className="space-y-4">
        {activities.map((activity, i) => (
          <div
            key={`${activity.projectId}-${i}`}
            className="flex items-center justify-between py-2"
          >
            <div className="space-y-1">
              <p className="text-sm font-medium">{activity.projectName}</p>
              <p className="text-sm text-muted-foreground">
                {activity.details}
              </p>
            </div>
            <span className="text-sm text-muted-foreground">
              {formatDistanceToNow(activity.timestamp, { addSuffix: true })}
            </span>
          </div>
        ))}
      </div>
    </ScrollArea>
  );
}

================
File: app/(admin)/components/SecurityLogPage.tsx
================
"use client";

import { useEffect, useState, useCallback, useMemo } from "react";
import { SecurityLogType, SecurityLog } from "@/lib/types/logs";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { ScrollArea } from "@/components/ui/scroll-area";
import { toast } from "sonner";
import {
  Loader2,
  ChevronLeft,
  ChevronRight,
  ArrowUpDown,
  Info,
} from "lucide-react";
import { LastUpdated } from "./users/LastUpdated";
import {
  getSecurityLogs,
  LogsResponse,
  SecurityLogFilters,
} from "@/lib/apis/logs";

type SortField = "userId" | "logType" | "timestamp" | "ip";
type SortOrder = "asc" | "desc";

interface SortConfig {
  field: SortField;
  order: SortOrder;
}

interface LogTypeGroup {
  label: string;
  types: SecurityLogType[];
}

const LOG_TYPE_GROUPS: LogTypeGroup[] = [
  {
    label: "Authentication Events",
    types: [
      SecurityLogType.LOGIN_SUCCESS,
      SecurityLogType.LOGIN_FAILED,
      SecurityLogType.LOGIN_ATTEMPT_LOCKED,
      SecurityLogType.ADMIN_LOGIN,
      SecurityLogType.USER_LOGOUT,
    ],
  },
  {
    label: "Account Events",
    types: [
      SecurityLogType.ACCOUNT_LOCKED,
      SecurityLogType.ACCOUNT_UNLOCKED,
      SecurityLogType.PASSWORD_RESET,
      SecurityLogType.ADMIN_PASSWORD_RESET,
      SecurityLogType.ADMIN_REVOKED,
      SecurityLogType.USER_DELETED,
      SecurityLogType.ADMIN_DELETED,
      SecurityLogType.PROJECT_SUBMITTED,
      SecurityLogType.PROJECT_UNMARKED,
      SecurityLogType.USER_UPDATED,
    ],
  },
  {
    label: "Project Events",
    types: [
      SecurityLogType.PROJECT_SUBMITTED,
      SecurityLogType.PROJECT_UNMARKED,
    ],
  },
  {
    label: "Security Events",
    types: [
      SecurityLogType.DEVICE_CHANGE,
      SecurityLogType.DEVICE_MISMATCH,
      SecurityLogType.SUSPICIOUS_ACTIVITY,
      SecurityLogType.RATE_LIMIT_EXCEEDED,
    ],
  },
  {
    label: "Client Security",
    types: [
      SecurityLogType.INSPECT_ELEMENT,
      SecurityLogType.SCREENSHOT_ATTEMPT,
      SecurityLogType.SCREEN_RECORD_ATTEMPT,
      SecurityLogType.KEYBOARD_SHORTCUT,
    ],
  },
  {
    label: "System Events",
    types: [
      SecurityLogType.USER_CREATED,
      SecurityLogType.ADMIN_CREATED,
      SecurityLogType.UNAUTHORIZED_ACCESS,
    ],
  },
];

const generatePaginationRange = (currentPage: number, totalPages: number) => {
  const delta = 2; // Number of pages to show on each side of current page
  const range: (number | string)[] = [];

  // Start range
  for (let i = 1; i <= Math.min(3, totalPages); i++) {
    range.push(i);
  }
  if (currentPage - delta > 4) {
    range.push("...");
  }

  // Middle range
  for (
    let i = Math.max(4, currentPage - delta);
    i <= Math.min(totalPages - 3, currentPage + delta);
    i++
  ) {
    range.push(i);
  }

  // End range
  if (currentPage + delta < totalPages - 3) {
    range.push("...");
  }
  for (
    let i = Math.max(totalPages - 2, Math.min(totalPages, 4));
    i <= totalPages;
    i++
  ) {
    range.push(i);
  }

  return [...new Set(range)]; // Remove duplicates
};

export default function SecurityLogsPage() {
  const [logs, setLogs] = useState<SecurityLog[]>([]);
  const [loading, setLoading] = useState(true);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [searchQuery, setSearchQuery] = useState("");
  const [selectedLogType, setSelectedLogType] = useState<string>("all");
  const [sort, setSort] = useState<SortConfig>({
    field: "timestamp",
    order: "desc",
  });
  const [lastRefreshed, setLastRefreshed] = useState<Date>(new Date());
  const [selectedLog, setSelectedLog] = useState<SecurityLog | null>(null);

  const fetchLogs = useCallback(
    async (showLoading = true) => {
      if (showLoading) setLoading(true);
      try {
        const filters: SecurityLogFilters = {
          page: currentPage,
          limit: 10,
        };

        if (searchQuery) {
          filters.userId = searchQuery;
        }

        if (selectedLogType !== "all") {
          filters.logType = selectedLogType as SecurityLogType;
        }

        // Use the getSecurityLogs API function instead of direct fetchWithAuth
        const response: LogsResponse = await getSecurityLogs(filters);

        setLogs(response.logs);
        setTotalPages(response.pagination.totalPages);
        setLastRefreshed(new Date());
      } catch (error) {
        toast.error("Failed to fetch security logs");
        console.error("Error fetching logs:", error);
      } finally {
        if (showLoading) setLoading(false);
      }
    },
    [currentPage, searchQuery, selectedLogType]
  );

  useEffect(() => {
    void fetchLogs();
  }, [fetchLogs]);

  const getSeverityColor = useCallback((logType: SecurityLogType): string => {
    // High severity - Red
    if (
      [
        SecurityLogType.SUSPICIOUS_ACTIVITY,
        SecurityLogType.LOGIN_ATTEMPT_LOCKED,
        SecurityLogType.ACCOUNT_LOCKED,
        SecurityLogType.ADMIN_REVOKED,
        SecurityLogType.UNAUTHORIZED_ACCESS,
        SecurityLogType.USER_DELETED,
        SecurityLogType.ADMIN_DELETED,
      ].includes(logType)
    ) {
      return "bg-red-50 text-red-700";
    }

    // Warning - Yellow
    if (
      [
        SecurityLogType.LOGIN_FAILED,
        SecurityLogType.DEVICE_MISMATCH,
        SecurityLogType.RATE_LIMIT_EXCEEDED,
        SecurityLogType.INSPECT_ELEMENT,
        SecurityLogType.SCREENSHOT_ATTEMPT,
        SecurityLogType.SCREEN_RECORD_ATTEMPT,
        SecurityLogType.PROJECT_UNMARKED, // Added here as it's a warning state
      ].includes(logType)
    ) {
      return "bg-yellow-50 text-yellow-700";
    }

    // Info - Blue
    if (
      [
        SecurityLogType.DEVICE_CHANGE,
        SecurityLogType.PASSWORD_RESET,
        SecurityLogType.ADMIN_PASSWORD_RESET,
        SecurityLogType.USER_CREATED,
        SecurityLogType.ADMIN_CREATED,
        SecurityLogType.PROJECT_SUBMITTED, // Added here as it's an info state
        SecurityLogType.USER_UPDATED,
      ].includes(logType)
    ) {
      return "bg-blue-50 text-blue-700";
    }

    // Success - Green
    return "bg-green-50 text-green-700";
  }, []);

  const handleSort = useCallback((field: SortField) => {
    setSort((prev) => ({
      field,
      order: prev.field === field && prev.order === "asc" ? "desc" : "asc",
    }));
  }, []);

  const handleSearch = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(e.target.value);
    setCurrentPage(1);
  }, []);

  const handleLogTypeChange = useCallback((value: string) => {
    setSelectedLogType(value);
    setCurrentPage(1);
  }, []);

  const handleManualRefresh = useCallback(() => {
    void fetchLogs(true);
    toast.success("Logs refreshed");
  }, [fetchLogs]);

  const SortIndicator = useCallback(
    ({ field }: { field: SortField }) => (
      <ArrowUpDown
        className={`ml-1 h-4 w-4 inline-block transition-colors ${
          sort.field === field ? "text-primary" : "text-gray-400"
        }`}
      />
    ),
    [sort.field]
  );

  // For log details
  const formatLogDetails = useMemo(() => {
    if (!selectedLog) return [];

    const details: { label: string; value: string }[] = [
      { label: "User ID", value: selectedLog.userId },
      { label: "Event Type", value: selectedLog.logType.replace(/_/g, " ") },
      {
        label: "Timestamp",
        value: new Date(selectedLog.timestamp).toLocaleString(),
      },
      { label: "IP Address", value: selectedLog.details.ip },
      { label: "User Agent", value: selectedLog.details.userAgent },
    ];

    if (selectedLog.details.path) {
      details.push({ label: "Path", value: selectedLog.details.path });
    }

    if (selectedLog.details.keyPressed) {
      details.push({
        label: "Key Pressed",
        value: selectedLog.details.keyPressed,
      });
    }

    if (selectedLog.details.requestCount) {
      details.push({
        label: "Request Count",
        value: selectedLog.details.requestCount.toString(),
      });
    }

    if (selectedLog.details.deviceInfo) {
      details.push({
        label: "Device Info",
        value: selectedLog.details.deviceInfo,
      });
    }

    // Add special handling for project-related logs
    if (
      selectedLog.logType === SecurityLogType.PROJECT_SUBMITTED ||
      selectedLog.logType === SecurityLogType.PROJECT_UNMARKED
    ) {
      if (selectedLog.details.additionalInfo) {
        details.push({
          label: "Project Details",
          value: selectedLog.details.additionalInfo,
        });
      }
    }

    // Handle user update logs
    if (selectedLog.logType === SecurityLogType.USER_UPDATED) {
      if (selectedLog.details.additionalInfo) {
        details.push({
          label: "Update Details",
          value: selectedLog.details.additionalInfo,
        });
      }
    }

    return details;
  }, [selectedLog]);

  const getEventDescription = useCallback(
    (logType: SecurityLogType, details: SecurityLog["details"]): string => {
      switch (logType) {
        case SecurityLogType.PROJECT_SUBMITTED:
          return `Project submitted for review - ${
            details.additionalInfo || ""
          }`;
        case SecurityLogType.PROJECT_UNMARKED:
          return `Project marked as incomplete - ${
            details.additionalInfo || ""
          }`;
        case SecurityLogType.USER_DELETED:
          return `User account deleted`;
        case SecurityLogType.ADMIN_DELETED:
          return `Admin account deleted - ${details.additionalInfo || ""}`;
        case SecurityLogType.USER_UPDATED:
          return `User settings updated - ${details.additionalInfo || ""}`;
        default:
          return details.additionalInfo || "";
      }
    },
    []
  );

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader className="flex flex-row items-center justify-between">
          <CardTitle>Security Logs</CardTitle>
          <LastUpdated
            timestamp={lastRefreshed}
            onRefresh={() => handleManualRefresh()}
          />
        </CardHeader>
        <CardContent>
          <div className="flex items-center gap-4 mb-6">
            <Input
              placeholder="Search by user ID..."
              className="max-w-xs"
              value={searchQuery}
              onChange={handleSearch}
            />
            <Select value={selectedLogType} onValueChange={handleLogTypeChange}>
              <SelectTrigger className="w-[220px]">
                <SelectValue placeholder="Select event type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Events</SelectItem>
                {LOG_TYPE_GROUPS.map((group) => (
                  <SelectGroup key={group.label}>
                    <SelectLabel className="font-semibold">
                      {group.label}
                    </SelectLabel>
                    {group.types.map((type) => (
                      <SelectItem key={type} value={type}>
                        {type.replace(/_/g, " ")}
                      </SelectItem>
                    ))}
                  </SelectGroup>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div className="rounded-md border">
            <Table>
              <TableHeader>
                <TableRow>
                  <TableHead
                    className="cursor-pointer hover:bg-muted/50"
                    onClick={() => handleSort("userId")}
                  >
                    User ID <SortIndicator field="userId" />
                  </TableHead>
                  <TableHead
                    className="cursor-pointer hover:bg-muted/50"
                    onClick={() => handleSort("logType")}
                  >
                    Event Type <SortIndicator field="logType" />
                  </TableHead>
                  <TableHead
                    className="cursor-pointer hover:bg-muted/50"
                    onClick={() => handleSort("ip")}
                  >
                    IP Address <SortIndicator field="ip" />
                  </TableHead>
                  <TableHead>User Agent</TableHead>
                  <TableHead
                    className="cursor-pointer hover:bg-muted/50"
                    onClick={() => handleSort("timestamp")}
                  >
                    Timestamp <SortIndicator field="timestamp" />
                  </TableHead>
                  <TableHead className="w-[50px]">Details</TableHead>
                </TableRow>
              </TableHeader>
              <TableBody>
                {loading ? (
                  <TableRow>
                    <TableCell colSpan={6} className="h-32 text-center">
                      <div className="flex items-center justify-center">
                        <Loader2 className="h-8 w-8 animate-spin text-gray-500" />
                      </div>
                    </TableCell>
                  </TableRow>
                ) : logs.length === 0 ? (
                  <TableRow>
                    <TableCell
                      colSpan={6}
                      className="h-32 text-center text-muted-foreground"
                    >
                      No logs found
                    </TableCell>
                  </TableRow>
                ) : (
                  logs.map((log) => (
                    <TableRow key={log._id} className="group">
                      <TableCell className="font-medium">
                        {log.userId}
                      </TableCell>
                      <TableCell>
                        <span
                          className={`inline-flex items-center rounded-full px-2 py-1 text-xs font-medium ${getSeverityColor(
                            log.logType
                          )}`}
                        >
                          {log.logType.replace(/_/g, " ")}
                        </span>
                      </TableCell>
                      <TableCell>{log.details.ip}</TableCell>
                      <TableCell
                        className="max-w-xs truncate"
                        title={log.details.userAgent}
                      >
                        {log.details.userAgent}
                      </TableCell>
                      <TableCell>
                        {new Date(log.timestamp).toLocaleString()}
                      </TableCell>
                      <TableCell>
                        {getEventDescription(log.logType, log.details)}
                      </TableCell>
                      <TableCell>
                        <Button
                          variant="ghost"
                          size="sm"
                          className="opacity-0 group-hover:opacity-100 transition-opacity"
                          onClick={() => setSelectedLog(log)}
                        >
                          <Info className="h-4 w-4" />
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))
                )}
              </TableBody>
            </Table>
          </div>

          {totalPages > 1 && (
            <div className="mt-4 flex items-center justify-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => setCurrentPage((p) => Math.max(1, p - 1))}
                disabled={currentPage === 1}
                className="flex items-center gap-1"
              >
                <ChevronLeft className="h-4 w-4" />
                Prev
              </Button>

              <div className="flex items-center gap-1">
                {generatePaginationRange(currentPage, totalPages).map(
                  (page, idx) => {
                    if (page === "...") {
                      return (
                        <div key={`ellipsis-${idx}`} className="px-2">
                          ...
                        </div>
                      );
                    }

                    return (
                      <Button
                        key={page}
                        variant={currentPage === page ? "default" : "outline"}
                        size="sm"
                        onClick={() => setCurrentPage(page as number)}
                        className="w-8 h-8 p-0"
                      >
                        {page}
                      </Button>
                    );
                  }
                )}
              </div>

              <Button
                variant="outline"
                size="sm"
                onClick={() =>
                  setCurrentPage((p) => Math.min(totalPages, p + 1))
                }
                disabled={currentPage === totalPages}
                className="flex items-center gap-1"
              >
                Next
                <ChevronRight className="h-4 w-4" />
              </Button>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Log Details Sheet */}
      <Sheet open={!!selectedLog} onOpenChange={() => setSelectedLog(null)}>
        <SheetContent>
          <SheetHeader>
            <SheetTitle>Log Details</SheetTitle>
          </SheetHeader>
          <ScrollArea className="h-[calc(100vh-8rem)] mt-8">
            <div className="space-y-6">
              {formatLogDetails.map((detail, index) => (
                <div key={index} className="space-y-1">
                  <p className="text-sm font-medium text-muted-foreground">
                    {detail.label}
                  </p>
                  <p className="text-sm break-all">{detail.value}</p>
                </div>
              ))}
            </div>
          </ScrollArea>
        </SheetContent>
      </Sheet>
    </div>
  );
}

================
File: app/(admin)/components/SidePanel.tsx
================
import { Sheet, SheetContent, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { RefreshCw } from "lucide-react";
import { cn } from "@/lib/utils";

interface SidePanelProps {
  open: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
  className?: string;
  onRefresh?: () => void;
  actionButtons?: React.ReactNode;
}

export function SidePanel({ 
  open, 
  onClose, 
  title, 
  children, 
  className,
  onRefresh,
  actionButtons
}: SidePanelProps) {
  return (
    <Sheet 
      open={open} 
      onOpenChange={(isOpen) => !isOpen && onClose()}
      modal={true}
    >
      <SheetContent 
        side="right" 
        className={cn("w-[400px] sm:w-[540px]", className)}
        onPointerDownOutside={(e) => {
          e.preventDefault();
        }}
        onInteractOutside={(e) => {
          e.preventDefault();
        }}
      >
        <SheetHeader className="flex flex-row items-center justify-between pr-8">
          <SheetTitle>{title}</SheetTitle>
          <div className="flex items-center gap-2">
            {onRefresh && (
              <Button
                variant="outline"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation();
                  onRefresh();
                }}
                className="h-8 w-8 p-0"
              >
                <RefreshCw className="h-4 w-4" />
              </Button>
            )}
            {actionButtons}
          </div>
        </SheetHeader>
        <ScrollArea className="h-[calc(100vh-8rem)] mt-8 overflow-y-auto">
          {children}
        </ScrollArea>
      </SheetContent>
    </Sheet>
  );
}

================
File: app/(auth)/components/FormFields.tsx
================
// app/(auth)/components/form-fields.tsx
'use client';

import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { User, KeyRound } from "lucide-react";

interface FormFieldsProps {
  isPending: boolean;
  error: boolean;
}

export function FormFields({ isPending, error }: FormFieldsProps) {
  return (
    <div className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="username">Username</Label>
        <div className="relative">
          <User className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            id="username"
            name="username"
            type="text"
            required
            placeholder="Enter your username"
            autoComplete="username"
            disabled={isPending}
            className={`pl-9 ${error ? 'border-destructive' : ''}`}
          />
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="password">Password</Label>
        <div className="relative">
          <KeyRound className="absolute left-3 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            id="password"
            name="password"
            type="password"
            required
            placeholder="Enter your password"
            autoComplete="current-password"
            disabled={isPending}
            className={`pl-9 ${error ? 'border-destructive' : ''}`}
          />
        </div>
      </div>
    </div>
  );
}

================
File: app/(auth)/components/LoginForm.tsx
================
// app/(auth)/components/login-form.tsx
"use client";

import { useState, useTransition } from "react";
import { Button } from "@/components/ui/button";
import { Loader2 } from "lucide-react";
import { login } from "@/lib/actions/auth";
import { toast } from "sonner";
import { FormFields } from "./FormFields";

export default function LoginForm() {
  const [isPending, startTransition] = useTransition();
  const [error, setError] = useState<boolean>(false);

  async function onSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setError(false);

    const form = event.currentTarget;
    const formData = new FormData(form);
    const username = formData.get("username") as string;
    const password = formData.get("password") as string;

    if (!username || !password) {
      toast.error("Missing required fields", {
        description: "Please fill in both username and password",
      });
      setError(true);
      return;
    }

    startTransition(async () => {
      try {
        const credentials = {
          username,
          password,
          deviceInfo: {
            platform: navigator?.platform || "unknown",
            screenResolution:
              typeof window !== "undefined"
                ? `${window.screen.width}x${window.screen.height}`
                : "unknown",
            language: navigator?.language || "unknown",
            timezone:
              typeof Intl !== "undefined"
                ? Intl.DateTimeFormat().resolvedOptions().timeZone
                : "UTC",
          },
        };

        await login(credentials);
      } catch (err) {
        const errorMessage =
          err instanceof Error ? err.message : "An error occurred";

        if (errorMessage.includes("Invalid credentials")) {
          toast.error("Login Failed", {
            description: "Incorrect username or password. Please try again.",
          });
        } else if (errorMessage.includes("locked")) {
          toast.error("Account Locked", {
            description:
              "Your account has been locked due to multiple failed attempts. Please contact support.",
          });
        } else if (errorMessage.includes("device")) {
          toast.error("New Device Detected", {
            description:
              "This login attempt is from a new device. Please verify your identity.",
          });
        } else {
          toast.error("Error", {
            description:
              "An unexpected error occurred. Please try again later.",
          });
        }

        setError(true);
        // Reset password field
        const passwordInput = form.elements.namedItem(
          "password"
        ) as HTMLInputElement;
        if (passwordInput) {
          passwordInput.value = "";
        }
      }
    });
  }

  return (
    <form onSubmit={onSubmit} className="space-y-6">
      <FormFields isPending={isPending} error={error} />

      <Button
        type="submit"
        className="w-full"
        disabled={isPending}
        variant={error ? "destructive" : "default"}
      >
        {isPending ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Signing in...
          </>
        ) : (
          "Sign in"
        )}
      </Button>
    </form>
  );
}

================
File: app/(auth)/login/loading.tsx
================
// app/(auth)/login/loading.tsx
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Skeleton } from "@/components/ui/skeleton";

export default function LoginLoading() {
  return (
    <main className="min-h-screen w-full flex items-center justify-center bg-background p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-2">
          <div className="flex flex-col items-center justify-center">
            <Skeleton className="w-24 h-24 rounded-full" />
          </div>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="space-y-2">
              <Skeleton className="h-4 w-[100px]" />
              <Skeleton className="h-10 w-full" />
            </div>
            <div className="space-y-2">
              <Skeleton className="h-4 w-[100px]" />
              <Skeleton className="h-10 w-full" />
            </div>
          </div>
          <Skeleton className="h-10 w-full" />
        </CardContent>
      </Card>
    </main>
  );
}

================
File: app/(auth)/login/page.tsx
================
// app/(auth)/login/page.tsx
import Image from "next/image";
import { Card, CardContent, CardHeader } from "@/components/ui/card";
import { Toaster } from "sonner";
import LoginForm from "../components/LoginForm";

export default function LoginPage() {
  return (
    <main className="min-h-screen w-full flex items-center justify-center bg-background p-4">
      <Toaster richColors closeButton position="top-center" />
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-2">
          <div className="flex flex-col items-center justify-center">
            <div className="relative w-24 h-24">
              <Image
                src="/Image.png"
                alt="Annota8r Logo"
                fill
                priority
                className="object-contain"
              />
            </div>
          </div>
        </CardHeader>
        <CardContent>
            <LoginForm />
        </CardContent>
      </Card>
    </main>
  );
}

================
File: app/(dashboard)/components/editor/Annotation.tsx
================
import React from "react";
import { Annotation as AnnotationType } from "@/lib/types/annotations";
import { getAnnotationColor } from "@/lib/utils/color";

interface AnnotationProps {
  annotation: AnnotationType;
  isSelected: boolean;
  isDrawing?: boolean;
  hasClass?: boolean;
  index: number;
}

const Annotation: React.FC<AnnotationProps> = ({
  annotation,
  isSelected,
  isDrawing = false,
  hasClass = false,
  index
}) => {
  const color = getAnnotationColor(annotation.id);
  
  // Style box differently if no class is assigned
  const borderStyle = !hasClass && !isDrawing ? 'border-dashed' : 'border-solid';
  const borderColor = isSelected 
    ? '#3B82F6' 
    : isDrawing 
      ? '#3B82F6' 
      : !hasClass 
        ? '#FF4444'  // Red for no class assigned
        : color;

  return (
    <div
      className={`absolute ${isSelected ? "border-[6px]" : "border-4"} ${borderStyle} rounded-md backdrop-filter backdrop-blur-[1px]`}
      style={{
        left: `${annotation.x}px`,
        top: `${annotation.y}px`,
        width: `${annotation.width}px`,
        height: `${annotation.height}px`,
        borderColor: borderColor,
      }}
    >
      {isSelected && (
        <>
          {/* Corner handles */}
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -top-3 -left-3 cursor-nw-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -top-3 -right-3 cursor-ne-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -bottom-3 -left-3 cursor-sw-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -bottom-3 -right-3 cursor-se-resize" />

          {/* Edge handles */}
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg top-1/2 -translate-y-1/2 -left-3 cursor-w-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg top-1/2 -translate-y-1/2 -right-3 cursor-e-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -top-3 left-1/2 -translate-x-1/2 cursor-n-resize" />
          <div className="absolute w-6 h-6 bg-white border-4 border-blue-500 rounded-full shadow-lg -bottom-3 left-1/2 -translate-x-1/2 cursor-s-resize" />
        </>
      )}

      {/* Number indicator */}
      <div 
        className="absolute -top-4 -left-4 flex items-center justify-center w-8 h-8 
                    rounded-full text-base font-semibold border-2 shadow-lg"
        style={{
          backgroundColor: isSelected 
            ? '#3B82F6' 
            : !hasClass && !isDrawing
              ? '#FF4444'  // Red for no class assigned
              : color,
          borderColor: isSelected 
            ? '#3B82F6' 
            : !hasClass && !isDrawing
              ? '#FF4444'
              : color,
          color: 'white'
        }}
      >
        {index + 1}
      </div>
    </div>
  );
};

export default React.memo(Annotation);

================
File: app/(dashboard)/components/editor/AnnotationToolbar.tsx
================
import React from "react";
import { Save, Trash2, BoxSelectIcon, AlertCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

interface AnnotationToolbarProps {
  onBoundingBoxCreateMode: () => void;
  onDeleteAll: () => void;
  onSave: () => void;
  onRequestChanges?: () => void; // Optional prop for admin functionality
  isDrawing: boolean;
  isAdmin?: boolean; // New prop to indicate admin mode
}

const AnnotationToolbar: React.FC<AnnotationToolbarProps> = ({
  onBoundingBoxCreateMode,
  onDeleteAll,
  onSave,
  onRequestChanges,
  isDrawing,
  isAdmin = false
}) => (
 <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-3 p-3 
                  bg-white/80 backdrop-blur-md border border-gray-200/50 rounded-full shadow-lg">
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onBoundingBoxCreateMode}
            variant="ghost"
            size="icon"
            className={`w-10 h-10 rounded-full transition-all hover:bg-gray-100 ${
              isDrawing ? "bg-gray-900 text-white hover:bg-gray-800" : ""
            }`}
          >
            <BoxSelectIcon className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>Draw Bounding Box (B)</TooltipContent>
      </Tooltip>

      <div className="w-px h-6 bg-gray-200" />

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onDeleteAll}
            variant="ghost"
            size="icon"
            className="w-10 h-10 rounded-full transition-all hover:bg-red-50 hover:text-red-500"
          >
            <Trash2 className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>Delete All (Ctrl+Shift+D)</TooltipContent>
      </Tooltip>

      <div className="w-px h-6 bg-gray-200" />

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onSave}
            variant="ghost"
            size="icon"
            className="w-10 h-10 rounded-full transition-all hover:bg-green-50 hover:text-green-500"
          >
            <Save className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>Save (Ctrl+S)</TooltipContent>
      </Tooltip>

      {isAdmin && (
        <>
          <div className="w-px h-6 bg-gray-200" />
          
          <Tooltip>
            <TooltipTrigger asChild>
              <Button
                onClick={onRequestChanges}
                variant="ghost"
                size="icon"
                className="w-10 h-10 rounded-full transition-all hover:bg-amber-50 hover:text-amber-500"
              >
                <AlertCircle className="w-5 h-5" />
              </Button>
            </TooltipTrigger>
            <TooltipContent>Request Changes</TooltipContent>
          </Tooltip>
        </>
      )}
    </TooltipProvider>
  </div>
);

export default AnnotationToolbar;

================
File: app/(dashboard)/components/editor/AutoSaveIndicator.tsx
================
import React from "react";
import { motion } from "framer-motion";
import { CircleCheckBigIcon, CloudOffIcon, LucideFileQuestion, RefreshCcwIcon } from "lucide-react";

type AutosaveStatus = "saved" | "saving" | "unsaved" | "not_available";

interface AutosaveIndicatorProps {
  status: AutosaveStatus;
}

const AutosaveIndicator: React.FC<AutosaveIndicatorProps> = ({ status }) => {
  const variants = {
    initial: { scale: 0.8, opacity: 0 },
    animate: { scale: 1, opacity: 1 },
    exit: { scale: 0.8, opacity: 0 }
  };

  const getStatusContent = () => {
    switch (status) {
      case "saved":
        return {
          icon: <CircleCheckBigIcon className="w-5 h-5" />,
          color: "bg-green-50 text-green-700 border-green-200",
          text: "All changes saved"
        };
      case "saving":
        return {
          icon: <RefreshCcwIcon className="w-5 h-5 animate-spin" />,
          color: "bg-blue-50 text-blue-700 border-blue-200",
          text: "Saving changes..."
        };
      case "unsaved":
        return {
          icon: <CloudOffIcon className="w-5 h-5" />,
          color: "bg-red-50 text-red-700 border-red-200",
          text: "Unsaved changes"
        };
      default:
        return {
          icon: <LucideFileQuestion className="w-5 h-5" />,
          color: "bg-gray-50 text-gray-700 border-gray-200",
          text: "No changes"
        };
    }
  };

  const { icon, color, text } = getStatusContent();

  return (
    <motion.div
      className="fixed top-4 right-4 z-50"
      initial="initial"
      animate="animate"
      exit="exit"
      variants={variants}
    >
      <motion.div
        className={`flex items-center gap-2 px-4 py-2 rounded-full border shadow-md ${color}`}
        layout
      >
        {icon}
        <span className="text-sm font-medium">{text}</span>
      </motion.div>
    </motion.div>
  );
};

export default AutosaveIndicator;

================
File: app/(dashboard)/components/editor/ClassAsignDialog.tsx
================
import React from "react";
import {
  AlertDialog,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogCancel,
  AlertDialogAction,
} from "@/components/ui/alert-dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface ClassAssignmentDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onAssign: (className: string) => void;
  availableClasses: string[];
}

const ClassAssignmentDialog: React.FC<ClassAssignmentDialogProps> = ({
  isOpen,
  onClose,
  onAssign,
  availableClasses,
}) => {
  return (
    <AlertDialog open={isOpen} onOpenChange={onClose}>
      <AlertDialogContent className="bg-white/95 backdrop-blur-lg border-0 shadow-xl">
        <AlertDialogHeader>
          <AlertDialogTitle className="text-xl">Assign Class</AlertDialogTitle>
          <AlertDialogDescription>
            Choose a class for this annotation
          </AlertDialogDescription>
        </AlertDialogHeader>

        <Select onValueChange={onAssign}>
          <SelectTrigger className="w-full border border-gray-200 h-10">
            <SelectValue placeholder="Select a class" />
          </SelectTrigger>
          <SelectContent>
            {availableClasses.map((className) => (
              <SelectItem
                key={className}
                value={className}
                className="cursor-pointer hover:bg-gray-100"
              >
                {className}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <AlertDialogFooter>
          <AlertDialogCancel
            className="rounded-full px-4 hover:bg-gray-100"
            onClick={onClose}
          >
            Cancel
          </AlertDialogCancel>
          <AlertDialogAction
            className="rounded-full px-4 bg-blue-500 hover:bg-blue-600"
            onClick={() => onAssign}
          >
            Assign
          </AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  );
};

export default ClassAssignmentDialog;

================
File: app/(dashboard)/components/editor/HelpDialog.tsx
================
import { motion } from "framer-motion";
import { 
  AlertDialog, 
  AlertDialogContent, 
  AlertDialogHeader, 
  AlertDialogTitle,
  AlertDialogFooter,
  AlertDialogCancel
} from "@/components/ui/alert-dialog";
import { HelpCircle } from "lucide-react";
import { Button } from "@/components/ui/button";
import { useState } from "react";

export function HelpDialog() {
  const [isOpen, setIsOpen] = useState(false);
  const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);

  const shortcuts = [
    { action: "Undo", shortcut: isMac ? "âŒ˜ + Z" : "Ctrl + Z" },
    { action: "Redo", shortcut: isMac ? "âŒ˜ + Shift + Z" : "Ctrl + Shift + Z" },
    { action: "Copy Annotation", shortcut: isMac ? "âŒ˜ + C" : "Ctrl + C" },
    { action: "Paste Annotation", shortcut: isMac ? "âŒ˜ + V" : "Ctrl + V" },
    { action: "Delete Annotation", shortcut: "Delete/Backspace" },
    { action: "Cancel Current Action", shortcut: "Escape" },
    { action: "Previous Image", shortcut: "â†" },
    { action: "Next Image", shortcut: "â†’" },
  ];

  const controls = [
    "Click and drag to draw annotations",
    "Scroll to zoom in/out",
    "Hold spacebar and drag to pan",
    "Click annotation to select",
    "Drag corners/edges to resize",
  ];

  return (
    <>
      <motion.div
        className="fixed bottom-4 right-4 z-50"
        whileHover={{ scale: 1.1 }}
        whileTap={{ scale: 0.9 }}
      >
        <Button
          onClick={() => setIsOpen(true)}
          variant="outline"
          size="icon"
          className="rounded-full w-12 h-12 bg-white shadow-lg hover:bg-gray-50 
                     transition-colors duration-200"
        >
          <HelpCircle className="w-6 h-6" />
        </Button>
      </motion.div>

      <AlertDialog open={isOpen} onOpenChange={setIsOpen}>
        <AlertDialogContent className="max-w-2xl">
          <AlertDialogHeader>
            <AlertDialogTitle className="text-xl font-semibold">
              Keyboard Shortcuts & Controls
            </AlertDialogTitle>
          </AlertDialogHeader>

          <div className="grid grid-cols-1 md:grid-cols-2 gap-8 py-4">
            {/* Keyboard Shortcuts Section */}
            <div className="space-y-4">
              <h3 className="font-semibold text-lg">Keyboard Shortcuts</h3>
              <div className="space-y-2">
                {shortcuts.map((item) => (
                  <div 
                    key={item.action} 
                    className="flex justify-between items-center text-sm"
                  >
                    <span className="text-gray-700">{item.action}</span>
                    <code className="px-2 py-1 rounded bg-gray-100 font-mono">
                      {item.shortcut}
                    </code>
                  </div>
                ))}
              </div>
            </div>

            {/* Controls Section */}
            <div className="space-y-4">
              <h3 className="font-semibold text-lg">Controls</h3>
              <ul className="list-disc list-inside space-y-2">
                {controls.map((control) => (
                  <li 
                    key={control} 
                    className="text-sm text-gray-700"
                  >
                    {control}
                  </li>
                ))}
              </ul>
            </div>
          </div>

          <AlertDialogFooter className="mt-6">
            <AlertDialogCancel 
              className="w-full sm:w-auto"
              onClick={() => setIsOpen(false)}
            >
              Close
            </AlertDialogCancel>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

================
File: app/(dashboard)/components/editor/ImageMover.tsx
================
import React from "react";
import {
  Lock,
  MinusCircle,
  PlusCircle,
  RotateCcw,
  Unlock,
} from "lucide-react";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";

interface ImageMoverProps {
  isLocked: boolean;
  onZoomIn: () => void;
  onZoomOut: () => void;
  onReset: () => void;
  onLockToggle: () => void;
  zoomPercentage: number;
}

const ImageMover: React.FC<ImageMoverProps> = ({
  isLocked,
  onZoomIn,
  onZoomOut,
  onReset,
  onLockToggle,
  zoomPercentage,
}) => (
   <div className="fixed right-4 top-1/2 transform -translate-y-1/2 z-50 flex flex-col items-center gap-2 p-3 
                  bg-white/80 backdrop-blur-md border border-gray-200/50 rounded-full shadow-lg">
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onZoomOut}
            variant="ghost"
            size="icon"
            className="w-10 h-10 rounded-full hover:bg-gray-100"
          >
            <MinusCircle className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent side="left">Zoom Out</TooltipContent>
      </Tooltip>

      <div className="text-sm font-medium">
        {zoomPercentage}%
      </div>

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onZoomIn}
            variant="ghost"
            size="icon"
            className="w-10 h-10 rounded-full hover:bg-gray-100"
          >
            <PlusCircle className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent side="left">Zoom In</TooltipContent>
      </Tooltip>

      <div className="w-6 h-px bg-gray-200" />

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onReset}
            variant="ghost"
            size="icon"
            className="w-10 h-10 rounded-full hover:bg-gray-100"
          >
            <RotateCcw className="w-5 h-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent side="left">Reset View (R)</TooltipContent>
      </Tooltip>

      <div className="w-6 h-px bg-gray-200" />

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onLockToggle}
            variant="ghost"
            size="icon"
            className={`w-10 h-10 rounded-full transition-all ${
              isLocked ? "bg-gray-900 text-white hover:bg-gray-800" : "hover:bg-gray-100"
            }`}
          >
            {isLocked ? (
              <Lock className="w-5 h-5" />
            ) : (
              <Unlock className="w-5 h-5" />
            )}
          </Button>
        </TooltipTrigger>
        <TooltipContent side="left">
          {isLocked ? "Unlock Canvas (L)" : "Lock Canvas (L)"}
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  </div>
);

export default ImageMover;

================
File: app/(dashboard)/components/editor/LabelSidebar.tsx
================
import React, { useEffect, useState } from "react";
import { Trash2, ChevronLeft, ChevronRight } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { motion, AnimatePresence } from "framer-motion";
import { getAnnotationColor } from "@/lib/utils/color";

interface AnnotationListProps {
  annotations: Array<{
    id: string;
    class: string;
  }>;
  availableClasses: string[];
  onClassChange: (id: string, newClass: string) => void;
  onDelete: (id: string) => void;
  selectedAnnotationId: string | null;
  onAnnotationSelect: (id: string) => void;
}

export default function AnnotationListPanel({
  annotations,
  availableClasses,
  onClassChange,
  onDelete,
  selectedAnnotationId,
  onAnnotationSelect,
}: AnnotationListProps) {
  const [isExpanded, setIsExpanded] = useState(true);

  useEffect(() => {
    if (annotations.some((ann) => !ann.class)) {
      setIsExpanded(true);
    }
  }, [annotations]);

  const sortedAnnotations = React.useMemo(() => {
    return [...annotations].sort((a, b) => {
      const getTimestamp = (id: string) => {
        const parts = id.split("-");
        return parts.length > 1 ? parseInt(parts[1]) : 0;
      };
      return getTimestamp(a.id) - getTimestamp(b.id);
    });
  }, [annotations]);

  const hasUnassignedClasses = annotations.some((ann) => !ann.class);

  return (
    <motion.div
      initial={false}
      animate={{
        width: isExpanded ? 320 : 72,
      }}
      transition={{
        duration: 0.3,
        ease: "easeOut",
      }}
      className="fixed left-4 top-1/2 transform -translate-y-1/2 z-50 
                 bg-white/90 backdrop-blur-md border border-gray-200/50 
                 rounded-xl shadow-lg overflow-hidden
                 min-h-[80px] max-h-[24rem] flex flex-col"
    >
      {/* Header */}
      <div
        className="p-4 border-b border-gray-200/50 flex items-center justify-between cursor-pointer shrink-0"
        onClick={() => setIsExpanded(!isExpanded)}
      >
        <div className="flex items-center gap-2 whitespace-nowrap">
          <span className="px-2 py-0.5 bg-gray-100 rounded-full text-sm">
            {annotations.length}
          </span>
        </div>
        <AnimatePresence mode="wait" initial={false}>
          <motion.div
            key={isExpanded ? "collapse" : "expand"}
            initial={{ opacity: 0, rotate: isExpanded ? -90 : 90 }}
            animate={{ opacity: 1, rotate: 0 }}
            exit={{ opacity: 0, rotate: isExpanded ? 90 : -90 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
          >
            {isExpanded ? (
              <ChevronLeft className="w-4 h-4" />
            ) : (
              <ChevronRight className="w-4 h-4" />
            )}
          </motion.div>
        </AnimatePresence>
      </div>

      {/* List Container */}
      <div className="flex-1 overflow-y-auto max-h-[20rem]">
        <ScrollArea className="h-full">
          <div className="py-3">
            {sortedAnnotations.map((annotation, index) => (
              <div
                key={annotation.id}
                className="relative px-4 mb-2 last:mb-0 h-10"
                onClick={() => onAnnotationSelect(annotation.id)}
              >
                {/* Fixed-size number circle */}
                <div
                  className={`absolute left-4 top-1/2 -translate-y-1/2
             w-8 h-8 rounded-full
             flex items-center justify-center
             text-white text-sm font-medium
             hover:opacity-80 transition-opacity cursor-pointer`}
                  style={{
                    backgroundColor:
                      selectedAnnotationId === annotation.id
                        ? "#3B82F6"
                        : getAnnotationColor(annotation.id),
                    minWidth: "32px",
                    minHeight: "32px",
                    transform: "translate(0, -50%)",
                  }}
                >
                  {index + 1}
                </div>

                {/* Expandable content */}
                <AnimatePresence>
                  {isExpanded && (
                    <motion.div
                      className="flex items-center gap-3 pl-12 h-10"
                      initial={{ opacity: 0, x: -20 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: -20 }}
                      transition={{ duration: 0.3, ease: "easeOut" }}
                    >
                      <Select
                        value={annotation.class}
                        onValueChange={(value) =>
                          onClassChange(annotation.id, value)
                        }
                      >
                        <SelectTrigger className="h-8 min-w-[120px]">
                          <SelectValue placeholder="Select class" />
                        </SelectTrigger>
                        <SelectContent>
                          {availableClasses.map((className) => (
                            <SelectItem key={className} value={className}>
                              {className}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>

                      <Button
                        variant="ghost"
                        size="icon"
                        className="w-8 h-8 rounded-full hover:bg-red-50 hover:text-red-500 shrink-0"
                        onClick={(e) => {
                          e.stopPropagation();
                          onDelete(annotation.id);
                        }}
                      >
                        <Trash2 className="w-4 h-4" />
                      </Button>
                    </motion.div>
                  )}
                </AnimatePresence>
              </div>
            ))}
          </div>
        </ScrollArea>
      </div>

      {/* Warning */}
      <AnimatePresence>
        {hasUnassignedClasses && (
          <motion.div
            className="p-3 bg-red-50 border-t border-red-200 shrink-0"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.3, ease: "easeOut" }}
          >
            <p className="text-sm text-red-600 font-medium whitespace-nowrap">
              {isExpanded ? "Assign classes to continue" : "!"}
            </p>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}

================
File: app/(dashboard)/components/editor/PaginationTool.tsx
================
import React from "react";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { Button } from "@/components/ui/button";

interface NavigationControlsProps {
  onPrevious: () => void;
  onNext: () => void;
  hasPrevious: boolean;
  hasNext: boolean;
  currentIndex: number;
  totalImage: number;
}

export const NavigationControls: React.FC<NavigationControlsProps> = ({
  onPrevious,
  onNext,
  hasPrevious,
  hasNext,
  currentIndex,
  totalImage,
}) => (
  <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50 flex items-center gap-2 p-3 
                  bg-white/80 backdrop-blur-md border border-gray-200/50 rounded-full shadow-lg">
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onPrevious}
            disabled={!hasPrevious}
            variant="ghost"
            size="icon"
            className={`w-8 h-8 rounded-full ${
              !hasPrevious ? "opacity-50 cursor-not-allowed" : "hover:bg-gray-100"
            }`}
          >
            <ChevronLeft className="w-4 h-4" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>Previous Image (â†)</TooltipContent>
      </Tooltip>

      <div className="">
        <span className="text-sm font-medium">
          {currentIndex + 1} / {totalImage}
        </span>
      </div>

      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            onClick={onNext}
            disabled={!hasNext}
            variant="ghost"
            size="icon"
            className={`w-8 h-8 rounded-full ${
              !hasNext ? "opacity-50 cursor-not-allowed" : "hover:bg-gray-100"
            }`}
          >
            <ChevronRight className="w-4 h-4" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>Next Image (â†’)</TooltipContent>
      </Tooltip>
    </TooltipProvider>
  </div>
);

================
File: app/(dashboard)/components/editor/PhotoViewer.tsx
================
import React, {
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";
import NextImage from "next/image";
import { debounce } from "lodash";
import { ArrowLeft, Clipboard, Redo, Trash, Undo } from "lucide-react";
import { toast } from "sonner";
// Types
import type {
  PhotoViewerProps,
  Annotation as AnnotationType,
  Point,
  ImageState,
  DragState,
  EditorState,
  AutosaveStatus,
  ResizeHandle,
  ResizeOperation,
} from "@/lib/types/editor";
// Components
import { isCornerHandle, isSideHandle } from "@/lib/types/editor";
import { isValidAnnotation } from "@/lib/utils/validation";
import AutosaveIndicator from "./AutoSaveIndicator";
import AnnotationToolbar from "./AnnotationToolbar";
import ImageMover from "./ImageMover";
import Annotation from "./Annotation";
import { NavigationControls } from "./PaginationTool";
import { StatusInfo } from "./StatusInfo";
import { HelpDialog } from "./HelpDialog";
import { motion } from "framer-motion";
import AnnotationListPanel from "./LabelSidebar";
import { fetchWithAuth } from "@/lib/apis/config";

export function PhotoViewer({
  currentImageId,
  annotationState,
  availableClasses,
  isOfficeUser,
  imageUrl,
  onSave,
  onNext,
  onPrevious,
  onBack,
  hasPrevious,
  hasNext,
  currentIndex,
  totalImages,
  isAdmin = false,
  projectId
}: PhotoViewerProps): React.ReactElement {
  // Refs
  const containerRef = useRef<HTMLDivElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);

  const MIN_BOX_SIZE = 20; // Minimum 20px for both width and height

  const [imageState, setImageState] = useState<ImageState>({
    width: 0,
    height: 0,
    scale: 0.5, // Change from 1 to 0.5 for a smaller initial size
    position: { x: 0, y: 0 },
  });

  console.log(isOfficeUser);

  // Annotations State
  const [annotations, setAnnotations] = useState<AnnotationType[]>(() =>
    annotationState.annotations.map((ann) => ({
      ...ann,
      id: ann.id || `${currentImageId}-${Date.now()}-${crypto.randomUUID()}`,
    }))
  );
  const [selectedAnnotation, setSelectedAnnotation] =
    useState<AnnotationType | null>(null);
  const [currentAnnotation, setCurrentAnnotation] =
    useState<AnnotationType | null>(null);

  // Drag State
  const [dragState, setDragState] = useState<DragState>({
    isDragging: false,
    isDraggingAnnotation: false,
    dragStart: { x: 0, y: 0 },
    dragOffset: { x: 0, y: 0 },
    resizingSide: null,
  });

  // Editor State
  const [editorState, setEditorState] = useState<EditorState>({
    isLocked: false,
    isDrawing: false,
  });

  // History State
  const [history, setHistory] = useState<{
    annotations: AnnotationType[][];
    currentIndex: number;
  }>({
    annotations: [annotationState.annotations],
    currentIndex: 0,
  });

  // Autosave State
  const [autosaveStatus, setAutosaveStatus] = useState<AutosaveStatus>(
    annotationState.isAnnotated ? "saved" : "not_available"
  );

  // Memoized state updates
  const updateHistory = useCallback(
    (newAnnotations: AnnotationType[]): void => {
      setHistory((prev) => ({
        annotations: [
          ...prev.annotations.slice(0, prev.currentIndex + 1),
          newAnnotations,
        ],
        currentIndex: prev.currentIndex + 1,
      }));
    },
    []
  );

  const updateDragState = useCallback((updates: Partial<DragState>): void => {
    setDragState((prev) => ({ ...prev, ...updates }));
  }, []);

  const updateEditorState = useCallback(
    (
      updates: Partial<EditorState> | ((prev: EditorState) => EditorState)
    ): void => {
      if (typeof updates === "function") {
        setEditorState(updates);
      } else {
        setEditorState((prev) => ({ ...prev, ...updates }));
      }
    },
    []
  );

  const updateImageState = useCallback(
    (
      updates: Partial<ImageState> | ((prev: ImageState) => ImageState)
    ): void => {
      if (typeof updates === "function") {
        setImageState(updates);
      } else {
        setImageState((prev) => ({ ...prev, ...updates }));
      }
    },
    []
  );

  // Center image helper
  const centerImage = useCallback((): void => {
    if (!containerRef.current || !imageRef.current) return;

    const containerRect = containerRef.current.getBoundingClientRect();
    const imgWidth = imageRef.current.naturalWidth;
    const imgHeight = imageRef.current.naturalHeight;

    // Calculate scale to fit within container with some padding
    const containerAspect = containerRect.width / containerRect.height;
    const imageAspect = imgWidth / imgHeight;
    let scale = 0.5; // Default scale

    // Adjust scale to fit within container while maintaining aspect ratio
    if (containerAspect > imageAspect) {
      // Container is wider than image
      scale = (containerRect.height * 0.8) / imgHeight;
    } else {
      // Container is taller than image
      scale = (containerRect.width * 0.8) / imgWidth;
    }

    // Ensure scale is not too large or too small
    scale = Math.min(Math.max(scale, 0.1), 1);

    updateImageState({
      width: imgWidth,
      height: imgHeight,
      scale: scale,
      position: {
        x: (containerRect.width - imgWidth * scale) / 2,
        y: (containerRect.height - imgHeight * scale) / 2,
      },
    });
  }, [updateImageState]);

  // Image zoom helpers
  const handleZoom = useCallback(
    (delta: number): void => {
      if (!containerRef.current) return;
      const { width, height } = containerRef.current.getBoundingClientRect();
      const mouseX = width / 2;
      const mouseY = height / 2;

      updateImageState((prev) => {
        const newScale = Math.max(0.1, Math.min(prev.scale * delta, 2));
        const scaleFactor = newScale / prev.scale;

        return {
          ...prev,
          scale: newScale,
          position: {
            x: prev.position.x - (mouseX - prev.position.x) * (scaleFactor - 1),
            y: prev.position.y - (mouseY - prev.position.y) * (scaleFactor - 1),
          },
        };
      });
    },
    [updateImageState]
  );

  const handleReset = useCallback((): void => {
    if (!containerRef.current || !imageRef.current) return;

    const containerRect = containerRef.current.getBoundingClientRect();
    const imgWidth = imageRef.current.naturalWidth;
    const imgHeight = imageRef.current.naturalHeight;

    // Calculate scale to fit
    const containerAspect = containerRect.width / containerRect.height;
    const imageAspect = imgWidth / imgHeight;
    let scale = 0.5;

    if (containerAspect > imageAspect) {
      scale = (containerRect.height * 0.8) / imgHeight;
    } else {
      scale = (containerRect.width * 0.8) / imgWidth;
    }

    scale = Math.min(Math.max(scale, 0.1), 1);

    updateImageState({
      scale: scale,
      width: imgWidth,
      height: imgHeight,
      position: {
        x: (containerRect.width - imgWidth * scale) / 2,
        y: (containerRect.height - imgHeight * scale) / 2,
      },
    });
  }, [updateImageState]);

  // Mouse position utility
  const getMousePosition = useCallback(
    (e: React.MouseEvent<HTMLDivElement>): Point => {
      const rect = containerRef.current?.getBoundingClientRect();
      if (!rect) return { x: 0, y: 0 };

      return {
        x: (e.clientX - rect.left - imageState.position.x) / imageState.scale,
        y: (e.clientY - rect.top - imageState.position.y) / imageState.scale,
      };
    },
    [imageState.position.x, imageState.position.y, imageState.scale]
  );

  // Annotation utilities
  const normalizeAnnotation = useCallback(
    (ann: AnnotationType): AnnotationType => {
      const normalized = { ...ann };
      if (normalized.width < 0) {
        normalized.x += normalized.width;
        normalized.width = Math.abs(normalized.width);
      }
      if (normalized.height < 0) {
        normalized.y += normalized.height;
        normalized.height = Math.abs(normalized.height);
      }
      return normalized;
    },
    []
  );

  const resizeAnnotation = useCallback(
    ({
      annotation,
      handle,
      point,
      imageSize,
    }: ResizeOperation): AnnotationType => {
      const newAnn = { ...annotation };
      const { x, y } = point;

      const clamp = (value: number, min: number, max: number): number =>
        Math.max(min, Math.min(max, value));

      if (isCornerHandle(handle)) {
        switch (handle) {
          case "tl":
            newAnn.width = clamp(
              annotation.width + (annotation.x - x),
              1,
              annotation.width + annotation.x
            );
            newAnn.height = clamp(
              annotation.height + (annotation.y - y),
              1,
              annotation.height + annotation.y
            );
            newAnn.x = clamp(x, 0, annotation.x + annotation.width - 1);
            newAnn.y = clamp(y, 0, annotation.y + annotation.height - 1);
            break;
          case "tr":
            newAnn.width = clamp(
              x - annotation.x,
              1,
              imageSize.width - annotation.x
            );
            newAnn.height = clamp(
              annotation.height + (annotation.y - y),
              1,
              annotation.height + annotation.y
            );
            newAnn.y = clamp(y, 0, annotation.y + annotation.height - 1);
            break;
          case "bl":
            newAnn.width = clamp(
              annotation.width + (annotation.x - x),
              1,
              annotation.width + annotation.x
            );
            newAnn.height = clamp(
              y - annotation.y,
              1,
              imageSize.height - annotation.y
            );
            newAnn.x = clamp(x, 0, annotation.x + annotation.width - 1);
            break;
          case "br":
            newAnn.width = clamp(
              x - annotation.x,
              1,
              imageSize.width - annotation.x
            );
            newAnn.height = clamp(
              y - annotation.y,
              1,
              imageSize.height - annotation.y
            );
            break;
        }
      } else if (isSideHandle(handle)) {
        switch (handle) {
          case "l":
            newAnn.width = clamp(
              annotation.width + (annotation.x - x),
              1,
              annotation.width + annotation.x
            );
            newAnn.x = clamp(x, 0, annotation.x + annotation.width - 1);
            break;
          case "r":
            newAnn.width = clamp(
              x - annotation.x,
              1,
              imageSize.width - annotation.x
            );
            break;
          case "t":
            newAnn.height = clamp(
              annotation.height + (annotation.y - y),
              1,
              annotation.height + annotation.y
            );
            newAnn.y = clamp(y, 0, annotation.y + annotation.height - 1);
            break;
          case "b":
            newAnn.height = clamp(
              y - annotation.y,
              1,
              imageSize.height - annotation.y
            );
            break;
        }
      }

      return newAnn;
    },
    []
  );

  // Autosave implementation
  const debouncedSave = useMemo(
    () =>
      debounce(async (annotationsToSave: AnnotationType[]) => {
        if (autosaveStatus === "unsaved") {
          setAutosaveStatus("saving");
          try {
            await onSave(annotationsToSave);
            setAutosaveStatus("saved");
          } catch {
            setAutosaveStatus("unsaved");
            toast.error("Failed to save annotations");
          }
        }
      }, 2000),
    [autosaveStatus, onSave]
  );

  // Get resize handle based on point
  const getResizeHandle = useCallback(
    (point: Point, annotation: AnnotationType): ResizeHandle => {
      const handleSize = 10;
      const { x, y } = point;
      const corners = [
        { handle: "tl" as const, x: annotation.x, y: annotation.y },
        {
          handle: "tr" as const,
          x: annotation.x + annotation.width,
          y: annotation.y,
        },
        {
          handle: "bl" as const,
          x: annotation.x,
          y: annotation.y + annotation.height,
        },
        {
          handle: "br" as const,
          x: annotation.x + annotation.width,
          y: annotation.y + annotation.height,
        },
      ];

      // Check corners
      for (const corner of corners) {
        if (
          Math.abs(x - corner.x) <= handleSize &&
          Math.abs(y - corner.y) <= handleSize
        ) {
          return corner.handle;
        }
      }

      // Check sides
      if (Math.abs(x - annotation.x) <= handleSize) return "l";
      if (Math.abs(x - (annotation.x + annotation.width)) <= handleSize)
        return "r";
      if (Math.abs(y - annotation.y) <= handleSize) return "t";
      if (Math.abs(y - (annotation.y + annotation.height)) <= handleSize)
        return "b";

      return null;
    },
    []
  );

  // Mouse event handlers
  const handleMouseDown = useCallback(
    (e: React.MouseEvent<HTMLDivElement>): void => {
      if (editorState.isLocked) return;
    e.preventDefault();

    const hasUnassignedClasses = annotations.some(ann => !ann.class);
    
    if (editorState.isDrawing && hasUnassignedClasses) {
      toast.error("Please assign classes to all existing boxes before creating new ones");
      return;
    }

    const point = getMousePosition(e);
      const clickedAnnotation = annotations.find(
        (ann) =>
          point.x >= ann.x &&
          point.x <= ann.x + ann.width &&
          point.y >= ann.y &&
          point.y <= ann.y + ann.height
      );

      if (clickedAnnotation) {
        setSelectedAnnotation(clickedAnnotation);
        const handle = getResizeHandle(point, clickedAnnotation);

        if (handle) {
          updateDragState({
            resizingSide: handle,
          });
        } else {
          updateDragState({
            isDraggingAnnotation: true,
            dragOffset: {
              x: point.x - clickedAnnotation.x,
              y: point.y - clickedAnnotation.y,
            },
          });
        }
      } else {
        setSelectedAnnotation(null);
        if (editorState.isDrawing) {
          const newAnnotation: AnnotationType = {
            id: `${currentImageId}-${Date.now()}-${crypto.randomUUID()}`,
            x: point.x,
            y: point.y,
            width: 0,
            height: 0,
            class: "",
          };
          console.log("Creating new annotation:", newAnnotation); // Debug log
          setCurrentAnnotation(newAnnotation);
        } else {
          updateDragState({
            isDragging: true,
            dragStart: {
              x: e.clientX - imageState.position.x,
              y: e.clientY - imageState.position.y,
            },
          });
        }
      }
    },
    [
      editorState.isLocked,
      editorState.isDrawing,
      getMousePosition,
      annotations,
      getResizeHandle,
      updateDragState,
      currentImageId,
      imageState.position.x,
      imageState.position.y,
    ]
  );

  const handleMouseMove = useCallback(
    (e: React.MouseEvent<HTMLDivElement>): void => {
      if (editorState.isLocked) return;
      e.preventDefault();

      const point = getMousePosition(e);

      if (selectedAnnotation && dragState.resizingSide) {
        const resizedAnnotation = resizeAnnotation({
          annotation: selectedAnnotation,
          handle: dragState.resizingSide,
          point,
          imageSize: { width: imageState.width, height: imageState.height },
        });

        setAnnotations((prevAnnotations) =>
          prevAnnotations.map((ann) =>
            ann.id === selectedAnnotation.id ? resizedAnnotation : ann
          )
        );
        setSelectedAnnotation(resizedAnnotation);
        setAutosaveStatus("unsaved");
      } else if (dragState.isDraggingAnnotation && selectedAnnotation) {
        const newX = point.x - dragState.dragOffset.x;
        const newY = point.y - dragState.dragOffset.y;

        const clampedAnnotation: AnnotationType = {
          ...selectedAnnotation,
          x: Math.max(
            0,
            Math.min(newX, imageState.width - selectedAnnotation.width)
          ),
          y: Math.max(
            0,
            Math.min(newY, imageState.height - selectedAnnotation.height)
          ),
        };

        setAnnotations((prevAnnotations) =>
          prevAnnotations.map((ann) =>
            ann.id === selectedAnnotation.id ? clampedAnnotation : ann
          )
        );
        setSelectedAnnotation(clampedAnnotation);
        setAutosaveStatus("unsaved");
      } else if (editorState.isDrawing && currentAnnotation) {
        const width = Math.min(
          Math.max(0, point.x - currentAnnotation.x),
          imageState.width - currentAnnotation.x
        );
        const height = Math.min(
          Math.max(0, point.y - currentAnnotation.y),
          imageState.height - currentAnnotation.y
        );
  
        setCurrentAnnotation({
          ...currentAnnotation,
          width,
          height
        });
      } else if (dragState.isDragging) {
        updateImageState({
          position: {
            x: e.clientX - dragState.dragStart.x,
            y: e.clientY - dragState.dragStart.y,
          },
        });
      }
    },
    [
      editorState.isLocked,
      editorState.isDrawing,
      dragState,
      selectedAnnotation,
      currentAnnotation,
      imageState.width,
      imageState.height,
      getMousePosition,
      resizeAnnotation,
      updateImageState,
    ]
  );

  const handleMouseUp = useCallback(
    (e: React.MouseEvent<HTMLDivElement>): void => {
      if (editorState.isLocked) return;
      e.preventDefault();
  
      if (
        dragState.isDraggingAnnotation ||
        (selectedAnnotation && dragState.resizingSide)
      ) {
        updateHistory(annotations);
        setAutosaveStatus("unsaved");
      } else if (editorState.isDrawing && currentAnnotation) {
        const normalizedAnnotation = normalizeAnnotation(currentAnnotation);
        
        // Check minimum size
        if (normalizedAnnotation.width < MIN_BOX_SIZE || 
            normalizedAnnotation.height < MIN_BOX_SIZE) {
          toast.error("Box is too small - minimum size is 20x20 pixels");
          setCurrentAnnotation(null);
          return;
        }
  
        // Check if box is within image bounds
        if (normalizedAnnotation.x < 0 || 
            normalizedAnnotation.y < 0 ||
            normalizedAnnotation.x + normalizedAnnotation.width > imageState.width ||
            normalizedAnnotation.y + normalizedAnnotation.height > imageState.height) {
          toast.error("Box must be within image bounds");
          setCurrentAnnotation(null);
          return;
        }
  
        // Create annotation
        setAnnotations(prev => [...prev, {
          ...normalizedAnnotation,
          class: "",
          id: `${currentImageId}-${Date.now()}-${crypto.randomUUID()}`
        }]);
        
        setCurrentAnnotation(null);
      }
  
      updateDragState({
        isDragging: false,
        isDraggingAnnotation: false,
        resizingSide: null,
      });
    },
    [editorState.isLocked, editorState.isDrawing, dragState.isDraggingAnnotation, dragState.resizingSide, selectedAnnotation, currentAnnotation, updateDragState, updateHistory, annotations, normalizeAnnotation, imageState.width, imageState.height, currentImageId]
  );

  const handleDeleteAnnotation = useCallback(
    (id: string): void => {
      setAnnotations((prev) => {
        const newAnnotations = prev.filter((ann) => ann.id !== id);
        updateHistory(newAnnotations);
        return newAnnotations;
      });
      setSelectedAnnotation(null);
      setAutosaveStatus("unsaved");
      toast("Annotation deleted!", {
        icon: <Trash className="h-4 w-4" />,
      });
    },
    [updateHistory]
  );

  const handleDeleteAll = useCallback((): void => {
    setAnnotations([]);
    setSelectedAnnotation(null);
    updateHistory([]);
    setAutosaveStatus("unsaved");
    toast("All annotations deleted!", {
      icon: <Trash className="h-4 w-4" />,
    });
  }, [updateHistory]);

  const handleWheel = useCallback(
    (e: React.WheelEvent<HTMLDivElement>): void => {
      e.preventDefault();
      const rect = containerRef.current?.getBoundingClientRect();
      if (!rect) return;

      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const delta = e.deltaY > 0 ? 0.9 : 1.1;

      updateImageState((prev) => {
        const newScale = Math.max(0.1, Math.min(prev.scale * delta, 2));
        const scaleFactor = newScale / prev.scale;

        return {
          ...prev,
          scale: newScale,
          position: {
            x: prev.position.x - (mouseX - prev.position.x) * (scaleFactor - 1),
            y: prev.position.y - (mouseY - prev.position.y) * (scaleFactor - 1),
          },
        };
      });
    },
    [updateImageState]
  );

  // Keyboard event handlers
  const handleKeyDown = useCallback(
    (e: KeyboardEvent): void => {
      const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
      const ctrlKey = isMac ? e.metaKey : e.ctrlKey;

      // Navigation
      if (e.key === "ArrowLeft" && hasPrevious) {
        onPrevious();
      } else if (e.key === "ArrowRight" && hasNext) {
        onNext();
      }

      // Shortcuts
      if (ctrlKey) {
        switch (e.key.toLowerCase()) {
          case "z": {
            e.preventDefault();
            if (
              e.shiftKey &&
              history.currentIndex < history.annotations.length - 1
            ) {
              // Redo
              const newIndex = history.currentIndex + 1;
              setHistory((prev) => ({ ...prev, currentIndex: newIndex }));
              setAnnotations(history.annotations[newIndex]);
              setAutosaveStatus("unsaved");
              toast("Redo Operation Performed!", {
                icon: <Redo className="h-4 w-4" />,
              });
            } else if (!e.shiftKey && history.currentIndex > 0) {
              // Undo
              const newIndex = history.currentIndex - 1;
              setHistory((prev) => ({ ...prev, currentIndex: newIndex }));
              setAnnotations(history.annotations[newIndex]);
              setAutosaveStatus("unsaved");
              toast("Undo Operation Performed!", {
                icon: <Undo className="h-4 w-4" />,
              });
            }
            break;
          }

          case "c": {
            if (selectedAnnotation) {
              e.preventDefault();
              void navigator.clipboard
                .writeText(JSON.stringify(selectedAnnotation))
                .then(() => {
                  toast("Annotation copied!", {
                    icon: <Clipboard className="h-4 w-4" />,
                  });
                })
                .catch(() => {
                  toast.error("Failed to copy annotation");
                });
            }
            break;
          }

          case "v": {
            e.preventDefault();
            void navigator.clipboard
              .readText()
              .then((text) => {
                try {
                  const pastedAnnotation = JSON.parse(text);
                  if (isValidAnnotation(pastedAnnotation)) {
                    const newAnnotation: AnnotationType = {
                      ...pastedAnnotation,
                      id: crypto.randomUUID(),
                    };
                    setAnnotations((prev) => [...prev, newAnnotation]);
                    updateHistory([...annotations, newAnnotation]);
                    setAutosaveStatus("unsaved");
                    toast("Annotation pasted!", {
                      icon: <Clipboard className="h-4 w-4" />,
                    });
                  }
                } catch {
                  toast.error("Invalid annotation data");
                }
              })
              .catch(() => {
                toast.error("Failed to paste annotation");
              });
            break;
          }

          case "d": {
            if (selectedAnnotation) {
              e.preventDefault();
              handleDeleteAnnotation(selectedAnnotation.id);
            }
            break;
          }
        }
      } else if (e.key === "Escape") {
        // Cancel current operation
        if (editorState.isDrawing) {
          updateEditorState({ isDrawing: false });
          setCurrentAnnotation(null);
        }
      } else if (e.key === "Delete" || e.key === "Backspace") {
        if (selectedAnnotation) {
          handleDeleteAnnotation(selectedAnnotation.id);
        }
      }
    },
    [
      editorState.isDrawing,
      selectedAnnotation,
      history,
      annotations,
      hasPrevious,
      hasNext,
      onNext,
      onPrevious,
      updateEditorState,
      updateHistory,
      handleDeleteAnnotation,
    ]
  );

  // UI Event Handlers
  const handleClassAssign = useCallback(
    (annotationId: string, className: string) => {
      setAnnotations((prev) =>
        prev.map((ann) =>
          ann.id === annotationId ? { ...ann, class: className } : ann
        )
      );
      setAutosaveStatus("unsaved");
    },
    []
  );

  const handleBoundingBoxMode = useCallback((): void => {
    // Check if there are any unassigned classes
    const hasUnassignedClasses = annotations.some(ann => !ann.class);
    
    if (hasUnassignedClasses) {
      toast.error("Please assign classes to all existing boxes before creating new ones");
      return;
    }
  
    updateEditorState((prev) => ({
      ...prev,
      isDrawing: !prev.isDrawing,
    }));
    setSelectedAnnotation(null);
  }, [updateEditorState, annotations]);

  const handleSave = useCallback(async (): Promise<void> => {
    const hasUnassignedClasses = annotations.some((ann) => !ann.class);

    if (hasUnassignedClasses) {
      toast.error("Please assign classes to all annotations before saving");
      return;
    }

    try {
      setAutosaveStatus("saving");
      await onSave(annotations);
      setAutosaveStatus("saved");
      toast.success("Annotations saved successfully");
    } catch {
      setAutosaveStatus("unsaved");
      toast.error("Failed to save annotations");
    }
  }, [annotations, onSave]);

  // Effects
  useEffect(() => {
    debouncedSave(annotations);
    return () => {
      debouncedSave.cancel();
    };
  }, [annotations, debouncedSave]);

  useEffect(() => {
    const img: HTMLImageElement = new Image();
    img.onload = () => {
      updateImageState({
        width: img.naturalWidth,
        height: img.naturalHeight,
      });
      centerImage();
    };
    img.src = imageUrl;
  }, [imageUrl, updateImageState, centerImage]);

  useEffect(() => {
    window.addEventListener("keydown", handleKeyDown);
    return () => {
      window.removeEventListener("keydown", handleKeyDown);
    };
  }, [handleKeyDown]);

  // Inside PhotoViewer.tsx

  const handleGoBack = useCallback(async () => {
    // Check for unsaved changes
    if (autosaveStatus === "unsaved") {
      const willSave = await new Promise((resolve) => {
        toast("You have unsaved changes", {
          action: {
            label: "Save & Exit",
            onClick: () => resolve(true),
          },
          cancel: {
            label: "Discard",
            onClick: () => resolve(false),
          },
        });
      });

      if (willSave) {
        try {
          // Try to save changes
          setAutosaveStatus("saving");
          await onSave(annotations);
          setAutosaveStatus("saved");
          onBack(); // Navigate back after successful save
        } catch {
          toast.error("Failed to save annotations before exit");
          // Let user decide whether to leave without saving
          const forceExit = await new Promise((resolve) => {
            toast("Failed to save. Exit anyway?", {
              action: {
                label: "Exit",
                onClick: () => resolve(true),
              },
              cancel: {
                label: "Stay",
                onClick: () => resolve(false),
              },
            });
          });

          if (forceExit) {
            onBack();
          }
        }
      } else {
        // User chose to discard changes
        onBack();
      }
    } else {
      // No unsaved changes, just go back
      onBack();
    }
  }, [autosaveStatus, annotations, onSave, onBack]);

  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        // Only trigger if not in drawing mode or class dialog
        if (!editorState.isDrawing) {
          handleGoBack();
        }
      }
    };

    window.addEventListener("keydown", handleEscape);
    return () => window.removeEventListener("keydown", handleEscape);
  }, [editorState.isDrawing, handleGoBack]);

  const handleRequestChanges = useCallback(async () => {
    if (!isAdmin) return;
    
    // Use a simple prompt for feedback
    const feedback = window.prompt("Please provide feedback for the annotator:");
    if (feedback === null) return; // User cancelled
    
    try {
      // Call API to request changes
      await fetchWithAuth(`/projects/${projectId}/images/${currentImageId}/review`, {
        method: 'POST',
        body: JSON.stringify({
          status: 'changes_requested',
          feedback
        })
      });
      
      toast.success("Change request sent to annotator");
      
      // Move to next image if available
      if (hasNext) {
        onNext();
      }
    } catch (error) {
      toast.error("Failed to submit change request");
      console.error(error);
    }
  }, [isAdmin, projectId, currentImageId, hasNext, onNext]);

  // Render
  return (
    <div className="relative w-full h-screen flex items-center justify-center bg-white overflow-hidden">
      {/* Back Button */}
      <div className="fixed top-4 left-4 z-50">
        <motion.button
          className="p-2 rounded-full bg-white shadow-lg border border-gray-200/50 hover:bg-gray-50"
          whileHover={{ scale: 1.1 }}
          whileTap={{ scale: 0.9 }}
          onClick={handleGoBack}
        >
          <ArrowLeft className="w-6 h-6" />
        </motion.button>
      </div>

      {/* Navigation Controls */}
      <NavigationControls
        onNext={onNext}
        onPrevious={onPrevious}
        hasPrevious={hasPrevious}
        hasNext={hasNext}
        currentIndex={currentIndex}
        totalImage={totalImages}
      />

      {/* Autosave Indicator */}
      <AutosaveIndicator status={autosaveStatus} />

      {/* Main Canvas Area */}
      <div
        ref={containerRef}
        className="relative w-full h-full overflow-hidden"
        style={{
          cursor: dragState.isDragging ? "grabbing" : "grab",
          backgroundImage:
            "radial-gradient(circle at 10px 10px, #f0f0f0 2px, transparent 0)",
          backgroundSize: "20px 20px",
        }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
      >
        <div
          style={{
            transform: `translate(${imageState.position.x}px, ${imageState.position.y}px) scale(${imageState.scale})`,
            transformOrigin: "top left",
            width: imageState.width,
            height: imageState.height,
          }}
          className="relative"
        >
          <NextImage
            ref={imageRef}
            src={imageUrl}
            alt="Annotation canvas"
            className="rounded-xl"
            width={imageState.width}
            height={imageState.height}
            priority
            unoptimized
            draggable={false}
            onContextMenu={(e) => e.preventDefault()}
          />

          {/* Annotations */}
          {annotations.map((annotation, index) => (
            <Annotation
              key={`annotation-${currentImageId}-${
                annotation.id || crypto.randomUUID()
              }`}
              annotation={annotation}
              isSelected={annotation.id === selectedAnnotation?.id}
              hasClass={!!annotation.class}
              index={index}
            />
          ))}

          {/* Current Drawing Annotation */}
          {currentAnnotation && (
            <Annotation
              key={`drawing-${currentAnnotation.id}`}
              annotation={currentAnnotation}
              isSelected={false}
              isDrawing={true}
              index={annotations.length}
            />
          )}
        </div>
      </div>

      {/* Image Controls */}
      <ImageMover
        isLocked={editorState.isLocked}
        onZoomIn={() => handleZoom(1.1)}
        onZoomOut={() => handleZoom(0.9)}
        onReset={handleReset}
        onLockToggle={() =>
          updateEditorState((prev) => ({
            ...prev,
            isLocked: !prev.isLocked,
          }))
        }
        zoomPercentage={Math.round(imageState.scale * 100)}
      />

      {/* Help Dialog */}
      <HelpDialog />

      {/* Annotation Controls */}
      <AnnotationToolbar
        onBoundingBoxCreateMode={handleBoundingBoxMode}
        onDeleteAll={handleDeleteAll}
        onSave={handleSave}
        isDrawing={editorState.isDrawing}
        isAdmin={isAdmin}
        onRequestChanges={isAdmin ? handleRequestChanges : undefined}
      />

      {/* Status Information */}
      <StatusInfo
        isDrawing={editorState.isDrawing}
        isLocked={editorState.isLocked}
      />

      {/* Class Assignment Dialog */}
      <AnnotationListPanel
        annotations={annotations}
        availableClasses={availableClasses}
        onClassChange={handleClassAssign}
        onDelete={handleDeleteAnnotation}
        selectedAnnotationId={selectedAnnotation?.id || null}
        onAnnotationSelect={(id) => {
          const annotation = annotations.find((a) => a.id === id);
          setSelectedAnnotation(annotation || null);
        }}
      />
    </div>
  );
}

export default React.memo(PhotoViewer);

================
File: app/(dashboard)/components/editor/StatusInfo.tsx
================
import { motion, AnimatePresence } from "framer-motion";

interface Status {
  isDrawing: boolean;
  isLocked: boolean;
}

export function StatusInfo({ isDrawing, isLocked }: Status) {
  return (
    <motion.div
      className="fixed bottom-4 left-4 flex items-center gap-2"
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
    >
      <AnimatePresence mode="wait">
        {isDrawing && (
          <motion.span
            key="drawing"
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.8 }}
            className="px-3 py-1.5 rounded-full bg-blue-500 text-white border border-blue-200/50 text-sm font-medium shadow-md"
          >
            Drawing Mode
          </motion.span>
        )}

        {isLocked && (
          <motion.span
            key="locked"
            initial={{ opacity: 0, scale: 0.8 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.8 }}
            className="px-3 py-1.5 rounded-full bg-red-500 text-white border border-red-200/50 text-sm font-medium shadow-md"
          >
            Locked
          </motion.span>
        )}
      </AnimatePresence>
    </motion.div>
  );
}

================
File: app/(dashboard)/components/navbar.tsx
================
// app/(dashboard)/components/navbar.tsx
'use client';

import { usePathname } from 'next/navigation';
import { motion, useScroll } from 'framer-motion';
import { useEffect, useState } from 'react';
import { LogOut } from 'lucide-react';
import { logout } from '@/lib/actions/auth';
import { UserInfo } from '@/lib/types/auth';

interface NavbarProps {
  user: UserInfo;
}

export function Navbar({ user }: NavbarProps) {
  const pathname = usePathname();
  const { scrollY } = useScroll();
  const [hasScrolled, setHasScrolled] = useState(false);

  useEffect(() => {
    return scrollY.onChange((latest) => {
      setHasScrolled(latest > 0);
    });
  }, [scrollY]);

  const getGreeting = () => {
    const hour = new Date().getHours();
    
    if (hour >= 5 && hour < 12) return 'Good morning';
    if (hour >= 12 && hour < 17) return 'Good afternoon';
    if (hour >= 17 && hour < 21) return 'Good evening';
    return 'Good night';
  };

  // Show navbar only on the main dashboard page
  if (pathname !== '/dashboard') return null;

  return (
    <motion.nav
      className="sticky top-0 left-0 right-0 z-50 px-6 h-16 flex items-center justify-between"
      animate={{
        backgroundColor: hasScrolled ? 'rgba(255, 255, 255, 1)' : 'rgba(255, 255, 255, 0)',
        borderBottom: hasScrolled ? '1px solid #e5e7eb' : '1px solid rgba(229, 231, 235, 0)',
      }}
      initial={{
        backgroundColor: 'rgba(255, 255, 255, 0)',
        borderBottom: '1px solid rgba(229, 231, 235, 0)',
      }}
      transition={{
        duration: 0.3,
        ease: [0.16, 1, 0.3, 1], // custom ease-out curve
      }}
    >
      <motion.div 
        className="text-lg font-medium"
        animate={{
          color: hasScrolled ? '#1a1a1a' : '#000000',
        }}
        transition={{ duration: 0.3 }}
      >
        {getGreeting()}, <span className="text-primary">{user.username}</span>
      </motion.div>

      <form action={logout}>
        <button
          type="submit"
          className="px-6 py-2 rounded-2xl bg-[#F4F4F4] text-gray-500 
                   hover:bg-red-500 hover:text-white hover:border-red-500 
                   transition-colors duration-200 flex items-center gap-2 font-medium"
        >
          <LogOut className="h-4 w-4" />
          Logout
        </button>
      </form>
    </motion.nav>
  );
}

================
File: app/(dashboard)/components/project-card.tsx
================
// app/(dashboard)/components/project-card.tsx
"use client";

import { Card } from "@/components/ui/card";
import { Project } from "@/lib/types/projects";
import { Folder, Image as ImageIcon, MoreVertical } from "lucide-react";
import Link from "next/link";

interface ProjectCardProps {
  project: Project;
}

export function ProjectCard({ project }: ProjectCardProps) {
  const progressPercentage = Math.round(
    (project.annotatedImages / project.totalImages) * 100
  );

  return (
    <Link
      href={`/dashboard/projects?projectId=${encodeURIComponent(project.name)}`}
      className="block group"
    >
      <Card className="relative overflow-hidden border border-gray-200 hover:border-gray-300 transition-all duration-200">
        <div className="aspect-[4/3] bg-gray-50 p-4">
          <div className="h-full rounded-md bg-white border-2 border-dashed border-gray-200 flex items-center justify-center">
            <Folder className="h-12 w-12 text-gray-400" />
          </div>
        </div>

        <div className="absolute top-2 right-2">
          <button className="p-1 rounded-full bg-white/80 backdrop-blur border border-gray-200/50 opacity-0 group-hover:opacity-100 transition-opacity">
            <MoreVertical className="h-4 w-4 text-gray-600" />
          </button>
        </div>

        <div className="p-4 space-y-3">
          <div className="flex items-center justify-between">
            <h2 className="font-medium truncate">{project.name}</h2>
          </div>

          <div className="flex items-center justify-between text-sm text-gray-500">
            <div className="flex items-center gap-1.5">
              <ImageIcon className="h-3.5 w-3.5 text-gray-500" />
              <span className="text-base font-medium text-gray-600">
                {project.totalImages}
              </span>
            </div>
            <div className="flex items-center gap-1.5">
              <span className="text-base font-semibold text-green-600">
                {progressPercentage}%
              </span>
            </div>
          </div>

          <div className="space-y-1">
            <div className="flex justify-between text-xs text-gray-500">
              <span>{project.annotatedImages} Annotated</span>
              <span>{project.remainingImages} Remaining</span>
            </div>
            <div className="w-full bg-gray-100 rounded-full h-1">
              <div
                className="bg-green-600 h-1 rounded-full transition-all duration-300"
                style={{ width: `${progressPercentage}%` }}
              />
            </div>
          </div>
        </div>
      </Card>
    </Link>
  );
}

================
File: app/(dashboard)/components/project-details/filter-chip.tsx
================
import { memo } from "react";

const FilterChip = memo(function FilterChip({ 
  label, 
  count, 
  active, 
  onClick 
}: { 
  label: string;
  count: number;
  active: boolean;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      className={`
        px-4 py-2 rounded-2xl flex items-center gap-2
        transition-all duration-200
        ${active 
          ? "bg-gray-800 text-white" 
          : "bg-[#F4F4F4] text-gray-500 hover:bg-gray-200"
        }
      `}
    >
      <span className="font-medium">{label}</span>
      <span className={`
        px-2 py-0.5 rounded-full text-xs
        ${active 
          ? "bg-white/20 text-white" 
          : "bg-gray-200 text-gray-600"
        }
      `}>
        {count}
      </span>
    </button>
  );
});

export function ProjectDetailFilters({
  total,
  annotatedCount,
  unannotatedCount,
  activeFilter,
  onFilterChange,
}: {
  total: number;
  annotatedCount: number;
  unannotatedCount: number;
  activeFilter: "all" | "annotated" | "unannotated";
  onFilterChange: (filter: "all" | "annotated" | "unannotated") => void;
}) {
  return (
    <div className="flex items-center gap-2 mb-6">
      <FilterChip
        label="All Images"
        count={total}
        active={activeFilter === "all"}
        onClick={() => onFilterChange("all")}
      />
      <FilterChip
        label="Annotated"
        count={annotatedCount}
        active={activeFilter === "annotated"}
        onClick={() => onFilterChange("annotated")}
      />
      <FilterChip
        label="Unannotated"
        count={unannotatedCount}
        active={activeFilter === "unannotated"}
        onClick={() => onFilterChange("unannotated")}
      />
    </div>
  );
}

================
File: app/(dashboard)/components/project-details/project-detail-images.tsx
================
/* eslint-disable @next/next/no-img-element */
"use client";

import { useCallback, useEffect, useState, memo } from "react";
import { useRouter, useSearchParams } from "next/navigation";
import { toast } from "sonner";
import { getProjectImages } from "@/lib/apis/projects";
import { ArrowLeft, ImageIcon } from "lucide-react";
import { getAuthToken } from "@/lib/actions/auth";
import type { 
  ImageMetadata, 
  PaginationInfo,
  StatsProps 
} from "@/lib/types/project-detail";
import { usePageData } from "@/lib/context/page-data-context";
import { useAuth } from "@/lib/context/auth";
import { UserRole } from "@/lib/types/auth";
import { AdminProjectStatus } from "@/app/(admin)/components/users/AdminProjectStatus";
import { SubmitProjectButton } from "./SubmitProjectBtn";

// Props types
interface ImageCellProps {
  image: ImageMetadata;
  token: string;
  onClick: () => void;
}

interface HeaderProps {
  projectId: string;
  onBack: () => void;
}

interface PageCursors {
  [page: number]: string;
}

interface ProjectDetailImagesProps {
  userId: string;
  isAdmin?: boolean; // Add this to know if it's admin view
}

// Memoized Header Component
const Header = memo(function Header({ projectId, onBack }: HeaderProps) {
  return (
    <div className="h-16 flex items-center justify-between">
      <div className="flex gap-2 items-center">
        <button
          onClick={onBack}
          className="px-4 py-2 rounded-2xl bg-[#F4F4F4] text-gray-500 hover:bg-gray-500 
                   hover:text-white transition-colors duration-200 flex items-center gap-2 font-medium"
        >
          <ArrowLeft className="h-4 w-4" />
          Back
        </button>
        <h1 className="text-2xl font-bold">{projectId}</h1>
      </div>
    </div>
  );
});

// Optimized Image Cell Component
const ImageCell = memo(function ImageCell({ image, token, onClick }: ImageCellProps) {
  const [imageUrl, setImageUrl] = useState<string | null>(null);
  const [loadingStage, setLoadingStage] = useState<'initial' | 'loading' | 'loaded'>('initial');
  const [error, setError] = useState(false);

  useEffect(() => {
    const controller = new AbortController();
    let objectUrl: string | null = null;

    const loadImage = async () => {
      try {
        setLoadingStage('loading');
        const response = await fetch(image.url, {
          headers: { Authorization: `Bearer ${token}` },
          signal: controller.signal
        });

        if (!response.ok) throw new Error('Failed to load image');

        const blob = await response.blob();
        objectUrl = URL.createObjectURL(blob);
        setImageUrl(objectUrl);
        setLoadingStage('loaded');
      } catch (error) {
        if (!controller.signal.aborted) {
          console.error('Failed to load image:', error);
          setError(true);
          setLoadingStage('loaded');
        }
      }
    };

    loadImage();

    return () => {
      controller.abort();
      if (objectUrl) URL.revokeObjectURL(objectUrl);
    };
  }, [image.url, token]);

  return (
    <div 
      onClick={onClick}
      className="relative aspect-[4/3] rounded-lg overflow-hidden bg-gray-50 cursor-pointer 
                 transform transition-transform duration-200 hover:scale-[1.02]"
    >
      {/* Placeholder/Error State */}
      {(loadingStage === 'initial' || error) && (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-gray-100">
          <ImageIcon className="w-8 h-8 text-gray-400 mb-2" />
          <p className="text-sm text-gray-500">
            {error ? 'Failed to load image' : 'Loading image...'}
          </p>
        </div>
      )}

      {/* Image */}
      {imageUrl && (
        <div className="w-full h-full">
          <img
            src={imageUrl}
            alt={image.originalName}
            className={`w-full h-full object-cover transition-all duration-500
              ${loadingStage === 'loaded' ? 'opacity-100' : 'opacity-0'}
            `}
          />
        </div>
      )}

      {/* Progressive Info Overlay */}
      <div className={`
        absolute inset-x-0 bottom-0 
        bg-gradient-to-t from-black/80 via-black/40 to-transparent
        backdrop-blur-[2px]
        transition-all duration-300
        ${loadingStage === 'loaded' ? 'h-24 opacity-100' : 'h-0 opacity-0'}
      `}>
        <div className="absolute bottom-0 p-4 w-full">
          <p className="text-white font-medium truncate mb-2">
            {image.originalName}
          </p>
          <div className="flex items-center gap-2">
            <span className={`
              px-2 py-0.5 rounded-full text-xs font-medium
              ${image.isAnnotated 
                ? "bg-green-500/80 text-white" 
                : "bg-orange-500/80 text-white"}
            `}>
              {image.isAnnotated 
                ? `${image.annotations.length} annotations` 
                : "Not Annotated"}
            </span>
          </div>
        </div>
      </div>

      {/* Loading Overlay */}
      {loadingStage === 'loading' && (
        <div className="absolute inset-0 bg-gradient-to-br from-gray-100 to-gray-200">
          <div className="absolute inset-0 animate-pulse bg-gradient-to-r from-transparent via-white/20 to-transparent" />
        </div>
      )}
    </div>
  );
});

// Memoized Stats Component
const Stats = memo(function Stats({ 
  total, 
  annotatedTotal, 
  annotationRemaining 
}: StatsProps) {
  return (
    <div className="grid grid-cols-3 gap-2 p-4 bg-white rounded-[24px] shadow-lg">
      <div className="text-center">
        <p className="text-sm text-gray-500">Total Images</p>
        <p className="text-2xl font-semibold">{total}</p>
      </div>
      <div className="text-center">
        <p className="text-sm text-gray-500">Annotated</p>
        <p className="text-2xl font-semibold text-green-600">{annotatedTotal}</p>
      </div>
      <div className="text-center">
        <p className="text-sm text-gray-500">Remaining</p>
        <p className="text-2xl font-semibold text-orange-600">{annotationRemaining}</p>
      </div>
    </div>
  );
});

// Main Component
export default function ProjectDetailImages({ userId }: ProjectDetailImagesProps) {
  const router = useRouter();
  const searchParams = useSearchParams();
  const projectId = searchParams.get("projectId");
  const { user } = useAuth();
  const { setEditorData } = usePageData();

  const [images, setImages] = useState<ImageMetadata[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pagination, setPagination] = useState<PaginationInfo | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const [cursors, setCursors] = useState<PageCursors>({});
  const [currentPage, setCurrentPage] = useState(1);

  const [submissionStatus, setSubmissionStatus] = useState<{
    isSubmitted: boolean;
    submittedAt?: string;
  }>({
    isSubmitted: false
  });

  const handleImageClick = useCallback((clickedImageId: string) => {
    if (!projectId) return;
    
    setEditorData({
      imageIds: images.map(img => img.id),
      userId,
      projectId,
      clickedImageId
    });
    
    // Use different paths for admin and user
    const basePath = user?.role === UserRole.ADMIN ? '/admin/users' : '/dashboard';
    router.push(`${basePath}/${projectId}/editor`);
  }, [projectId, router, images, setEditorData, userId, user?.role]);

  const fetchImages = useCallback(async (page: number, cursor?: string) => {
    if (!projectId || !token) return;

    setLoading(true);
    try {
      const response = await getProjectImages(userId, projectId, {
        cursor,
        limit: 30,
      });
      
      setImages(response.items);
      setPagination(response.pagination);
      // Add submission status
      setSubmissionStatus({
        isSubmitted: response.isSubmitted || false,
        submittedAt: response.submittedAt
      });
      
      setCurrentPage(page);
      
      if (response.pagination.nextCursor) {
        setCursors(prev => ({
          ...prev,
          [page + 1]: response.pagination.nextCursor!
        }));
      }
      
      setError(null);
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to load images';
      setError(message);
      toast.error("Error loading images", { description: message });
    } finally {
      setLoading(false);
    }
  }, [projectId, userId, token]);

  useEffect(() => {
    const initializeToken = async () => {
      const newToken = await getAuthToken();
      if (newToken) {
        setToken(newToken);
        fetchImages(1);
      }
    };

    initializeToken();
  }, [fetchImages]);

  const handlePageChange = useCallback((newPage: number) => {
    if (newPage === currentPage) return;
    
    const cursor = newPage === 1 ? undefined : cursors[newPage];
    fetchImages(newPage, cursor);
  }, [currentPage, cursors, fetchImages]);

  if (!projectId) {
    return (
      <div className="p-4 bg-red-50 text-red-700 rounded-lg">
        Project ID not found
      </div>
    );
  }

  if (!token) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="w-8 h-8 border-4 border-gray-200 rounded-full animate-spin border-t-blue-500" />
      </div>
    );
  }

  return (
    <div className="w-full space-y-6">
      <Header projectId={projectId} onBack={() => router.back()} />

      {user?.role === UserRole.ADMIN ? (
          <AdminProjectStatus
            username={userId}
            projectId={projectId!}
            isSubmitted={submissionStatus.isSubmitted}
            submittedAt={submissionStatus.submittedAt}
            onStatusChange={() => fetchImages(currentPage)}
          />
        ) : (
          <SubmitProjectButton
            userId={userId}
            projectId={projectId!}
            isSubmitted={submissionStatus.isSubmitted}
            onSubmissionChange={() => fetchImages(currentPage)}
          />
        )}

      {loading && !images.length ? (
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {[...Array(12)].map((_, i) => (
            <div 
              key={i} 
              className="aspect-[4/3] rounded-lg bg-gradient-to-br from-gray-100 to-gray-200 animate-pulse" 
            />
          ))}
        </div>
      ) : error ? (
        <div className="p-4 bg-red-50 text-red-700 rounded-lg">{error}</div>
      ) : (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {images.map((image) => (
              <ImageCell 
                key={image.id} 
                image={image} 
                token={token}
                onClick={() => handleImageClick(image.id)}
              />
            ))}
          </div>

          <div className="fixed bottom-4 right-4 space-y-2">
            {pagination && (
              <>
                <Stats
                  total={pagination.total}
                  annotatedTotal={pagination.annotatedTotal}
                  annotationRemaining={pagination.annotationRemaining}
                />

                {pagination.totalPages > 1 && (
                  <div className="p-2 bg-white rounded-[24px] shadow-lg">
                    <div className="flex gap-2">
                      <button
                        onClick={() => handlePageChange(currentPage - 1)}
                        disabled={currentPage === 1 || loading}
                        className="px-4 py-2 rounded-2xl bg-gray-100 hover:bg-gray-200 
                                disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Previous
                      </button>
                      <span className="px-4 py-2">
                        Page {currentPage} of {pagination.totalPages}
                      </span>
                      <button
                        onClick={() => handlePageChange(currentPage + 1)}
                        disabled={currentPage === pagination.totalPages || loading}
                        className="px-4 py-2 rounded-2xl bg-gray-100 hover:bg-gray-200 
                                disabled:opacity-50 disabled:cursor-not-allowed"
                      >
                        Next
                      </button>
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        </>
      )}
    </div>
  );
}

================
File: app/(dashboard)/components/project-details/SubmitProjectBtn.tsx
================
// SubmitProjectButton.tsx
import { useState } from 'react';
import { Button } from "@/components/ui/button";
import { Check, Loader2, Send } from "lucide-react";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { fetchWithAuth } from '@/lib/apis/config';
import { toast } from 'sonner';

interface SubmitProjectButtonProps {
  userId: string;
  projectId: string;
  isSubmitted: boolean;
  onSubmissionChange: () => void;
}

export function SubmitProjectButton({ 
  userId, 
  projectId, 
  isSubmitted,
  onSubmissionChange 
}: SubmitProjectButtonProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const handleSubmit = async () => {
    try {
      setIsLoading(true);
      await fetchWithAuth(`/projects/${userId}/${projectId}/submit`, {
        method: 'POST'
      });
      
      toast.success('Project submitted successfully');
      onSubmissionChange();
    } catch {
      toast.error('Failed to submit project');
    } finally {
      setIsLoading(false);
      setIsOpen(false);
    }
  };

  return (
    <>
      <Button
        onClick={() => setIsOpen(true)}
        className="gap-2"
        variant={isSubmitted ? "secondary" : "default"}
        disabled={isLoading}
      >
        {isSubmitted ? (
          <>
            <Check className="h-4 w-4" />
            Submitted
          </>
        ) : (
          <>
            <Send className="h-4 w-4" />
            Submit Project
          </>
        )}
      </Button>

      <AlertDialog open={isOpen} onOpenChange={setIsOpen}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Submit Project</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to submit this project? This will mark all annotations as complete and notify the admin for review.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isLoading}>Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleSubmit}
              disabled={isLoading}
              className="gap-2"
            >
              {isLoading ? (
                <>
                  <Loader2 className="h-4 w-4 animate-spin" />
                  Submitting...
                </>
              ) : (
                <>
                  <Send className="h-4 w-4" />
                  Submit Project
                </>
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}

================
File: app/(dashboard)/components/project-grid.tsx
================
// app/(dashboard)/components/client-project-grid.tsx
'use client';

import { toast } from 'sonner';
import { Folder } from "lucide-react";
import { ProjectCard } from './project-card';
import { ProjectHeader } from './project-header';
import { Project } from '@/lib/types/projects';

interface ClientProjectGridProps {
  initialProjects?: Project[];
  error?: string;
}

export function ClientProjectGrid({ initialProjects, error }: ClientProjectGridProps) {
  if (!initialProjects && !error) {
    return (
      <div className="space-y-8 pgnCtn">
        <h1 className="text-2xl font-semibold tracking-tight">Collections</h1>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {[...Array(6)].map((_, i) => (
            <div key={i} className="aspect-[4/3] rounded-lg bg-gray-100 animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    toast.error('Failed to load projects', {
      description: error,
    });

    return (
      <div className="space-y-6 pgnCtn">
        <h1 className="text-2xl font-semibold tracking-tight">Collections</h1>
        <div className="bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
          <p className="text-sm">Failed to load projects: {error}</p>
        </div>
      </div>
    );
  }

  const projects = initialProjects || [];

  return (
    <div className="space-y-8 pgnCtn">
      <ProjectHeader count={projects.length} />

      {projects.length === 0 ? (
        <div className="text-center py-12 rounded-lg bg-gray-50">
          <Folder className="h-12 w-12 mx-auto text-gray-400 mb-4" />
          <p className="text-gray-600">No projects found</p>
        </div>
      ) : (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
          {projects.map((project) => (
            <ProjectCard key={project.id} project={project} />
          ))}
        </div>
      )}
    </div>
  );
}

================
File: app/(dashboard)/components/project-header.tsx
================
// app/(dashboard)/components/project-header.tsx
'use client';

interface ProjectHeaderProps {
  count: number;
}

export function ProjectHeader({ count }: ProjectHeaderProps) {
  return (
    <div className="flex items-center justify-between">
      <h1 className="text-2xl font-semibold tracking-tight">All Assigned Projects</h1>
      <p className="text-sm font-semibold text-gray-500 px-4 py-2 rounded-2xl bg-[#F4F4F4]">
        {count} {count === 1 ? "Project" : "Projects"}
      </p>
    </div>
  );
}

================
File: app/(dashboard)/dashboard/[ProjectId]/editor/page.tsx
================
"use client";

import { useCallback, useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { toast } from "sonner";
import { Loader2 } from "lucide-react";
import { usePageData } from "@/lib/context/page-data-context";
import {
  getClasses,
  getAnnotations,
  updateAnnotations,
} from "@/lib/apis/annotations";
import type { Annotation, AnnotationState } from "@/lib/types/annotations";
import PhotoViewer from "@/app/(dashboard)/components/editor/PhotoViewer";
import { getImage } from "@/lib/apis/images";
import { getAuthToken } from "@/lib/actions/auth";

export default function EditorPage() {
  const router = useRouter();
  const { editorData } = usePageData();
  const [isLoading, setIsLoading] = useState(true);
  const [annotationClasses, setAnnotationClasses] = useState<string[]>([]);
  const [currentImageIndex, setCurrentImageIndex] = useState(() => {
    if (!editorData) return 0;
    const index = editorData.imageIds.findIndex(
      (id) => id === editorData.clickedImageId
    );
    return index >= 0 ? index : 0;
  });
  const [isOfficeUser, setIsOfficeUser] = useState(false);
  const [imageUrl, setImageUrl] = useState<string>("");
  const [annotationState, setAnnotationState] = useState<AnnotationState>({
    annotations: [],
    isAnnotated: false,
  });
  const [token, setToken] = useState<string | null>(null);

  // Navigate back if no editor data
  useEffect(() => {
    if (!editorData) {
      router.replace("/dashboard");
    } else {
      const init = async () => {
        try {
          const authToken = await getAuthToken();
          setToken(authToken ?? null);
        } catch (error) {
          console.error("Error initializing:", error);
          toast.error("Failed to auth token");
        }
      };
      init();
    }
  }, [editorData, router]);

  // Fetch image data
  const fetchImage = useCallback(async () => {
    if (!editorData || !token) return;

    const controller = new AbortController();
    let objectUrl = "";

    try {
      const currentImageId = editorData.imageIds[currentImageIndex];
      setImageUrl(""); // Clear previous image URL

      const imageData = await getImage(
        editorData.userId,
        editorData.projectId,
        currentImageId
      );

      // Check if component is still mounted (controller not aborted)
      if (controller.signal.aborted) return;

      const response = await fetch(imageData.url, {
        headers: { Authorization: `Bearer ${token}` },
        signal: controller.signal,
      });

      if (!response.ok) throw new Error("Failed to load image");

      const blob = await response.blob();
      objectUrl = URL.createObjectURL(blob);
      setImageUrl(objectUrl);
    } catch (error) {
      if (!controller.signal.aborted) {
        // Only show error if not aborted
        toast.error("Failed to load image", {
          description: error instanceof Error ? error.message : "Unknown error",
        });
        console.error("Error loading image:", error);
      }
    }

    return () => {
      controller.abort();
      if (objectUrl) URL.revokeObjectURL(objectUrl);
    };
  }, [editorData, currentImageIndex, token]);

  // Add effect to handle image changes
  useEffect(() => {
    if (currentImageIndex >= 0) {
      const cleanupPromise = fetchImage();
      cleanupPromise.then((cleanup) => {
        if (cleanup) cleanup();
      });
      return () => {
        cleanupPromise.then((cleanup) => {
          if (cleanup) cleanup();
        });
      };
    }
  }, [currentImageIndex, fetchImage]);

  // Fetch annotation classes
  const fetchClasses = useCallback(async () => {
    if (!editorData) return;

    try {
      const { classes, isOfficeUser: isOffice } = await getClasses(
        editorData.userId,
        editorData.projectId
      );
      setAnnotationClasses(classes);
      setIsOfficeUser(isOffice);
    } catch (error) {
      toast.error("Failed to load annotation classes");
      console.error("Error loading classes:", error);
    }
  }, [editorData]);

  // Fetch annotations for current image
  const fetchAnnotations = useCallback(async () => {
    if (!editorData) return;

    try {
      const currentImageId = editorData.imageIds[currentImageIndex];
      const annotations = await getAnnotations(
        editorData.userId,
        editorData.projectId,
        currentImageId
      );
      setAnnotationState(annotations);
    } catch (error) {
      toast.error("Failed to load annotations");
      console.error("Error loading annotations:", error);
    }
  }, [editorData, currentImageIndex]);

  useEffect(() => {
    if (!editorData || !token) return; // Add token check here

    const loadData = async () => {
      setIsLoading(true);
      try {
        await Promise.all([fetchImage(), fetchClasses(), fetchAnnotations()]);
      } catch (error) {
        console.error("Error loading data:", error);
        toast.error("Failed to load data");
      } finally {
        setIsLoading(false);
      }
    };

    void loadData();
  }, [fetchImage, fetchClasses, fetchAnnotations, editorData, token]); // Add token dependency

  // Save annotations handler
  const handleSaveAnnotations = useCallback(
    async (annotations: Annotation[], customClass?: string) => {
      if (!editorData) return;

      try {
        const currentImageId = editorData.imageIds[currentImageIndex];
        await updateAnnotations(
          editorData.userId,
          editorData.projectId,
          currentImageId,
          annotations,
          customClass
        );

        setAnnotationState((prev) => ({
          ...prev,
          annotations,
          isAnnotated: annotations.length > 0,
        }));

        toast.success("Annotations saved successfully");
      } catch (error) {
        toast.error("Failed to save annotations");
        console.error("Error saving annotations:", error);
      }
    },
    [editorData, currentImageIndex]
  );

  // Navigation handlers
  const handleNext = useCallback(() => {
    if (!editorData) return;
    if (currentImageIndex < editorData.imageIds.length - 1) {
      setCurrentImageIndex((prev) => prev + 1);
    }
  }, [editorData, currentImageIndex]);

  const handlePrevious = useCallback(() => {
    if (currentImageIndex > 0) {
      setCurrentImageIndex((prev) => prev - 1);
    }
  }, [currentImageIndex]);

  if (!editorData || isLoading || !imageUrl) {
    return (
      <div className="h-screen w-full flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <Loader2 className="w-8 h-8 animate-spin text-primary" />
          <p className="text-muted-foreground">Loading editor...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-screen w-full">
      <PhotoViewer
        currentImageId={editorData.imageIds[currentImageIndex]}
        annotationState={annotationState}
        availableClasses={annotationClasses}
        isOfficeUser={isOfficeUser}
        imageUrl={imageUrl}
        onSave={handleSaveAnnotations}
        onNext={handleNext}
        onPrevious={handlePrevious}
        onBack={() => {
          // Navigate back logic here, e.g.:
          router.back();
        }}
        currentIndex={currentImageIndex}
        totalImages={editorData.imageIds.length}
        hasPrevious={currentImageIndex > 0}
        hasNext={currentImageIndex < editorData.imageIds.length - 1}
      />
    </div>
  );
}

================
File: app/(dashboard)/dashboard/[ProjectId]/page.tsx
================
// app/(dashboard)/projects/[projectId]/page.tsx
import { getCurrentUser } from "@/lib/apis/auth"
import { redirect } from "next/navigation"
import ProjectDetailImages from "../../components/project-details/project-detail-images"

export default async function ProjectPage() {
  const user = await getCurrentUser()

  if (!user?.username) {
    redirect("/login")
  }

  return (
    <div className="w-full min-h-screen bg-white pgnCtn">
      <ProjectDetailImages userId={user.username} />
    </div>
  )
}

================
File: app/(dashboard)/dashboard/layout.tsx
================
// app/(dashboard)/layout.tsx
import { redirect } from "next/navigation";
import { getCurrentUser } from "@/lib/apis/auth";
import { UserRole } from "@/lib/types/auth";
import { PageDataProvider } from "@/lib/context/page-data-context";
import { Navbar } from "../components/navbar";

export default async function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await getCurrentUser();

  if (!user) {
    redirect("/login");
  }

  // Prevent admins from accessing user dashboard
  if (user.role === UserRole.ADMIN) {
    redirect("/admin");
  }

  return (
    <div className="min-h-screen bg-white">
      <Navbar user={user} />
      <main>
        <PageDataProvider>{children}</PageDataProvider>
      </main>
    </div>
  );
}

================
File: app/(dashboard)/dashboard/page.tsx
================
// app/(dashboard)/components/project-grid.tsx
import { getCurrentUser } from '@/lib/apis/auth';
import { getAllProjects } from '@/lib/apis/projects';
import { ClientProjectGrid } from '../components/project-grid';

export default async function Dashboard() {
  const user = await getCurrentUser();
  
  if (!user?.username) {
    return null;
  }

  try {
    const response = await getAllProjects(user.username);
    return <ClientProjectGrid initialProjects={response.projects} />;
  } catch (error) {
    return <ClientProjectGrid error={error instanceof Error ? error.message : 'Failed to load projects'} />;
  }
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Add global padding */
.pgnCtn {
  @apply px-6 py-8;  /* 24px horizontal, 32px vertical padding */
}

/* Remove padding from specific pgnCtns if needed */
.pgnCtn.no-padding {
  @apply p-0;
}

img,
video {
  height: auto;
  max-width: 100%;
}

audio,
canvas,
embed,
iframe,
img,
object,
svg,
video {
  display: block;
}

img {
  overflow-clip-margin: content-box;
  overflow: clip;
}

h1,
h2,
h3,
h4,
h5,
h6,
p {
  text-wrap: balance;
}

.ios-loader {
  width: 48px;
  height: 48px;
  border: 5px solid #0F0F0F;
  border-bottom-color: transparent;
  border-radius: 50%;
  display: inline-block;
  box-sizing: border-box;
  animation: rotation 1s linear infinite;
  }

@keyframes rotation {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

================
File: app/layout.tsx
================
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { Suspense } from "react";
import { AuthProvider } from "@/lib/context/auth";
import { getCurrentUser } from "@/lib/apis/auth";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const runtime = "edge";

export const metadata: Metadata = {
  title: "Annot8R: Client-Server",
  description: "Generated by create next app",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Get initial auth state
  const user = await getCurrentUser();

  return (
    <html lang="en">
      <head>
        {/* <script>
          {`
            // Disable right-click
            document.addEventListener('contextmenu', (e) => e.preventDefault());

            // Disable certain key combinations
            document.addEventListener('keydown', (e) => {
              if (e.ctrlKey && (e.key === 'u' || e.key === 'U')) {
                e.preventDefault();
              }
              if (e.ctrlKey && e.shiftKey && (e.key === 'i' || e.key === 'I' || e.key === 'j' || e.key === 'J')) {
                e.preventDefault();
              }
              if (e.key === 'F12') {
                e.preventDefault();
              }
            });

            // Detect if DevTools is open (optional)
            const devToolsDetected = () => {
              const threshold = 160;
              const widthThreshold = window.outerWidth - window.innerWidth > threshold;
              const heightThreshold = window.outerHeight - window.innerHeight > threshold;
              if (widthThreshold || heightThreshold) {
                alert("DevTools is open. Please close it to continue.");
                window.close();
              }
            };

            setInterval(devToolsDetected, 1000);
          `}
        </script> */}
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Suspense>
          <AuthProvider initialUser={user}>{children}</AuthProvider>
        </Suspense>
      </body>
    </html>
  );
}

================
File: lib/actions/auth.ts
================
// lib/actions/auth.ts
"use server";

import { cookies } from "next/headers";
import { redirect } from "next/navigation";
import { revalidatePath } from "next/cache";
import { login as loginApi, logout as logoutApi } from "@/lib/apis/auth";
import type { LoginCredentials, DeviceInfo } from "@/lib/types/auth";

export async function login(credentials: LoginCredentials) {
  try {
    console.log("Sending login credentials to API", {
      ...credentials,
      password: "[REDACTED]", // Don't log actual password
    });

    const response = await loginApi(credentials);

    // Log the token for debugging (remove in production)
    if (response && response.token) {
      console.log(
        "Auth token received:",
        response.token.substring(0, 10) + "..."
      );

      const cookieStore = await cookies();

      // Set auth cookie - make sure there are no extra spaces or encoding issues
      cookieStore.set("auth_token", response.token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        expires: new Date(response.expiry),
        path: "/",
      });

      // Force revalidation
      revalidatePath("/", "layout");

      // Redirect based on role
      redirect(response.redirectTo);
    } else {
      console.error("Invalid response from login API", response);
      throw new Error("Invalid response from login API");
    }
  } catch (error) {
    console.error("Login action error:", error);
    if (error instanceof Error) {
      throw error;
    }
    throw new Error("Login failed. Please try again.");
  }
}

export async function logout() {
  try {
    // Call API to invalidate token
    await logoutApi();
  } finally {
    // Always remove cookie and redirect, even if API call fails
    const cookieStore = await cookies();
    cookieStore.delete("auth_token");
    redirect("/login");
  }
}

export async function getAuthToken(): Promise<string | undefined> {
  const cookieStore = await cookies();
  return cookieStore.get("auth_token")?.value;
}

// Helper to verify client's device info matches stored info
export async function verifyDeviceInfo(
  deviceInfo: DeviceInfo
): Promise<boolean> {
  const token = await getAuthToken();
  if (!token) return false;

  try {
    const res = await fetch(
      `${process.env.NEXT_PUBLIC_API_BASE}/api/v1/auth/verify`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ deviceInfo }),
      }
    );

    return res.ok;
  } catch {
    return false;
  }
}

================
File: lib/apis/admins.ts
================
// lib/apis/admins.ts
import { fetchWithAuth } from "./config";
import { AdminInfo } from "../types/admins";

export interface CreateAdminPayload {
  username: string;
  password: string;
  isSuperAdmin?: boolean;
}

// Get all admins (super admin only)
export async function getAllAdmins(): Promise<AdminInfo[]> {
  const response = await fetchWithAuth("/admins");
  return response.admins;
}

// Create new admin (super admin only)
export async function createAdmin(
  adminData: CreateAdminPayload
): Promise<boolean> {
  const response = await fetchWithAuth("/admins", {
    method: "POST",
    body: JSON.stringify(adminData),
  });

  return response.success === true;
}

// Delete admin (super admin only)
export async function deleteAdmin(adminId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/admins/${adminId}`, {
    method: "DELETE",
  });

  return response.success === true;
}

// Reset admin password (super admin only)
export async function resetAdminPassword(
  adminId: string,
  newPassword: string
): Promise<boolean> {
  const response = await fetchWithAuth(`/admins/${adminId}/password`, {
    method: "PUT",
    body: JSON.stringify({
      username: adminId,
      newPassword,
    }),
  });

  return response.success === true;
}

// Get admin logs (super admin only)
export async function getAdminLogs(
  adminId: string,
  page: number = 1,
  limit: number = 20
): Promise<{
  logs: Array<{
    _id: string;
    timestamp: Date;
    logType: string;
    details: {
      userAgent: string;
      ip: string;
      path?: string;
      additionalInfo?: string;
    };
  }>;
  pagination: {
    total: number;
    page: number;
    totalPages: number;
  };
}> {
  return fetchWithAuth(`/admins/${adminId}/logs?page=${page}&limit=${limit}`);
}

================
File: lib/apis/annotations.ts
================
// lib/apis/annotations.ts
import { fetchWithAuth } from "./config";
import type {
  Annotation,
  AnnotationState,
  AnnotationResponse,
  ClassesResponse,
} from "@/lib/types/annotations";

/**
 * Get all annotations for an image
 */
export async function getAnnotations(
  userId: string,
  projectId: string,
  imageId: string
): Promise<AnnotationState> {
  try {
    const response: AnnotationResponse = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/annotations`
    );

    if (!response.success || !response.data) {
      throw new Error(response.error || "Failed to fetch annotations");
    }

    return response.data;
  } catch (error) {
    console.error("Error fetching annotations:", error);
    // Return empty state if error
    return {
      annotations: [],
      isAnnotated: false,
    };
  }
}

/**
 * Update annotations for an image
 */
export async function updateAnnotations(
  userId: string,
  projectId: string,
  imageId: string,
  annotations: Annotation[],
  customClass?: string
): Promise<boolean> {
  try {
    const response = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/annotations`,
      {
        method: "POST",
        body: JSON.stringify({
          annotations,
          ...(customClass && { customClass }),
        }),
      }
    );

    if (!response.success) {
      throw new Error(response.error || "Failed to update annotations");
    }

    return true;
  } catch (error) {
    console.error("Error updating annotations:", error);
    throw error;
  }
}

/**
 * Get all annotation classes for a project
 */
export async function getClasses(
  userId: string,
  projectId: string
): Promise<{ classes: string[]; isOfficeUser: boolean }> {
  try {
    const response: ClassesResponse = await fetchWithAuth(
      `/projects/${projectId}/classes`
    );

    if (!response.success || !response.data) {
      console.error("Failed to fetch classes:", response.error);
      return {
        classes: [],
        isOfficeUser: false,
      };
    }

    // Clean up class names by removing the numbering
    const cleanedClasses = response.data.classes.map((className) => {
      // Remove numbering pattern (e.g., "- 01", "- 1", etc.)
      return className.split("-")[0].trim();
    });

    return {
      classes: cleanedClasses,
      isOfficeUser: response.data.isOfficeUser,
    };
  } catch (error) {
    console.error("Error fetching classes:", error);
    return {
      classes: [],
      isOfficeUser: false,
    };
  }
}

/**
 * Review annotations (admin only)
 */
export async function reviewAnnotations(
  projectId: string,
  imageId: string,
  status: "approved" | "changes_requested",
  feedback?: string
): Promise<boolean> {
  try {
    const response = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/review`,
      {
        method: "POST",
        body: JSON.stringify({ status, feedback }),
      }
    );

    if (!response.success) {
      throw new Error(response.error || "Failed to review annotations");
    }

    return true;
  } catch (error) {
    console.error("Error reviewing annotations:", error);
    return false;
  }
}

================
File: lib/apis/auth.ts
================
// lib/apis/auth.ts
import { cookies } from "next/headers";
import { AuthResponse, LoginCredentials, UserInfo } from "../types/auth";
import { API_BASE } from "./config";

export async function login(
  credentials: LoginCredentials
): Promise<AuthResponse> {
  try {
    // Add debugging for the URL we're hitting
    const loginUrl = `${API_BASE}/auth/login`;
    console.log("Attempting login at URL:", loginUrl);
    
    const res = await fetch(loginUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(credentials),
    });

    // Log the raw response for debugging
    console.log("Status:", res.status);
    
    // Check if the response is JSON before trying to parse it
    const contentType = res.headers.get("content-type");
    const isJson = contentType && contentType.includes("application/json");
    
    if (!isJson) {
      const rawText = await res.text();
      console.error("Non-JSON response:", rawText);
      throw new Error("Server did not return JSON. Check API endpoint URL.");
    }
    
    const data = await res.json();
    console.log("Response data:", data);

    if (!res.ok) {
      throw new Error(data.error || "Failed to login");
    }

    return data as AuthResponse;
  } catch (error) {
    console.error("Login error:", error);
    throw error;
  }
}

export async function getCurrentUser(): Promise<UserInfo | null> {
  const cookieStore = await cookies();
  const token = cookieStore.get("auth_token")?.value;

  if (!token) return null;

  try {
    const res = await fetch(`${API_BASE}/auth/me`, {
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      cache: "no-store",
    });

    if (!res.ok) {
      console.error("Auth error:", res.status, await res.text());
      return null;
    }

    return await res.json();
  } catch (error) {
    console.error("Error fetching user:", error);
    return null;
  }
}

export async function verifyAuth(): Promise<boolean> {
  const cookieStore = await cookies();
  const token = cookieStore.get("auth_token")?.value;

  if (!token) return false;

  try {
    const res = await fetch(`${API_BASE}/auth/verify`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        deviceInfo: {
          platform: navigator.platform,
          screenResolution: `${window.screen.width}x${window.screen.height}`,
          language: navigator.language,
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
      }),
    });

    if (!res.ok) return false;

    const data = await res.json();
    return data.valid;
  } catch {
    return false;
  }
}

export async function logout(): Promise<void> {
  const cookieStore = await cookies();
  const token = cookieStore.get("auth_token")?.value;

  if (!token) return;

  await fetch(`${API_BASE}/auth/logout`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  // Cookie will be removed by the server response
}

================
File: lib/apis/config.ts
================
// lib/apis/config.ts
import { getAuthToken } from "../actions/auth";

// Define API_BASE for both browser and server environments
export const API_BASE =
  typeof window !== "undefined"
    ? window.location.hostname === "localhost"
      ? "http://localhost:3001/api/v1"
      : `${window.location.origin}/api/v1`
    : process.env.NEXT_PUBLIC_API_BASE || "http://localhost:3001/api/v1";

// Log the API base for debugging
console.log("API_BASE initialized as:", API_BASE);

export class ApiError extends Error {
  constructor(public statusCode: number, message: string) {
    super(message);
    this.name = "ApiError";
  }
}

export async function fetchWithAuth(
  endpoint: string,
  options: RequestInit = {}
) {
  const token = await getAuthToken();

  if (!token) {
    throw new ApiError(401, "No authentication token available");
  }

  console.log("Making API request to:", `${API_BASE}${endpoint}`);
  console.log("With headers:", {
    Authorization: "Bearer [redacted]",
    "Content-Type": "application/json",
    ...options.headers,
  });

  const response = await fetch(`${API_BASE}${endpoint}`, {
    ...options,
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
      ...options.headers,
    },
  });

  const contentType = response.headers.get("content-type");
  const isJson = contentType?.includes("application/json");

  if (!response.ok) {
    const error = isJson ? await response.json() : await response.text();
    console.error("API Error:", error);
    throw new ApiError(
      response.status,
      error.error || error || `HTTP error! status: ${response.status}`
    );
  }

  const data = isJson ? await response.json() : response;
  console.log("API Response:", data);
  return data;
}

================
File: lib/apis/images.ts
================
// lib/apis/annotations.ts
import { fetchWithAuth } from "./config";
import type {
  Annotation,
  AnnotationState,
  AnnotationResponse,
  ClassesResponse,
} from "@/lib/types/annotations";

/**
 * Get all annotations for an image
 */
export async function getAnnotations(
  userId: string,
  projectId: string,
  imageId: string
): Promise<AnnotationState> {
  try {
    const response: AnnotationResponse = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/annotations`
    );

    if (!response.success || !response.data) {
      throw new Error(response.error || "Failed to fetch annotations");
    }

    return response.data;
  } catch (error) {
    console.error("Error fetching annotations:", error);
    // Return empty state if error
    return {
      annotations: [],
      isAnnotated: false,
    };
  }
}

/**
 * Update annotations for an image
 */
export async function updateAnnotations(
  userId: string,
  projectId: string,
  imageId: string,
  annotations: Annotation[],
  customClass?: string
): Promise<boolean> {
  try {
    const response = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/annotations`,
      {
        method: "POST",
        body: JSON.stringify({
          annotations,
          ...(customClass && { customClass }),
        }),
      }
    );

    if (!response.success) {
      throw new Error(response.error || "Failed to update annotations");
    }

    return true;
  } catch (error) {
    console.error("Error updating annotations:", error);
    throw error;
  }
}

/**
 * Get all annotation classes for a project
 */
export async function getClasses(
  userId: string,
  projectId: string
): Promise<{ classes: string[]; isOfficeUser: boolean }> {
  try {
    const response: ClassesResponse = await fetchWithAuth(
      `/projects/${projectId}/classes`
    );

    if (!response.success || !response.data) {
      console.error("Failed to fetch classes:", response.error);
      return {
        classes: [],
        isOfficeUser: false,
      };
    }

    // Clean up class names by removing the numbering
    const cleanedClasses = response.data.classes.map((className) => {
      // Remove numbering pattern (e.g., "- 01", "- 1", etc.)
      return className.split("-")[0].trim();
    });

    return {
      classes: cleanedClasses,
      isOfficeUser: response.data.isOfficeUser,
    };
  } catch (error) {
    console.error("Error fetching classes:", error);
    return {
      classes: [],
      isOfficeUser: false,
    };
  }
}

/**
 * Review annotations (admin only)
 */
export async function reviewAnnotations(
  projectId: string,
  imageId: string,
  status: "approved" | "changes_requested",
  feedback?: string
): Promise<boolean> {
  try {
    const response = await fetchWithAuth(
      `/projects/${projectId}/images/${imageId}/review`,
      {
        method: "POST",
        body: JSON.stringify({ status, feedback }),
      }
    );

    if (!response.success) {
      throw new Error(response.error || "Failed to review annotations");
    }

    return true;
  } catch (error) {
    console.error("Error reviewing annotations:", error);
    return false;
  }
}

================
File: lib/apis/logs.ts
================
// lib/apis/logs.ts
import { SecurityLogType } from "../types/logs";
import { fetchWithAuth } from "./config";

export interface SecurityLogFilters {
  userId?: string;
  logType?: SecurityLogType | SecurityLogType[];
  startDate?: Date;
  endDate?: Date;
  ip?: string;
  page?: number;
  limit?: number;
}

export interface SecurityLog {
  _id: string;
  userId: string;
  timestamp: Date;
  logType: SecurityLogType;
  details: {
    userAgent: string;
    ip: string;
    path?: string;
    keyPressed?: string;
    requestCount?: number;
    deviceInfo?: string;
    additionalInfo?: string;
  };
}

export interface LogsResponse {
  logs: SecurityLog[];
  pagination: {
    total: number;
    page: number;
    totalPages: number;
    limit: number;
  };
}

// Get security logs (admin only)
export async function getSecurityLogs(filters: SecurityLogFilters = {}): Promise<LogsResponse> {
  const queryParams = new URLSearchParams();
  
  if (filters.userId) queryParams.append('userId', filters.userId);
  if (filters.ip) queryParams.append('ip', filters.ip);
  
  if (filters.logType) {
    if (Array.isArray(filters.logType)) {
      filters.logType.forEach(type => queryParams.append('logType', type));
    } else {
      queryParams.append('logType', filters.logType);
    }
  }
  
  if (filters.startDate) queryParams.append('startDate', filters.startDate.toISOString());
  if (filters.endDate) queryParams.append('endDate', filters.endDate.toISOString());
  
  const page = filters.page || 1;
  const limit = filters.limit || 50;
  
  queryParams.append('page', page.toString());
  queryParams.append('limit', limit.toString());
  
  const queryString = queryParams.toString();
  
  return fetchWithAuth(`/logs?${queryString}`);
}

// Get security stats (admin only)
export async function getSecurityStats(timeframe: number = 24): Promise<{
  timeframe: number;
  totalEvents: number;
  topUsers: Array<{ _id: string; count: number }>;
  eventDistribution: Array<{ _id: SecurityLogType; count: number }>;
  recentEvents: SecurityLog[];
}> {
  return fetchWithAuth(`/logs/stats?timeframe=${timeframe}`);
}

// Get user security summary (admin only)
export async function getUserSecuritySummary(userId: string): Promise<{
  recentLogs: SecurityLog[];
  summary: Array<{ 
    _id: SecurityLogType; 
    count: number; 
    lastOccurrence: Date 
  }>;
  totalEvents: number;
}> {
  return fetchWithAuth(`/logs/users/${userId}`);
}

// Get admin logs (super admin only)
export async function getAdminLogs(
  adminId: string,
  page: number = 1,
  limit: number = 20
): Promise<LogsResponse> {
  return fetchWithAuth(`/logs/admins/${adminId}?page=${page}&limit=${limit}`);
}

// Log security event from client
export async function logSecurityEvent(
  logType: SecurityLogType,
  additionalInfo?: string,
  keyPressed?: string
): Promise<boolean> {
  const response = await fetchWithAuth("/logs/events", {
    method: "POST",
    body: JSON.stringify({
      logType,
      additionalInfo,
      keyPressed,
    }),
  });
  
  return response.success === true;
}

================
File: lib/apis/projects.ts
================
// lib/apis/projects.ts
import { fetchWithAuth } from "./config";
import type {
  Project,
  AssignedProject,
  ImageAssignment,
  ProjectMember,
  AnnotationFormat,
  ProjectStatus,
} from "../types/project";

// Get assigned projects (for regular users)
export async function getAssignedProjects(userId: string): Promise<AssignedProject[]> {
  const response = await fetchWithAuth(`/users/${userId}/projects`);
  return response.projects;
}

// Get all projects (for admins)
export async function getAllProjects(username?: string): Promise<{projects: Project[]}> {
  // If username is provided, get projects for that user
  if (username) {
    const response = await fetchWithAuth(`/users/${username}/projects`);
    return response;
  }
  // Otherwise get all projects (admin view)
  const response = await fetchWithAuth("/projects");
  return response;
}

// Create new project
export async function createProject(
  projectData: {
    name: string;
    description?: string;
    settings: {
      modelFormat: AnnotationFormat;
      allowCustomClasses: boolean;
      requireReview: boolean;
      autoDistribute: boolean;
    };
    classes: string[];
    status: ProjectStatus;
    totalImages: number;
    members: ProjectMember[];
  }
): Promise<string> {
  const response = await fetchWithAuth("/projects", {
    method: "POST",
    body: JSON.stringify(projectData),
  });

  if (!response.success) {
    console.error("Project creation error:", response.error);
    throw new Error(response.error?.message || "Failed to create project");
  }

  return response.projectId;
}

// Get project details
export async function getProjectDetails(projectId: string): Promise<Project> {
  try {
    console.log(`Fetching project details for ID: ${projectId}`);
    const response = await fetchWithAuth(`/projects/${projectId}`);

    // Log the raw response for debugging
    console.log("Raw project details response:", response);

    if (!response.success) {
      throw new Error(response.error || "Failed to fetch project details");
    }

    // Ensure dates are properly converted to Date objects
    const project = response.project;

    if (project) {
      // Convert string dates to Date objects where needed
      if (typeof project.createdAt === "string") {
        project.createdAt = new Date(project.createdAt);
      }

      if (typeof project.stats?.lastActivity === "string") {
        project.stats.lastActivity = new Date(project.stats.lastActivity);
      }

      // Process member dates if they exist
      if (project.members) {
        project.members = project.members.map((member: ProjectMember) => ({
          ...member,
          lastActivity: member.lastActivity
            ? new Date(member.lastActivity)
            : undefined,
        }));
      }
    }

    return project;
  } catch (error) {
    console.error("Error in getProjectDetails:", error);
    throw error;
  }
}

// Update project
export async function updateProject(
  projectId: string,
  updates: Partial<Project>
): Promise<boolean> {
  const response = await fetchWithAuth(`/projects/${projectId}`, {
    method: "PUT",
    body: JSON.stringify(updates),
  });
  return response.success;
}

// Add project member
export async function addProjectMember(
  projectId: string,
  userId: string,
  allocationPercentage: number
): Promise<boolean> {
  const response = await fetchWithAuth(`/projects/${projectId}/members`, {
    method: "POST",
    body: JSON.stringify({
      userId,
      allocationPercentage,
      redistributeTasks: true, // Add this flag to enable task redistribution
    }),
  });

  if (!response.success) {
    console.error("Failed to add project member:", response.error);
    throw new Error(response.error || "Failed to add project member");
  }

  return response.success;
}

// Update member allocation
export async function updateMemberAllocation(
  projectId: string,
  userId: string,
  allocationPercentage: number
): Promise<boolean> {
  const response = await fetchWithAuth(
    `/projects/${projectId}/members/${userId}`,
    {
      method: "PUT",
      body: JSON.stringify({
        allocationPercentage,
        redistributeTasks: true, // Add this flag to enable task redistribution
      }),
    }
  );

  if (!response.success) {
    console.error("Failed to update member allocation:", response.error);
    throw new Error(response.error || "Failed to update member allocation");
  }

  return response.success;
}

// Remove project member with task reassignment
export async function removeProjectMember(
  projectId: string,
  userId: string
): Promise<boolean> {
  const response = await fetchWithAuth(
    `/projects/${projectId}/members/${userId}`,
    {
      method: "DELETE",
      body: JSON.stringify({
        redistributeTasks: true, // Add this flag to enable task redistribution
      }),
    }
  );

  if (!response.success) {
    console.error("Failed to remove project member:", response.error);
    throw new Error(response.error || "Failed to remove project member");
  }

  return response.success;
}

// Get all users (for member selection)
export async function getAllUsers(): Promise<
  { username: string; isLocked: boolean }[]
> {
  const response = await fetchWithAuth("/users");

  if (!response.users) {
    console.error("Failed to get users:", response.error);
    throw new Error(response.error || "Failed to get users");
  }

  return response.users;
}

// Get project stats
export async function getProjectStats(projectId: string): Promise<{
  totalImages: number;
  assignedImages: number;
  completedImages: number;
  approvedImages: number;
  memberStats: {
    userId: string;
    assigned: number;
    completed: number;
    approved: number;
    timeSpent: number;
  }[];
}> {
  const response = await fetchWithAuth(`/projects/${projectId}/stats`);
  return response.stats;
}

// Get member assignments
export async function getMemberAssignments(
  projectId: string,
  page: number = 1,
  limit: number = 20
): Promise<{
  assignments: ImageAssignment[];
  total: number;
  page: number;
  totalPages: number;
}> {
  const response = await fetchWithAuth(
    `/projects/${projectId}/assignments?page=${page}&limit=${limit}`
  );
  return response;
}

// Submit project for review
export async function submitProject(userId: string, projectId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/projects/${projectId}/submit`, {
    method: "POST"
  });
  
  return response.success === true;
}

// Unmark project (admin only)
export async function unmarkProject(projectId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/projects/${projectId}/unmark`, {
    method: "POST"
  });
  
  return response.success === true;
}

================
File: lib/apis/users.ts
================
// lib/apis/users.ts
import { SecurityLogType } from "../types/logs";
import { fetchWithAuth } from "./config";

export interface CreateUserPayload {
  username: string;
  password: string;
  isOfficeUser?: boolean;
}

export interface UserResponse {
  username: string;
  isLocked: boolean;
  lockReason?: string;
  lastLoginAttempt: Date;
  failedLoginAttempts: number;
  isOfficeUser: boolean;
  activeDevice?: {
    lastSeen: Date;
    ip: string;
    userAgent: string;
  };
  activityLog: Array<{
    timestamp: Date;
    action: string;
    ip: string;
    userAgent: string;
    endpoint: string;
    responseTime: number;
  }>;
}

// Get all users (admin only)
export async function getAllUsers() {
  return fetchWithAuth("/users");
}

// Get user details
export async function getUserDetails(userId: string): Promise<UserResponse> {
  const response = await fetchWithAuth(`/users/${userId}`);
  return response.user;
}

// Create new user (admin only)
export async function createUser(userData: CreateUserPayload): Promise<boolean> {
  const response = await fetchWithAuth("/users", {
    method: "POST",
    body: JSON.stringify(userData),
  });
  
  return response.success === true;
}

// Reset password (admin only)
export async function resetPassword(userId: string, newPassword: string): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}/password`, {
    method: "PUT",
    body: JSON.stringify({ newPassword }),
  });
  
  return response.success === true;
}

// Lock user
export async function lockUser(userId: string, reason?: string): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}/status`, {
    method: "PUT",
    body: JSON.stringify({ 
      action: "lock",
      reason 
    }),
  });
  
  return response.success === true;
}

// Unlock user
export async function unlockUser(userId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}/status`, {
    method: "PUT",
    body: JSON.stringify({ action: "unlock" }),
  });
  
  return response.success === true;
}

// Force logout user
export async function forceLogoutUser(userId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}/sessions`, {
    method: "DELETE",
  });
  
  return response.success === true;
}

// Delete user
export async function deleteUser(userId: string): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}`, {
    method: "DELETE",
  });
  
  return response.success === true;
}

// Update office status
export async function updateOfficeStatus(userId: string, isOfficeUser: boolean): Promise<boolean> {
  const response = await fetchWithAuth(`/users/${userId}/office-status`, {
    method: "PUT",
    body: JSON.stringify({ isOfficeUser }),
  });
  
  return response.success === true;
}

// Get user security logs
export async function getUserLogs(
  userId: string, 
  page: number = 1, 
  limit: number = 50,
  logType?: SecurityLogType
): Promise<{
  logs: Array<{
    _id: string;
    userId: string;
    timestamp: Date;
    logType: SecurityLogType;
    details: {
      userAgent: string;
      ip: string;
      path?: string;
      additionalInfo?: string;
    };
  }>;
  pagination: {
    total: number;
    page: number;
    totalPages: number;
    limit: number;
  };
}> {
  let query = `/users/${userId}/logs?page=${page}&limit=${limit}`;
  if (logType) {
    query += `&logType=${logType}`;
  }
  
  return fetchWithAuth(query);
}

================
File: lib/context/auth.tsx
================
// lib/context/auth.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { UserInfo } from "../types/auth";

interface AuthContextType {
  user: UserInfo | null;
  isLoading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}

export function AuthProvider({
  children,
  initialUser,
}: {
  children: React.ReactNode;
  initialUser: UserInfo | null;
}) {
  const [user, setUser] = useState<UserInfo | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    setUser(initialUser);
    setIsLoading(false);
  }, [initialUser]);

  return (
    <AuthContext.Provider value={{ user, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
}

================
File: lib/context/page-data-context.tsx
================
// lib/context/page-data-context.tsx
'use client';

import { createContext, useContext, useState } from 'react';

interface EditorPageData {
  imageIds: string[];
  userId: string;
  projectId: string;
  clickedImageId: string,
}

interface PageDataContextType {
  editorData: EditorPageData | null;
  setEditorData: (data: EditorPageData) => void;
}

const PageDataContext = createContext<PageDataContextType | undefined>(undefined);

export function PageDataProvider({ children }: { children: React.ReactNode }) {
  const [editorData, setEditorData] = useState<EditorPageData | null>(null);

  return (
    <PageDataContext.Provider value={{ editorData, setEditorData }}>
      {children}
    </PageDataContext.Provider>
  );
}

export function usePageData() {
  const context = useContext(PageDataContext);
  if (!context) {
    throw new Error('usePageData must be used within a PageDataProvider');
  }
  return context;
}

================
File: lib/types/admins.ts
================
// lib/types/admin.ts

// Base Admin type for database
export interface Admin {
    _id?: string;
    username: string;
    passwordHash: string;
    salt: string;
    isSuperAdmin: boolean;
    createdAt: Date;
    lastLogin?: Date;
    isLocked: boolean;
    lockReason?: string;
    accessToken?: string;
    tokenExpiry?: Date;
    failedLoginAttempts: number;
    lastLoginAttempt: Date;
  }
  
  // Admin info returned to frontend
  export interface AdminInfo {
    username: string;
    isSuperAdmin: boolean;
    createdAt: Date;
    lastLogin?: Date;
    isLocked: boolean;
    lockReason?: string;
    status: 'active' | 'locked';
  }
  
  // For creating new admin
  export interface CreateAdminPayload {
    username: string;
    password: string;
    isSuperAdmin?: boolean;
  }
  
  // For resetting admin password
  export interface ResetAdminPasswordPayload {
    username: string;
    newPassword: string;
  }
  
  // Admin action types
  export type AdminActionType = 'delete' | 'reset-password' | 'view-logs' | null;
  
  // Dialog state for admin actions
  export interface AdminDialogState {
    type: AdminActionType;
    admin: AdminInfo | null;
  }
  
  // Response for admin list
  export interface AdminListResponse {
    admins: AdminInfo[];
    total: number;
  }
  
  // Admin log entry
  export interface AdminLogEntry {
    _id?: string;
    adminId: string;
    timestamp: Date;
    action: string;
    ip: string;
    userAgent: string;
    details?: AdminLogDetails;
  }
  
  // Details for admin log entries
  export interface AdminLogDetails {
    targetUser?: string;
    actionType?: string;
    changes?: AdminChangeLog;
    additionalInfo?: string;
  }
  
  // Structure for logging changes
  export interface AdminChangeLog {
    field: string;
    oldValue: string | number | boolean;
    newValue: string | number | boolean;
  }
  
  // Admin logs response
  export interface AdminLogsResponse {
    logs: AdminLogEntry[];
    pagination: {
      total: number;
      page: number;
      totalPages: number;
    };
  }
  
  // Admin statistics
  export interface AdminStats {
    totalActions: number;
    lastActive?: Date;
    managedUsers: number;
    recentActions: AdminRecentAction[];
  }
  
  export interface AdminRecentAction {
    timestamp: Date;
    action: string;
    details?: string;
  }
  
  // Error responses
  export interface AdminError {
    code: AdminErrorCode;
    message: string;
    details?: string;
  }
  
  export type AdminErrorCode = 
    | 'UNAUTHORIZED' 
    | 'NOT_FOUND' 
    | 'FORBIDDEN' 
    | 'VALIDATION_ERROR' 
    | 'INTERNAL_ERROR';
  
  // Sort configuration for admin list
  export interface AdminSortConfig {
    field: AdminSortField;
    order: SortOrder;
  }
  
  export type AdminSortField = 'username' | 'createdAt' | 'lastLogin' | 'status';
  export type SortOrder = 'asc' | 'desc';
  
  // Filter options for admin list
  export interface AdminFilters {
    search?: string;
    status?: AdminStatus;
    role?: AdminRole;
  }
  
  export type AdminStatus = 'all' | 'active' | 'locked';
  export type AdminRole = 'all' | 'admin' | 'superadmin';
  
  // Pagination parameters
  export interface AdminPaginationParams {
    page: number;
    limit: number;
    sort?: AdminSortConfig;
    filters?: AdminFilters;
  }
  
  // Admin activity types
  export enum AdminActivityType {
    USER_CREATED = 'USER_CREATED',
    USER_UPDATED = 'USER_UPDATED',
    USER_DELETED = 'USER_DELETED',
    USER_LOCKED = 'USER_LOCKED',
    USER_UNLOCKED = 'USER_UNLOCKED',
    PASSWORD_RESET = 'PASSWORD_RESET',
    LOGIN_SUCCESS = 'LOGIN_SUCCESS',
    LOGIN_FAILED = 'LOGIN_FAILED',
    LOGOUT = 'LOGOUT',
    ADMIN_CREATED = 'ADMIN_CREATED',
    ADMIN_DELETED = 'ADMIN_DELETED',
    ADMIN_PASSWORD_RESET = 'ADMIN_PASSWORD_RESET',
    PROJECT_REVIEWED = 'PROJECT_REVIEWED',
    SETTINGS_UPDATED = 'SETTINGS_UPDATED'
  }
  
  // Admin session info
  export interface AdminSession {
    id: string;
    adminId: string;
    ip: string;
    userAgent: string;
    createdAt: Date;
    expiresAt: Date;
    lastActive: Date;
    isActive: boolean;
  }
  
  // Response for admin operations
  export interface AdminActionResponse<T> {
    success: boolean;
    message: string;
    data?: T;
    error?: AdminError;
  }

================
File: lib/types/annotations.ts
================
// lib/types/annotations.ts

export interface Annotation {
  id: string;
  class: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface AnnotationState {
  annotations: Annotation[];
  isAnnotated: boolean;
}

export interface AnnotationResponse {
  success: boolean;
  data?: AnnotationState;
  error?: string;
}

export interface ClassesResponse {
  success: boolean;
  data?: {
    classes: string[];
    isOfficeUser: boolean;
  };
  error?: string;
}

export interface PhotoViewerProps {
  currentImageId: string;
  annotationState: AnnotationState;
  availableClasses: string[];
  isOfficeUser: boolean;
  onSave: (annotations: Annotation[], customClass?: string) => Promise<void>;
  onNext: () => void;
  onPrevious: () => void;
  hasPrevious: boolean;
  hasNext: boolean;
}

================
File: lib/types/auth.ts
================
// lib/types/auth.ts

export enum UserRole {
  USER = "user",
  ADMIN = "admin",
}

export interface DeviceInfo {
  platform: string;
  screenResolution: string;
  language: string;
  timezone: string;
}

export interface AuthResponse {
  token: string;
  expiry: string;
  role: UserRole;
  redirectTo: string;
  deviceChanged?: boolean;
}

export interface UserInfo {
  username: string;
  role: UserRole;
  deviceInfo?: {
    fingerprint: string;
    userAgent: string;
    lastSeen: string;
  };
  isLocked?: boolean;
  lockReason?: string;
  isSuperAdmin?: boolean;
  isOfficeUser?: boolean;
}

export interface LoginCredentials {
  username: string;
  password: string;
  deviceInfo: DeviceInfo;
}

// For server-side auth state
export interface AuthState {
  isAuthenticated: boolean;
  user: UserInfo | null;
  token: string | null;
}

================
File: lib/types/editor.ts
================
// lib/types/editor.ts
export interface Annotation {
  id: string;
  class: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface Point {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}

export interface ImageState extends Size {
  scale: number;
  position: Point;
}

export interface DragState {
  isDragging: boolean;
  isDraggingAnnotation: boolean;
  dragStart: Point;
  dragOffset: Point;
  resizingSide: ResizeHandle;
}

export interface EditorState {
  isLocked: boolean;
  isDrawing: boolean;
}

export type AutosaveStatus = "saved" | "saving" | "unsaved" | "not_available";

export type ResizeHandle = 
  | "tl" | "tr" | "bl" | "br"  // corners
  | "t" | "r" | "b" | "l"      // sides
  | null;

export interface ResizeOperation {
  annotation: Annotation;
  handle: ResizeHandle;
  point: Point;
  imageSize: Size;
}

export interface PhotoViewerProps {
  currentImageId: string;
  annotationState: {
    annotations: Annotation[];
    isAnnotated: boolean;
  };
  availableClasses: string[];
  isOfficeUser: boolean;
  imageUrl: string;
  onSave: (annotations: Annotation[]) => Promise<void>;
  onNext: () => void;
  onPrevious: () => void;
  onBack: () => void;
  hasPrevious: boolean;
  hasNext: boolean;
  currentIndex: number;
  totalImages: number;
  reviewMode?: boolean; // Add this new prop
  isAdmin?: boolean; // Add this prop to indicate admin mode
  projectId?: string; // Add this to the props
}

export interface AnnotationProps {
  annotation: Annotation;
  isSelected: boolean;
  isDrawing?: boolean;
  onDelete?: () => void;
}

export interface ImageMoverProps {
  isLocked: boolean;
  zoomPercentage: number;
  onZoomIn: () => void;
  onZoomOut: () => void;
  onReset: () => void;
  onLockToggle: () => void;
}

export interface AnnotationToolbarProps {
  isDrawing: boolean;
  onBoundingBoxCreateMode: () => void;
  onDeleteAll: () => void;
  onSave: () => void;
}

export interface ClassAssignmentDialogProps {
  isOpen: boolean;
  onClose: () => void;
  onAssign: (className: string) => void;
  availableClasses: string[];
}

export interface AutosaveIndicatorProps {
  status: AutosaveStatus;
}

// Type Guard Functions
export const isCornerHandle = (handle: ResizeHandle): handle is "tl" | "tr" | "bl" | "br" => {
  return handle === "tl" || handle === "tr" || handle === "bl" || handle === "br";
};

export const isSideHandle = (handle: ResizeHandle): handle is "t" | "r" | "b" | "l" => {
  return handle === "t" || handle === "r" || handle === "b" || handle === "l";
};

export const isValidResizeHandle = (handle: string | null): handle is ResizeHandle => {
  return isCornerHandle(handle as ResizeHandle) || isSideHandle(handle as ResizeHandle) || handle === null;
};

================
File: lib/types/logs.ts
================
export enum SecurityLogType {
  // Authentication events
  LOGIN_SUCCESS = "LOGIN_SUCCESS",
  LOGIN_FAILED = "LOGIN_FAILED",
  LOGIN_ATTEMPT_LOCKED = "LOGIN_ATTEMPT_LOCKED",
  ADMIN_LOGIN = "ADMIN_LOGIN",
  USER_LOGOUT = "USER_LOGOUT",

  // Account events
  ACCOUNT_LOCKED = "ACCOUNT_LOCKED",
  ACCOUNT_UNLOCKED = "ACCOUNT_UNLOCKED",
  PASSWORD_RESET = "PASSWORD_RESET",
  ADMIN_PASSWORD_RESET = "ADMIN_PASSWORD_RESET", // Added
  ADMIN_REVOKED = "ADMIN_REVOKED", // Added
  USER_DELETED = 'USER_DELETED',
  ADMIN_DELETED = 'ADMIN_DELETED',
  PROJECT_SUBMITTED = 'PROJECT_SUBMITTED',
  PROJECT_UNMARKED = 'PROJECT_UNMARKED',
  USER_UPDATED = 'USER_UPDATED',  // Add this

  // Security events
  DEVICE_CHANGE = "DEVICE_CHANGE",
  DEVICE_MISMATCH = "DEVICE_MISMATCH",
  SUSPICIOUS_ACTIVITY = "SUSPICIOUS_ACTIVITY",
  RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED",

  // Client security events
  INSPECT_ELEMENT = "INSPECT_ELEMENT",
  SCREENSHOT_ATTEMPT = "SCREENSHOT_ATTEMPT",
  SCREEN_RECORD_ATTEMPT = "SCREEN_RECORD_ATTEMPT",
  KEYBOARD_SHORTCUT = "KEYBOARD_SHORTCUT",

  // System events
  USER_CREATED = "USER_CREATED",
  ADMIN_CREATED = "ADMIN_CREATED",
  UNAUTHORIZED_ACCESS = "UNAUTHORIZED_ACCESS",
}

export interface SecurityLog {
  _id?: string;
  userId: string;
  timestamp: Date;
  logType: SecurityLogType;
  details: {
    userAgent: string;
    ip: string;
    path?: string;
    keyPressed?: string;
    requestCount?: number;
    deviceInfo?: string;
    additionalInfo?: string;
  };
}

export interface LogEntry {
  logType: SecurityLogType;
  timestamp: Date;
  details: string;
}

export interface LogFile {
  logs: LogEntry[];
}

================
File: lib/types/project-detail.ts
================
// types/project-detail.ts

export type FilterType = "all" | "annotated" | "unannotated";

export interface Annotation {
  class: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface ImageMetadata {
  id: string;
  originalName: string;
  url: string;
  lastModified: string;
  isAnnotated: boolean;
  annotations: Annotation[];
}

export interface PaginationInfo {
  total: number;
  currentPage: number;
  totalPages: number;
  nextCursor?: string;
  prevCursor?: string;
  limit: number;
  annotatedTotal: number;
  annotationRemaining: number;
}

// In lib/types/project-detail.ts
export interface PaginatedImagesResponse {
  items: ImageMetadata[];
  pagination: PaginationInfo;
  isSubmitted: boolean;
  submittedAt?: string;
}

export interface PaginationParams {
  cursor?: string;
  limit?: number;
  filter?: FilterType;
}

export interface StatsProps {
  total: number;
  annotatedTotal: number;
  annotationRemaining: number;
}

================
File: lib/types/project.ts
================
// lib/types/project.ts

export enum ProjectStatus {
  DRAFT = "draft",
  ACTIVE = "active",
  COMPLETED = "completed",
  ARCHIVED = "archived",
}

export enum AnnotationFormat {
  YOLO = "yolo",
  COCO = "coco",
  PASCAL_VOC = "pascal_voc",
}

export interface ProjectSettings {
  allowCustomClasses: boolean;
  requireReview: boolean;
  autoDistribute: boolean;
  modelFormat: AnnotationFormat;
}

export interface ProjectMember {
  userId: string;
  allocationPercentage: number;
  assignedImages: string[];
  completedImages: string[];
  lastActivity?: Date;
  timeSpent: number;
}

export interface ProjectStats {
  assignedImages: number;
  completedImages: number;
  approvedImages: number;
  totalAnnotations: number;
  lastActivity: Date;
}

export interface Project {
  id: string;
  name: string;
  description?: string;
  status: ProjectStatus;
  createdAt: Date;
  createdBy: string;
  settings: ProjectSettings;
  classes: string[];
  totalImages: number;
  stats: ProjectStats;
  members: ProjectMember[];
}

export interface AssignedProject {
  id: string;
  name: string;
  description?: string;
  status: ProjectStatus;
  allocationPercentage: number;
  stats: {
    assigned: number;
    completed: number;
    timeSpent: number;
  };
  lastActivity: Date;
  modelFormat: AnnotationFormat;
  totalImages: number;
  projectStats: {
    assignedImages: number;
    completedImages: number;
    approvedImages: number;
  };
}

export interface ImageAssignment {
  imageId: string;
  assignedTo: string;
  assignedAt: Date;
  status:
    | "pending"
    | "in_progress"
    | "completed"
    | "review_pending"
    | "changes_requested";
  metadata: {
    originalName: string;
    size: number;
    dimensions: {
      width: number;
      height: number;
    };
  };
  review?: {
    reviewedBy?: string;
    reviewedAt?: Date;
    status: "approved" | "changes_requested";
    feedback?: string;
  };
}

================
File: lib/types/projects.ts
================
// lib/types/projects.ts
export interface Project {
  id: string;
  name: string;
  totalImages: number;
  annotatedImages: number;
  remainingImages: number;
  isSubmitted: boolean;
  submittedAt?: string;
}

export interface ProjectsResponse {
  projects: Project[];
}

export interface Annotation {
  class: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface ImageMetadata {
  id: string;
  originalName: string;
  url: string;
  lastModified: Date;
  isAnnotated: boolean;
  annotations: Annotation[];
}

export interface PaginatedResponse<T> {
  items: T[];
  pagination: {
    total: number;
    currentPage: number;
    totalPages: number;
    nextCursor?: string;
    prevCursor?: string;
    limit: number;
    annotatedTotal: number;
    annotationRemaining: number;
  };
}

================
File: lib/types/users.ts
================
export type SortField = "username" | "lastLogin" | "createdAt";
export type SortOrder = "asc" | "desc";
export type UserStatus = "all" | "active" | "locked";

export interface ActivityLogEntry {
  timestamp: Date;
  action: string;
  ip: string;
  userAgent: string;
  endpoint: string;
  responseTime: number;
}

export interface Project {
  id: string;
  name: string;
  totalImages?: number;
  annotatedImages?: number;
  remainingImages?: number;
}

export interface UserInfo {
  _id: string;
  username: string;
  isLocked: boolean;
  lockReason?: string;
  lastLoginAttempt: Date;
  isOfficeUser: boolean;  // Add this field
  failedLoginAttempts: number;
  activeDevice?: {
    lastSeen: Date;
    ip: string;
    userAgent: string;
    deviceInfo?: string;
  };
  rateLimit: {
    count: number;
    resetAt: Date;
  };
  activityLog: ActivityLogEntry[];
}

export interface SortConfig {
  field: SortField;
  order: SortOrder;
}

export interface DialogState {
  type:
    | "reset-password"
    | "lock"
    | "unlock"
    | "delete-user"
    | "delete-admin"
    | "create-project"
    | "rename-project"
    | null;
  user: UserInfo | null;
  project?: Project | null;
  reason?: string;
}

export type PanelType = "logs" | "projects" | null;

export interface PanelState {
  type: PanelType;
  user: UserInfo | null;
}

export interface DeviceInfoType {
  lastSeen: Date;
  ip: string;
  userAgent: string;
  deviceInfo?: string;
}

export type DialogType =
  | "reset-password"
  | "lock"
  | "unlock"
  | "delete-user"
  | "delete-admin"
  | "create-project"
  | "rename-project"
  | null;

export interface DialogState {
  type: DialogType;
  user: UserInfo | null;
  project?: Project | null;
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: lib/utils/color.ts
================
// utils/colors.ts
const boldColors = [
    '#FF3B30', // Red
    '#FF9500', // Orange
    '#FFCC00', // Yellow
    '#34C759', // Green
    '#5856D6', // Purple
    '#FF2D55', // Pink
    '#5AC8FA', // Light Blue
    '#007AFF', // Blue
    '#4CD964', // Lime
    '#FF3B30', // Coral
    '#E91E63', // Pink
    '#9C27B0', // Purple
    '#673AB7', // Deep Purple
    '#3F51B5', // Indigo
    '#2196F3', // Blue
    '#03A9F4', // Light Blue
    '#00BCD4', // Cyan
    '#009688', // Teal
    '#4CAF50', // Green
    '#8BC34A', // Light Green
    '#CDDC39', // Lime
    '#FFC107', // Amber
    '#FF9800', // Orange
    '#FF5722', // Deep Orange
  ];
  
  // Map to store annotation ID to color mapping
  const annotationColors = new Map<string, string>();
  
  export const getAnnotationColor = (id: string): string => {
    if (!annotationColors.has(id)) {
      // Get a random color from the boldColors array
      const randomColor = boldColors[Math.floor(Math.random() * boldColors.length)];
      annotationColors.set(id, randomColor);
    }
    return annotationColors.get(id)!;
  };
  
  export const clearAnnotationColors = () => {
    annotationColors.clear();
  };

================
File: lib/utils/validation.ts
================
// utils/validation.ts

import type { Annotation } from '@/lib/types/annotations';

export function isValidAnnotation(obj: unknown): obj is Annotation {
  if (!obj || typeof obj !== 'object') return false;

  const annotation = obj as Record<string, unknown>;

  return (
    typeof annotation.id === 'string' &&
    typeof annotation.class === 'string' &&
    typeof annotation.x === 'number' &&
    typeof annotation.y === 'number' &&
    typeof annotation.width === 'number' &&
    typeof annotation.height === 'number' &&
    annotation.x >= 0 &&
    annotation.y >= 0 &&
    annotation.width > 0 &&
    annotation.height > 0
  );
}

export function isValidClass(className: string, availableClasses: string[]): boolean {
  return (
    typeof className === 'string' &&
    className.length > 0 &&
    availableClasses.includes(className)
  );
}

export function validateAnnotations(
  annotations: unknown[],
  availableClasses: string[]
): annotations is Annotation[] {
  return annotations.every(
    ann => 
      isValidAnnotation(ann) && 
      (!ann.class || isValidClass(ann.class, availableClasses))
  );
}

================
File: middleware.ts
================
// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { UserRole } from './lib/types/auth'

// Paths that don't require authentication
const publicPaths = ['/login']

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl
  
  // Allow public paths
  if (publicPaths.includes(pathname)) {
    return NextResponse.next()
  }

  // Get auth token from request cookies
  const cookieStore = request.cookies
  const token = cookieStore.get('auth_token')?.value

  if (!token) {
    // Redirect to login if no token
    return NextResponse.redirect(new URL('/login', request.url))
  }

  // Verify token and get user info
  try {
    const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/auth/verify`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        // Pass the original user agent from the request
        'User-Agent': request.headers.get('user-agent') || 'unknown',
      },
      body: JSON.stringify({
        deviceInfo: {
          platform: request.headers.get('sec-ch-ua-platform') || 'unknown',
          screenResolution: 'unknown',
          language: request.headers.get('accept-language') || 'unknown',
          timezone: 'unknown'
        }
      })
    })

    if (!res.ok) {
      // Token is invalid, redirect to login
      const response = NextResponse.redirect(new URL('/login', request.url))
      response.cookies.delete('auth_token')
      return response
    }

    const data = await res.json()

    // Check role-based access
    if (pathname.startsWith('/admin') && data.role !== UserRole.ADMIN) {
      // Non-admin trying to access admin routes
      return NextResponse.redirect(new URL('/dashboard', request.url))
    }

    if (pathname.startsWith('/dashboard') && data.role === UserRole.ADMIN) {
      // Admin trying to access user routes
      return NextResponse.redirect(new URL('/admin', request.url))
    }

    // All checks passed
    return NextResponse.next()
  } catch {
    // Error verifying token, redirect to login
    const response = NextResponse.redirect(new URL('/login', request.url))
    response.cookies.delete('auth_token')
    return response
  }
}

export const config = {
  // Paths to run the middleware on
  matcher: [
    /*
     * Match all paths except:
     * 1. /api (API routes)
     * 2. /_next (Next.js internals)
     * 3. /_static (inside /public)
     * 4. /_vercel (Vercel internals)
     * 5. /favicon.ico, /sitemap.xml (static files)
     */
    '/((?!api|_next|_static|_vercel|favicon.ico|sitemap.xml).*)',
  ],
}

================================================================
End of Codebase
================================================================

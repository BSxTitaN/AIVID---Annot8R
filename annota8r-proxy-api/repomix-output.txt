This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
package.json
README.md
scripts/create-super-admin.js
src/config/aws.ts
src/config/env.ts
src/config/mongo.ts
src/index.ts
src/middleware/auth.middleware.ts
src/middleware/cors.ts
src/routes/admin.routes.ts
src/routes/annotation.routes.ts
src/routes/auth.routes.ts
src/routes/image.routes.ts
src/routes/index.ts
src/routes/log.routes.ts
src/routes/project.routes.ts
src/routes/user.routes.ts
src/services/auth.service.ts
src/services/crypto.service.ts
src/services/device.service.ts
src/services/log.service.ts
src/services/project.service.ts
src/services/s3.service.ts
src/services/scraping-detection.service.ts
src/services/slug.service.ts
src/services/token.service.ts
src/types/auth.types.ts
src/types/log.types.ts
src/types/project.types.ts
tsconfig.json

================================================================
Files
================================================================

================
File: .gitignore
================
# dev
.yarn/
!.yarn/releases
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf

# deps
node_modules/

# env
.env
.env.production

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store

.codegpt

================
File: scripts/create-super-admin.js
================
// scripts/create-super-admin.js
import { MongoClient } from 'mongodb';
import { config } from 'dotenv';
import { createHash, randomBytes } from 'crypto';
import { pbkdf2 } from 'crypto';
import { promisify } from 'util';

config();

const pbkdf2Async = promisify(pbkdf2);

async function hashPassword(password) {
  const salt = randomBytes(32).toString('hex');
  const hash = await pbkdf2Async(
    password,
    salt,
    600000, // iterations
    64,     // keylen
    'sha512'
  );
  return { hash: hash.toString('hex'), salt };
}

async function createSuperAdmin() {
  const client = new MongoClient(process.env.MONGODB_URI);
  try {
    await client.connect();
    console.log('Connected to MongoDB');

    const db = client.db('annot8r');
    const admins = db.collection('admins');

    // Check if super admin already exists
    const existingSuperAdmin = await admins.findOne({ isSuperAdmin: true });
    if (existingSuperAdmin) {
      console.error('Super admin already exists!');
      return;
    }

    // Generate password and hash it
    const password = `ak_${randomBytes(32).toString('base64url')}`;
    const { hash: passwordHash, salt } = await hashPassword(password);

    // Create super admin
    await admins.insertOne({
      username: 'superadmin',
      passwordHash,
      salt,
      isSuperAdmin: true,
      createdAt: new Date(),
      isLocked: false,
      failedLoginAttempts: 0,
      lastLoginAttempt: new Date()
    });

    console.log('\n========== SUPER ADMIN CREATED SUCCESSFULLY ==========');
    console.log('Username: superadmin');
    console.log('Password:', password);
    console.log('IMPORTANT: Save this password securely. It cannot be recovered later!');
    console.log('===============================================\n');
  } catch (error) {
    console.error('Error creating super admin:', error);
  } finally {
    await client.close();
  }
}

createSuperAdmin().catch(console.error);

================
File: src/config/aws.ts
================
// src/config/aws.ts
import { S3Client } from '@aws-sdk/client-s3'
import { env } from './env.js'

export const s3Client = new S3Client({
  region: env.AWS_REGION,
  credentials: {
    accessKeyId: env.AWS_ACCESS_KEY_ID,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY
  }
})

export const BUCKET_NAME = env.S3_BUCKET_NAME

================
File: src/config/env.ts
================
// src/config/env.ts
import { config } from "dotenv";
import * as path from "path";

// Load .env file
config({ path: path.resolve(process.cwd(), ".env") });

export interface RequiredEnv {
  AWS_REGION: string;
  AWS_ACCESS_KEY_ID: string;
  AWS_SECRET_ACCESS_KEY: string;
  S3_BUCKET_NAME: string;
  PORT: number;
  MONGODB_URI: string;
}

export function validateEnv(): RequiredEnv {
  const required = [
    "AWS_REGION",
    "AWS_ACCESS_KEY_ID",
    "AWS_SECRET_ACCESS_KEY",
    "S3_BUCKET_NAME",
    "MONGODB_URI",
  ] as const;

  for (const key of required) {
    if (!process.env[key]) {
      throw new Error(`Missing required environment variable: ${key}`);
    }
  }

  return {
    AWS_REGION: process.env.AWS_REGION!,
    AWS_ACCESS_KEY_ID: process.env.AWS_ACCESS_KEY_ID!,
    AWS_SECRET_ACCESS_KEY: process.env.AWS_SECRET_ACCESS_KEY!,
    S3_BUCKET_NAME: process.env.S3_BUCKET_NAME!,
    PORT: parseInt(process.env.PORT || "3001", 10),
    MONGODB_URI: process.env.MONGODB_URI!,
  };
}

export const env = validateEnv();

================
File: src/config/mongo.ts
================
// src/config/mongo.ts
import { MongoClient } from 'mongodb';
import { env } from './env.js';
import type { Admin, WebUser } from '../types/auth.types.js';
import type { SecurityLog } from '../types/log.types.js';
import type { ImageAssignment, Project } from '../types/project.types.js';

const client = new MongoClient(env.MONGODB_URI);

try {
  await client.connect();
  console.log('Successfully connected to MongoDB');
  
  const adminCount = await client.db('annot8r').collection('admins').countDocuments();
  console.log('Number of admins in database:', adminCount);
} catch (error) {
  console.error('MongoDB connection error:', error);
}

export const db = client.db('annot8r');
export const WebUsers = db.collection<WebUser>('web_users');
export const Admins = db.collection<Admin>('admins');
export const SecurityLogs = db.collection<SecurityLog>('security_logs');
export const Projects = db.collection<Project>('projects');
export const ImageAssignments = db.collection<ImageAssignment>('image_assignments');

================
File: src/index.ts
================
// src/index.ts
import { serve } from '@hono/node-server'
import { Hono } from 'hono'
import { corsMiddleware } from './middleware/cors.js'
import { routes } from './routes/index.js'
import { env } from './config/env.js'

const app = new Hono()

// Add CORS middleware
app.use('/*', corsMiddleware)

// Add routes
app.route('/', routes)

// Log configuration
console.log('Configuration:')
console.log(`- PORT: ${env.PORT}`)
console.log(`- AWS_REGION: ${env.AWS_REGION}`)
console.log(`- S3_BUCKET_NAME: ${env.S3_BUCKET_NAME}`)
console.log('- AWS credentials are configured')

// Start the server
console.log(`Server is running on port ${env.PORT}`)

serve({
  fetch: app.fetch,
  port: env.PORT
})

================
File: src/middleware/auth.middleware.ts
================
// src/middleware/auth.middleware.ts
import type { Next } from 'hono';
import { WebUsers, Admins } from '../config/mongo.js';
import { AuthService } from '../services/auth.service.js';
import { UserRole } from '../types/auth.types.js';

export async function webAuthMiddleware(c: any, next: Next) {
  const startTime = Date.now();
  const token = c.req.header('Authorization')?.replace('Bearer ', '');
  const userAgent = c.req.header('user-agent') || 'unknown';
  const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown';
  const endpoint = c.req.path;
  
  console.log('Auth middleware check:', {
    token: token ? 'provided' : 'missing',
    userAgent,
    endpoint,
  });
  
  if (!token) {
    return c.json({ error: 'Unauthorized - No token provided' }, 401);
  }

  // First check web users
  const webUser = await WebUsers.findOne({ accessToken: token });
  if (webUser) {
    const isValid = await AuthService.verifyRequest(token, ip, userAgent, endpoint, startTime);
    if (!isValid) {
      return c.json({ error: 'Unauthorized - Invalid token or device mismatch' }, 401);
    }

    c.set("user", webUser);
  } else {
    // Check if it's an admin token
    const admin = await Admins.findOne({ accessToken: token });
    if (!admin) {
      return c.json({ error: 'Unauthorized - Invalid token' }, 401);
    }

    // For admins, just verify token expiry
    if (!admin.tokenExpiry || new Date() > admin.tokenExpiry) {
      return c.json({ error: 'Unauthorized - Token expired' }, 401);
    }

    c.set("adminUser", admin);
  }
  
  await next();
}

export async function adminAuthMiddleware(c: any, next: Next) {
  const token = c.req.header('Authorization')?.replace('Bearer ', '');
  if (!token) {
    return c.json({ error: 'Unauthorized - No token provided' }, 401);
  }

  const admin = await Admins.findOne({ accessToken: token });
  if (!admin || !admin.tokenExpiry || new Date() > admin.tokenExpiry) {
    return c.json({ error: 'Unauthorized - Invalid or expired token' }, 401);
  }

  c.set("adminUser", admin);

  await next();
}

// Helper to get user info from token
export async function getUserFromToken(token: string): Promise<{
  username: string;
  role: UserRole;
  deviceInfo?: any;
} | null> {
  // Check web users first
  const webUser = await WebUsers.findOne({ accessToken: token });
  if (webUser) {
    return {
      username: webUser.username,
      role: UserRole.USER,
      deviceInfo: webUser.activeDevice
    };
  }

  // Check admins
  const admin = await Admins.findOne({ accessToken: token });
  if (admin) {
    return {
      username: admin.username,
      role: UserRole.ADMIN
    };
  }

  return null;
}

================
File: src/middleware/cors.ts
================
// src/middleware/cors.ts
import { cors } from 'hono/cors'

export const corsMiddleware = cors({
  origin: ['http://localhost:3000', 'http://127.0.0.1:3000', 'http://localhost:3001'],
  allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'], // Update to include all methods
  allowHeaders: ['Content-Type', 'Authorization', 'Accept', 'Origin'],
  exposeHeaders: ['WWW-Authenticate', 'Server-Authorization'],
  credentials: true,
  maxAge: 86400,
})

================
File: src/routes/admin.routes.ts
================
// src/routes/admin.routes.ts
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import { Admins } from "../config/mongo.js";
import { SecurityLogService } from "../services/log.service.js";
import { SecurityLogType } from "../types/log.types.js";
import { AuthService } from "../services/auth.service.js";
import { adminAuthMiddleware } from "../middleware/auth.middleware.js";
import type { Admin, WebUser } from "../types/auth.types.js";

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const createAdminSchema = z.object({
  username: z.string().min(3),
  password: z.string().min(8),
});

const resetPasswordSchema = z.object({
  username: z.string(),
  newPassword: z.string().min(8),
});

// Protect all routes with admin authentication
app.use("/*", adminAuthMiddleware);

// List all admins
app.get("/", async (c) => {
  try {
    const adminUser = c.get("adminUser");

    // Only super admins can list all admins
    if (!adminUser.isSuperAdmin) {
      return c.json({ error: "Only super admins can access admin list" }, 403);
    }

    const admins = await Admins.find({}).toArray();

    // Filter sensitive information
    const filteredAdmins = admins.map((admin) => ({
      username: admin.username,
      isSuperAdmin: admin.isSuperAdmin,
      createdAt: admin.createdAt,
      lastLogin: admin.lastLogin,
      isLocked: admin.isLocked,
      lockReason: admin.lockReason,
    }));

    return c.json({ admins: filteredAdmins });
  } catch (error) {
    console.error("Error fetching admins:", error);
    return c.json({ error: "Failed to fetch admins" }, 500);
  }
});

// Create new admin (super admin only)
app.post("/", zValidator("json", createAdminSchema), async (c) => {
  try {
    const adminUser = c.get("adminUser");

    // Only super admins can create new admins
    if (!adminUser.isSuperAdmin) {
      return c.json({ error: "Only super admins can create new admins" }, 403);
    }

    const { username, password } = await c.req.json();
    const success = await AuthService.createAdmin(username, password);

    if (!success) {
      return c.json({ error: "Admin username already exists" }, 409);
    }

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.ADMIN_CREATED,
      {
        userAgent: c.req.header("user-agent") || "unknown",
        ip:
          c.req.header("x-forwarded-for") ||
          c.req.header("x-real-ip") ||
          "unknown",
        path: c.req.path,
        additionalInfo: `Created admin: ${username}`,
      }
    );

    return c.json({ success: true });
  } catch (error) {
    console.error("Admin creation error:", error);
    return c.json({ error: "Failed to create admin" }, 500);
  }
});

// Delete admin (super admin only)
app.delete("/:adminId", async (c) => {
  try {
    const adminUser = c.get("adminUser");
    const username = c.req.param("adminId");

    // Only super admins can delete admins
    if (!adminUser.isSuperAdmin) {
      return c.json({ error: "Only super admins can delete admins" }, 403);
    }

    // Cannot delete self
    if (adminUser.username === username) {
      return c.json({ error: "Cannot delete your own admin account" }, 400);
    }

    const success = await AuthService.deleteAdmin(username, adminUser.username);
    if (!success) {
      return c.json(
        { error: "Failed to delete admin or admin not found" },
        404
      );
    }

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.ADMIN_DELETED,
      {
        userAgent: c.req.header("user-agent") || "unknown",
        ip:
          c.req.header("x-forwarded-for") ||
          c.req.header("x-real-ip") ||
          "unknown",
        path: c.req.path,
        additionalInfo: `Deleted admin: ${username}`,
      }
    );

    return c.json({ success: true });
  } catch (error) {
    console.error("Error deleting admin:", error);
    return c.json({ error: "Failed to delete admin" }, 500);
  }
});

// Reset admin password (super admin only)
app.put(
  "/:adminId/password",
  zValidator("json", resetPasswordSchema),
  async (c) => {
    try {
      const adminUser = c.get("adminUser");
      const username = c.req.param("adminId");
      const { newPassword } = await c.req.json();

      // Only super admins can reset admin passwords
      if (!adminUser.isSuperAdmin) {
        return c.json(
          { error: "Only super admins can reset admin passwords" },
          403
        );
      }

      const success = await AuthService.resetAdminPassword(
        username,
        newPassword
      );
      if (!success) {
        return c.json(
          { error: "Failed to reset password or admin not found" },
          404
        );
      }

      await SecurityLogService.logSecurityEvent(
        adminUser.username,
        SecurityLogType.ADMIN_PASSWORD_RESET,
        {
          userAgent: c.req.header("user-agent") || "unknown",
          ip:
            c.req.header("x-forwarded-for") ||
            c.req.header("x-real-ip") ||
            "unknown",
          path: c.req.path,
          additionalInfo: `Reset password for admin: ${username}`,
        }
      );

      return c.json({ success: true });
    } catch (error) {
      console.error("Error resetting admin password:", error);
      return c.json({ error: "Failed to reset admin password" }, 500);
    }
  }
);

// Get admin logs (super admin only)
app.get("/:adminId/logs", async (c) => {
  try {
    const adminUser = c.get("adminUser");
    const username = c.req.param("adminId");

    // Only super admins can view admin logs
    if (!adminUser.isSuperAdmin) {
      return c.json({ error: "Only super admins can view admin logs" }, 403);
    }

    const { page = "1", limit = "20" } = c.req.query();

    const logs = await SecurityLogService.getSecurityLogs({
      userId: username,
      page: parseInt(page),
      limit: parseInt(limit),
      logType: [
        SecurityLogType.ADMIN_LOGIN,
        SecurityLogType.ADMIN_CREATED,
        SecurityLogType.ADMIN_DELETED,
        SecurityLogType.ADMIN_PASSWORD_RESET,
        SecurityLogType.ADMIN_REVOKED,
        SecurityLogType.USER_CREATED,
        SecurityLogType.USER_UPDATED,
        SecurityLogType.USER_DELETED,
        SecurityLogType.ACCOUNT_LOCKED,
        SecurityLogType.ACCOUNT_UNLOCKED,
      ],
    });

    return c.json(logs);
  } catch (error) {
    console.error("Error fetching admin logs:", error);
    return c.json({ error: "Failed to fetch admin logs" }, 500);
  }
});

export { app as adminRoutes };

================
File: src/routes/annotation.routes.ts
================
// src/routes/annotation.routes.ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { adminAuthMiddleware, webAuthMiddleware } from '../middleware/auth.middleware.js';
import { ProjectService } from '../services/project.service.js';
import { S3Service } from '../services/s3.service.js';
import { SecurityLogService } from '../services/log.service.js';
import { SecurityLogType } from '../types/log.types.js';
import type { Admin, WebUser } from '../types/auth.types.js';

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const annotationSchema = z.object({
  class: z.string(),
  x: z.number().min(0),
  y: z.number().min(0),
  width: z.number().min(0),
  height: z.number().min(0)
});

const updateAnnotationsSchema = z.object({
  annotations: z.array(annotationSchema),
  customClass: z.string().optional()
});

const reviewSchema = z.object({
  status: z.enum(['approved', 'changes_requested']),
  feedback: z.string().optional()
});

// Get Image Annotations
app.get('/projects/:projectId/images/:imageId/annotations', webAuthMiddleware, async (c) => {
  try {
    const { projectId, imageId } = c.req.param();
    const user = c.get('user');

    // Verify user has access to this project's images
    const assignments = await ProjectService.getMemberAssignments(projectId, user.username, 1, 1);
    if (assignments.total === 0) {
      return c.json({ success: false, error: 'Not authorized to access this project' }, 403);
    }

    const annotations = await S3Service.getImageAnnotations(projectId, imageId);
    return c.json({ success: true, annotations });
  } catch (error) {
    console.error('Error getting annotations:', error);
    return c.json({ success: false, error: 'Failed to get annotations' }, 500);
  }
});

// Update Image Annotations
app.post('/projects/:projectId/images/:imageId/annotations', 
  webAuthMiddleware,
  zValidator('json', updateAnnotationsSchema),
  async (c) => {
    try {
      const { projectId, imageId } = c.req.param();
      const user = c.get('user');
      const { annotations, customClass } = await c.req.json();

      // Verify user has access and image is assigned to them
      const assignments = await ProjectService.getMemberAssignments(projectId, user.username, 1, 1);
      if (assignments.total === 0) {
        return c.json({ success: false, error: 'Not authorized to access this project' }, 403);
      }

      // Save annotations
      const success = await S3Service.saveImageAnnotations(projectId, imageId, annotations);
      if (!success) {
        return c.json({ success: false, error: 'Failed to save annotations' }, 500);
      }

      // If custom class provided and allowed, add it
      if (customClass) {
        const existingClasses = await S3Service.getClasses(projectId);
        if (!existingClasses.includes(customClass)) {
          await S3Service.saveClasses(projectId, [...existingClasses, customClass]);
        }
      }

      // Log annotation update
      await SecurityLogService.logSecurityEvent(
        user.username,
        SecurityLogType.ANNOTATION_UPDATED,
        {
          userAgent: c.req.header('user-agent') || 'unknown',
          ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
          path: c.req.path,
          additionalInfo: `Updated annotations for image: ${imageId}`
        }
      );

      return c.json({ success: true });
    } catch (error) {
      console.error('Error updating annotations:', error);
      return c.json({ success: false, error: 'Failed to update annotations' }, 500);
    }
});

// Review Annotations (Admin Only)
app.post('/projects/:projectId/images/:imageId/review',
  adminAuthMiddleware,
  zValidator('json', reviewSchema),
  async (c) => {
    try {
      const { projectId, imageId } = c.req.param();
      const adminUser = c.get('adminUser');
      const { status, feedback } = await c.req.json();

      // Update review status
      const success = await ProjectService.updateAnnotationReview(
        projectId,
        imageId,
        adminUser.username,
        status,
        feedback
      );

      if (!success) {
        return c.json({ success: false, error: 'Failed to update review status' }, 500);
      }

      // Log review action
      await SecurityLogService.logSecurityEvent(
        adminUser.username,
        SecurityLogType.ANNOTATION_REVIEWED,
        {
          userAgent: c.req.header('user-agent') || 'unknown',
          ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
          path: c.req.path,
          additionalInfo: `Reviewed annotations for image: ${imageId} - Status: ${status}`
        }
      );

      return c.json({ success: true });
    } catch (error) {
      console.error('Error reviewing annotations:', error);
      return c.json({ success: false, error: 'Failed to review annotations' }, 500);
    }
});

// Get Project Classes
app.get('/projects/:projectId/classes', webAuthMiddleware, async (c) => {
  try {
    const { projectId } = c.req.param();
    const classes = await S3Service.getClasses(projectId);
    return c.json({ success: true, classes });
  } catch (error) {
    console.error('Error getting classes:', error);
    return c.json({ success: false, error: 'Failed to get classes' }, 500);
  }
});

// Update Project Classes (Admin Only)
app.put('/projects/:projectId/classes',
  adminAuthMiddleware,
  zValidator('json', z.object({ classes: z.array(z.string()) })),
  async (c) => {
    try {
      const { projectId } = c.req.param();
      const { classes } = await c.req.json();

      const success = await S3Service.saveClasses(projectId, classes);
      if (!success) {
        return c.json({ success: false, error: 'Failed to update classes' }, 500);
      }

      return c.json({ success: true });
    } catch (error) {
      console.error('Error updating classes:', error);
      return c.json({ success: false, error: 'Failed to update classes' }, 500);
    }
});

export { app as annotationRoutes };

================
File: src/routes/auth.routes.ts
================
// src/routes/auth.routes.ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { WebUsers } from '../config/mongo.js';
import { AuthService } from '../services/auth.service.js';
import { webAuthMiddleware } from '../middleware/auth.middleware.js';
import type { 
  Admin, 
  WebUser 
} from '../types/auth.types.js';

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const loginSchema = z.object({
  username: z.string().min(1),
  password: z.string().min(1),
  deviceInfo: z.object({
    platform: z.string(),
    screenResolution: z.string(),
    language: z.string(),
    timezone: z.string()
  }).optional()
});

// Get current user info
app.get('/me', webAuthMiddleware, async (c) => {
  try {
    const token = c.req.header('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return c.json({ error: 'No token provided' }, 401);
    }

    const userInfo = await AuthService.getUserInfo(token);
    if (!userInfo) {
      return c.json({ error: 'User not found' }, 401);
    }

    return c.json(userInfo);
  } catch (error) {
    console.error('Error fetching user info:', error);
    return c.json({ error: 'Failed to fetch user info' }, 500);
  }
});

// Login endpoint
app.post('/login', zValidator('json', loginSchema), async (c) => {
  try {
    const { username, password, deviceInfo } = await c.req.json();
    const userAgent = c.req.header('user-agent') || 'unknown';
    const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown';

    // First check web users
    const webUser = await WebUsers.findOne({ username });
    if (webUser) {
      const result = await AuthService.loginWebUser(
        username,
        password,
        ip,
        userAgent,
        JSON.stringify(deviceInfo || {})
      );

      if (!result) {
        return c.json({ error: 'Invalid credentials or account locked' }, 401);
      }

      return c.json(result);
    }

    // Then check admins
    const result = await AuthService.loginAdmin(username, password, ip, userAgent);
    if (!result) {
      return c.json({ error: 'Invalid credentials or account locked' }, 401);
    }

    return c.json(result);
  } catch (error) {
    console.error('Login error:', error);
    return c.json({ error: 'Internal server error' }, 500);
  }
});

// Verify token
app.post('/verify', async (c) => {
  try {
    const token = c.req.header('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return c.json({ error: 'No token provided' }, 401);
    }

    const userAgent = c.req.header('user-agent') || 'unknown';
    const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown';
    const deviceInfo = await c.req.json();

    const verificationResult = await AuthService.verifyToken(token, ip, userAgent, deviceInfo);
    if (!verificationResult.valid) {
      return c.json({ error: verificationResult.error }, 401);
    }

    return c.json({ 
      valid: true, 
      role: verificationResult.role 
    });
  } catch (error) {
    console.error('Verification error:', error);
    return c.json({ error: 'Failed to verify token' }, 500);
  }
});

// Refresh token
app.post('/refresh', webAuthMiddleware, async (c) => {
  try {
    const token = c.req.header('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return c.json({ error: 'No token provided' }, 401);
    }

    const refreshedToken = await AuthService.refreshToken(token);
    if (!refreshedToken) {
      return c.json({ error: 'Failed to refresh token' }, 401);
    }

    return c.json(refreshedToken);
  } catch (error) {
    console.error('Error refreshing token:', error);
    return c.json({ error: 'Failed to refresh token' }, 500);
  }
});

// Logout endpoint
app.post('/logout', webAuthMiddleware, async (c) => {
  try {
    const token = c.req.header('Authorization')?.replace('Bearer ', '');
    if (!token) {
      return c.json({ error: 'No token provided' }, 401);
    }

    const success = await AuthService.logout(token);
    if (!success) {
      return c.json({ error: 'Failed to logout' }, 500);
    }

    return c.json({ message: 'Logged out successfully' });
  } catch (error) {
    console.error('Error during logout:', error);
    return c.json({ error: 'Failed to process logout request' }, 500);
  }
});

export { app as authRoutes };

================
File: src/routes/image.routes.ts
================
// src/routes/image.routes.ts
import { Hono } from 'hono';
import { S3Service } from '../services/s3.service.js';
import { TokenService } from '../services/token.service.js';
import { webAuthMiddleware, adminAuthMiddleware } from '../middleware/auth.middleware.js';
import type { Admin, WebUser } from '../types/auth.types.js';

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Get image by token (proxied image access)
app.get('/:token', webAuthMiddleware, async (c) => {
  const imageToken = c.req.param('token');
  
  try {
    const tokenData = TokenService.verifyToken(imageToken);
    if (!tokenData) {
      return c.json({ error: 'Invalid or expired token' }, 401);
    }

    const stream = await S3Service.getObject(tokenData.key);
    if (!stream) {
      return c.json({ error: 'Image not found' }, 404);
    }

    // Set appropriate headers for secure image delivery
    c.header('Cache-Control', 'no-store, must-revalidate, private');
    c.header('Pragma', 'no-cache');
    c.header('Expires', '0');
    c.header('Content-Type', 'image/jpeg');
    c.header('Cross-Origin-Resource-Policy', 'same-origin');
    c.header('Content-Security-Policy', "default-src 'self'");
    
    // Stream the image directly
    return new Response(stream);
  } catch (error) {
    console.error('Error streaming image:', error);
    return c.json({ error: 'Failed to fetch image' }, 500);
  }
});

// Get project image by ID
app.get('/projects/:projectId/images/:imageId', webAuthMiddleware, async (c) => {
  const { projectId, imageId } = c.req.param();
  const baseUrl = new URL(c.req.url).origin;
  
  try {
    const imageData = await S3Service.getProjectImage(projectId, imageId, baseUrl);
    if (!imageData) {
      return c.json({ error: 'Image not found' }, 404);
    }

    // Generate a token for the image using the key from imageData
    const token = TokenService.generateToken(imageData.id);
    const proxyUrl = `${baseUrl}/api/v1/images/${token}`;
    
    return c.json({
      success: true,
      image: {
        id: imageId,
        originalName: imageData.originalName,
        url: proxyUrl,
        lastModified: imageData.lastModified,
        isAnnotated: imageData.isAnnotated,
        annotations: imageData.annotations
      }
    });
  } catch (error) {
    console.error('Error getting image:', error);
    return c.json({ error: 'Failed to get image' }, 500);
  }
});

// List project images
app.get('/projects/:projectId/images', webAuthMiddleware, async (c) => {
  const projectId = c.req.param('projectId');
  const cursor = c.req.query('cursor');
  const limit = parseInt(c.req.query('limit') || '30');
  const baseUrl = new URL(c.req.url).origin;

  try {
    const images = await S3Service.listProjectImages(
      projectId,
      baseUrl,
      cursor,
      limit
    );

    return c.json({ success: true, ...images });
  } catch (error) {
    console.error('Error listing project images:', error);
    return c.json({ error: 'Failed to list images' }, 500);
  }
});

// Upload project images
app.post('/projects/:projectId/images', webAuthMiddleware, async (c) => {
  const projectId = c.req.param('projectId');
  const formData = await c.req.formData();
  
  try {
    const files = [];
    
    // Extract files from form data
    for (const entry of formData.entries()) {
      const [name, value] = entry;
      if (value instanceof File) {
        files.push(value);
      }
    }
    
    if (files.length === 0) {
      return c.json({ error: 'No files uploaded' }, 400);
    }
    
    // Process and upload each file
    const results = await Promise.all(
      files.map(async (file) => {
        const fileBuffer = await file.arrayBuffer();
        const buffer = Buffer.from(fileBuffer);
        
        // Get image dimensions if possible
        let dimensions;
        try {
          // Simplified dimension extraction - you might want to use a more robust method
          const width = 0; // Placeholder
          const height = 0; // Placeholder
          dimensions = { width, height };
        } catch (error) {
          console.warn('Failed to extract image dimensions:', error);
        }
        
        // Upload to S3
        const success = await S3Service.uploadProjectImage(
          projectId,
          file.name,
          buffer,
          dimensions
        );
        
        return {
          filename: file.name,
          success
        };
      })
    );
    
    // Count successful uploads
    const successCount = results.filter(r => r.success).length;
    
    return c.json({
      success: true,
      message: `Uploaded ${successCount} of ${files.length} images successfully`,
      results
    });
  } catch (error) {
    console.error('Error uploading images:', error);
    return c.json({ error: 'Failed to upload images' }, 500);
  }
});

// Delete a project image
app.delete('/projects/:projectId/images/:imageId', adminAuthMiddleware, async (c) => {
  const { projectId, imageId } = c.req.param();
  
  try {
    const success = await S3Service.deleteProjectImage(projectId, imageId);
    
    if (!success) {
      return c.json({ success: false, error: 'Failed to delete image' }, 500);
    }
    
    return c.json({ success: true });
  } catch (error) {
    console.error('Error deleting image:', error);
    return c.json({ error: 'Failed to delete image' }, 500);
  }
});

export { app as imageRoutes };

================
File: src/routes/index.ts
================
// src/routes/index.ts
import { Hono } from 'hono'
import { authRoutes } from './auth.routes.js'
import { projectRoutes } from './project.routes.js'
import { imageRoutes } from './image.routes.js'
import { annotationRoutes } from './annotation.routes.js'
import { logRoutes } from './log.routes.js'
import { userRoutes } from './user.routes.js'
import { adminRoutes } from './admin.routes.js'

const app = new Hono()

// API version prefix for all routes
const API_PREFIX = '/api/v1'

// Mount all route groups under the API prefix
app.route(`${API_PREFIX}/auth`, authRoutes)
app.route(`${API_PREFIX}/users`, userRoutes)
app.route(`${API_PREFIX}/admins`, adminRoutes)
app.route(`${API_PREFIX}/projects`, projectRoutes)
app.route(`${API_PREFIX}/images`, imageRoutes)
app.route(`${API_PREFIX}/logs`, logRoutes)

// Routes that don't fit the pattern above
app.route(API_PREFIX, annotationRoutes) // These routes include project-related annotation paths

export { app as routes }

================
File: src/routes/log.routes.ts
================
// src/routes/log.routes.ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { SecurityLogService } from '../services/log.service.js';
import { adminAuthMiddleware, webAuthMiddleware } from '../middleware/auth.middleware.js';
import { SecurityLogType } from '../types/log.types.js';
import type { Admin, WebUser } from '../types/auth.types.js';

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const securityEventSchema = z.object({
  logType: z.nativeEnum(SecurityLogType),
  keyPressed: z.string().optional(),
  additionalInfo: z.string().optional()
});

// Log security event (from client)
app.post('/events', webAuthMiddleware, zValidator('json', securityEventSchema), async (c) => {
  try {
    const body = await c.req.json();
    const { logType, keyPressed, additionalInfo } = body;

    // Get user info from request
    const userAgent = c.req.header('user-agent') || 'unknown';
    const ip = c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown';
    const path = c.req.path;

    // Get user from context
    const user = c.get('user');
    
    if (!user) {
      return c.json({ error: 'User not found' }, 401);
    }

    const success = await SecurityLogService.logSecurityEvent(
      user.username,
      logType,
      {
        userAgent,
        ip,
        path,
        keyPressed,
        additionalInfo,
        deviceInfo: user.activeDevice?.fingerprint
      }
    );

    if (!success) {
      return c.json({ error: 'Failed to log security event' }, 500);
    }

    return c.json({ success: true, message: 'Security event logged successfully' });
  } catch (error) {
    console.error('Error logging security event:', error);
    return c.json({ error: 'Failed to process security event' }, 500);
  }
});

// Get security logs with filtering (admin only)
app.get('/', adminAuthMiddleware, async (c) => {
  try {
    const {
      userId,
      logType,
      startDate,
      endDate,
      ip,
      page,
      limit
    } = c.req.query();

    const filters = {
      userId,
      logType: logType as SecurityLogType,
      startDate: startDate ? new Date(startDate) : undefined,
      endDate: endDate ? new Date(endDate) : undefined,
      ip,
      page: page ? parseInt(page) : 1,
      limit: limit ? parseInt(limit) : 50
    };

    const logs = await SecurityLogService.getSecurityLogs(filters);
    return c.json(logs);
  } catch (error) {
    console.error('Error fetching security logs:', error);
    return c.json({ error: 'Failed to fetch security logs' }, 500);
  }
});

// Get security statistics (admin only)
app.get('/stats', adminAuthMiddleware, async (c) => {
  try {
    const timeframe = parseInt(c.req.query('timeframe') || '24');
    const stats = await SecurityLogService.getSecurityStats(timeframe);
    return c.json(stats);
  } catch (error) {
    console.error('Error fetching security stats:', error);
    return c.json({ error: 'Failed to fetch security stats' }, 500);
  }
});

// Get user security summary (admin only)
app.get('/users/:userId', adminAuthMiddleware, async (c) => {
  try {
    const userId = c.req.param('userId');
    const summary = await SecurityLogService.getUserSecuritySummary(userId);
    return c.json(summary);
  } catch (error) {
    console.error('Error fetching user security summary:', error);
    return c.json({ error: 'Failed to fetch user security summary' }, 500);
  }
});

// Get admin logs (super admin only)
app.get('/admins/:adminId', adminAuthMiddleware, async (c) => {
  try {
    const adminId = c.req.param('adminId');
    const { page = "1", limit = "20" } = c.req.query();

    // Verify super admin status using the token
    const requestingAdmin = c.get('adminUser');

    if (!requestingAdmin?.isSuperAdmin) {
      return c.json({ error: 'Only super admins can view admin logs' }, 403);
    }

    // Get admin's logs
    const logs = await SecurityLogService.getSecurityLogs({
      userId: adminId,
      page: parseInt(page),
      limit: parseInt(limit),
      // Add filter for admin-specific log types
      logType: [
        SecurityLogType.ADMIN_LOGIN,
        SecurityLogType.ADMIN_CREATED,
        SecurityLogType.ADMIN_DELETED,
        SecurityLogType.ADMIN_PASSWORD_RESET,
        SecurityLogType.ADMIN_REVOKED,
        SecurityLogType.USER_CREATED,
        SecurityLogType.USER_UPDATED,
        SecurityLogType.USER_DELETED,
        SecurityLogType.ACCOUNT_LOCKED,
        SecurityLogType.ACCOUNT_UNLOCKED
      ]
    });

    return c.json(logs);
  } catch (error) {
    console.error('Error fetching admin logs:', error);
    return c.json({ error: 'Failed to fetch admin logs' }, 500);
  }
});

export { app as logRoutes };

================
File: src/routes/project.routes.ts
================
// src/routes/project.routes.ts
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { z } from "zod";
import { adminAuthMiddleware, webAuthMiddleware } from "../middleware/auth.middleware.js";
import { ProjectService } from "../services/project.service.js";
import { SecurityLogService } from "../services/log.service.js";
import { SecurityLogType } from "../types/log.types.js";
import { ProjectStatus, AnnotationFormat } from "../types/project.types.js";
import type { Admin, WebUser } from "../types/auth.types.js";
import { Projects } from "../config/mongo.js";
import { ObjectId } from "mongodb";

type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const createProjectSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().optional(),
  settings: z.object({
    allowCustomClasses: z.boolean().default(false),
    requireReview: z.boolean().default(true),
    autoDistribute: z.boolean().default(true),
    modelFormat: z.nativeEnum(AnnotationFormat),
  }),
  classes: z.array(z.string()).min(1),
  totalImages: z.number().int().positive(),
});

const updateProjectSchema = z.object({
  name: z.string().min(1).max(100).optional(),
  description: z.string().optional(),
  settings: z
    .object({
      allowCustomClasses: z.boolean(),
      requireReview: z.boolean(),
      autoDistribute: z.boolean(),
      modelFormat: z.nativeEnum(AnnotationFormat),
    })
    .optional(),
  classes: z.array(z.string()).min(1).optional(),
  status: z.nativeEnum(ProjectStatus).optional(),
});

const memberAssignmentSchema = z.object({
  userId: z.string(),
  allocationPercentage: z.number().min(0).max(100),
});

const classesSchema = z.object({
  classes: z.array(z.string())
});

const submitProjectSchema = z.object({
  projectId: z.string()
});

const unmarkProjectSchema = z.object({
  projectId: z.string()
});

// List all projects (admin only)
app.get('/', adminAuthMiddleware, async (c) => {
  try {
    const projects = await Projects.find({}).toArray();
    
    const formattedProjects = projects.map(project => ({
      id: project._id.toString(),
      name: project.name,
      description: project.description,
      status: project.status,
      createdAt: project.createdAt,
      createdBy: project.createdBy,
      settings: project.settings,
      classes: project.classes,
      totalImages: project.totalImages,
      stats: project.stats,
      members: project.members || []
    }));

    return c.json({ 
      success: true, 
      projects: formattedProjects 
    });
  } catch (error) {
    console.error("Error fetching projects:", error);
    return c.json({ 
      success: false, 
      error: "Failed to fetch projects" 
    }, 500);
  }
});

// Create new project
app.post('/', adminAuthMiddleware, zValidator("json", createProjectSchema), async (c) => {
  try {
    const adminUser = c.get("adminUser");
    const projectData = await c.req.json();

    const projectId = await ProjectService.createProject(
      adminUser.username,
      projectData
    );

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.PROJECT_CREATED,
      {
        userAgent: c.req.header("user-agent") || "unknown",
        ip: c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown",
        path: c.req.path,
        additionalInfo: `Created project: ${projectData.name}`,
      }
    );

    return c.json({ success: true, projectId });
  } catch (error) {
    console.error("Error creating project:", error);
    return c.json({ success: false, error: "Failed to create project" }, 500);
  }
});

// Get single project
app.get('/:projectId', adminAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    
    // Use a regular expression to match the project ID - this avoids type issues
    const projects = await Projects.find({}).toArray();
    const project = projects.find(p => p._id.toString() === projectId);
    
    if (!project) {
      return c.json({ 
        success: false, 
        error: "Project not found" 
      }, 404);
    }

    // Format the response
    const formattedProject = {
      id: project._id.toString(),
      name: project.name,
      description: project.description,
      status: project.status,
      createdAt: project.createdAt,
      createdBy: project.createdBy,
      settings: project.settings,
      classes: project.classes,
      totalImages: project.totalImages,
      stats: project.stats,
      members: project.members || []
    };

    return c.json({ 
      success: true, 
      project: formattedProject
    });
  } catch (error) {
    console.error("Error fetching project:", error);
    return c.json({ 
      success: false, 
      error: "Failed to fetch project" 
    }, 500);
  }
});

// Update project
app.put('/:projectId', adminAuthMiddleware, zValidator("json", updateProjectSchema), async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const updates = await c.req.json();

    const success = await ProjectService.updateProject(projectId, updates);
    if (!success) {
      return c.json({ success: false, error: "Project not found" }, 404);
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Error updating project:", error);
    return c.json({ success: false, error: "Failed to update project" }, 500);
  }
});

// Get project stats
app.get('/:projectId/stats', adminAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const stats = await ProjectService.getProjectStats(projectId);
    return c.json({ success: true, stats });
  } catch (error) {
    console.error("Error getting project stats:", error);
    return c.json(
      { success: false, error: "Failed to get project stats" },
      500
    );
  }
});

// Submit project for review
app.post('/:projectId/submit', webAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const user = c.get("user");
    
    // Verify user has access to this project
    const hasAccess = await ProjectService.userHasAccess(user.username, projectId);
    if (!hasAccess) {
      return c.json({ success: false, error: "Not authorized to access this project" }, 403);
    }
    
    // Submit project for review
    const success = await ProjectService.submitProject(projectId, user.username);
    if (!success) {
      return c.json({ success: false, error: "Failed to submit project" }, 500);
    }
    
    await SecurityLogService.logSecurityEvent(
      user.username,
      SecurityLogType.PROJECT_SUBMITTED,
      {
        userAgent: c.req.header("user-agent") || "unknown",
        ip: c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown",
        path: c.req.path,
        additionalInfo: `Submitted project: ${projectId}`
      }
    );
    
    return c.json({ success: true });
  } catch (error) {
    console.error("Error submitting project:", error);
    return c.json({ success: false, error: "Failed to submit project" }, 500);
  }
});

// Unmark project submission (admin only)
app.post('/:projectId/unmark', adminAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const adminUser = c.get("adminUser");
    
    // Unmark project submission
    const success = await ProjectService.unmarkSubmission(projectId);
    if (!success) {
      return c.json({ success: false, error: "Failed to unmark project" }, 500);
    }
    
    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.PROJECT_UNMARKED,
      {
        userAgent: c.req.header("user-agent") || "unknown",
        ip: c.req.header("x-forwarded-for") || c.req.header("x-real-ip") || "unknown",
        path: c.req.path,
        additionalInfo: `Unmarked project submission: ${projectId}`
      }
    );
    
    return c.json({ success: true });
  } catch (error) {
    console.error("Error unmarking project:", error);
    return c.json({ success: false, error: "Failed to unmark project" }, 500);
  }
});

// Get project classes
app.get('/:projectId/classes', webAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const classes = await ProjectService.getClasses(projectId);
    
    return c.json({ success: true, classes });
  } catch (error) {
    console.error("Error getting classes:", error);
    return c.json({ success: false, error: "Failed to get classes" }, 500);
  }
});

// Update project classes
app.put('/:projectId/classes', adminAuthMiddleware, zValidator("json", classesSchema), async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const { classes } = await c.req.json();

    const success = await ProjectService.updateClasses(projectId, classes);
    if (!success) {
      return c.json({ success: false, error: "Failed to update classes" }, 500);
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Error updating classes:", error);
    return c.json({ success: false, error: "Failed to update classes" }, 500);
  }
});

// List project members
app.get('/:projectId/members', adminAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    
    const project = await Projects.findOne({
      _id: new ObjectId(projectId) as unknown as string,
    });
    
    if (!project) {
      return c.json({ success: false, error: "Project not found" }, 404);
    }
    
    return c.json({ 
      success: true, 
      members: project.members || [] 
    });
  } catch (error) {
    console.error("Error fetching project members:", error);
    return c.json({ success: false, error: "Failed to fetch members" }, 500);
  }
});

// Add project member
app.post('/:projectId/members', adminAuthMiddleware, zValidator("json", memberAssignmentSchema), async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const { userId, allocationPercentage } = await c.req.json();

    const success = await ProjectService.addProjectMember(
      projectId,
      userId,
      allocationPercentage
    );

    if (!success) {
      return c.json({ success: false, error: "Failed to add member" }, 400);
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Error adding project member:", error);
    return c.json({ success: false, error: "Failed to add member" }, 500);
  }
});

// Update member allocation
app.put('/:projectId/members/:userId', adminAuthMiddleware, zValidator("json", memberAssignmentSchema), async (c) => {
  try {
    const { projectId, userId } = c.req.param();
    const { allocationPercentage } = await c.req.json();

    const success = await ProjectService.updateMemberAllocation(
      projectId,
      userId,
      allocationPercentage
    );

    if (!success) {
      return c.json(
        { success: false, error: "Failed to update allocation" },
        400
      );
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Error updating member allocation:", error);
    return c.json(
      { success: false, error: "Failed to update allocation" },
      500
    );
  }
});

// Remove project member
app.delete('/:projectId/members/:userId', adminAuthMiddleware, async (c) => {
  try {
    const { projectId, userId } = c.req.param();

    const success = await ProjectService.removeMember(projectId, userId);
    if (!success) {
      return c.json({ success: false, error: "Failed to remove member" }, 400);
    }

    return c.json({ success: true });
  } catch (error) {
    console.error("Error removing project member:", error);
    return c.json({ success: false, error: "Failed to remove member" }, 500);
  }
});

// Get assignments for a project
app.get('/:projectId/assignments', webAuthMiddleware, async (c) => {
  try {
    const projectId = c.req.param("projectId");
    const user = c.get("user");
    const page = parseInt(c.req.query("page") || "1");
    const limit = parseInt(c.req.query("limit") || "20");

    const assignments = await ProjectService.getMemberAssignments(
      projectId,
      user.username,
      page,
      limit
    );

    return c.json({ success: true, ...assignments });
  } catch (error) {
    console.error("Error getting assignments:", error);
    return c.json({ success: false, error: "Failed to get assignments" }, 500);
  }
});

export { app as projectRoutes };

================
File: src/routes/user.routes.ts
================
// src/routes/user.routes.ts
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { WebUsers } from '../config/mongo.js';
import { SecurityLogService } from '../services/log.service.js';
import { SecurityLogType } from '../types/log.types.js';
import { AuthService } from '../services/auth.service.js';
import { adminAuthMiddleware, webAuthMiddleware } from '../middleware/auth.middleware.js';
import type { Admin, WebUser } from '../types/auth.types.js';

// Define context variable types
type Variables = {
  adminUser: Admin;
  user: WebUser;
};

const app = new Hono<{ Variables: Variables }>();

// Schema Validation
const createUserSchema = z.object({
  username: z.string().min(3),
  password: z.string().min(8),
  isOfficeUser: z.boolean().default(false)
});

const resetPasswordSchema = z.object({
  newPassword: z.string().min(8)
});

const lockUserSchema = z.object({
  reason: z.string().optional()
});

const officeStatusSchema = z.object({
  isOfficeUser: z.boolean()
});

// List all users (admin only)
app.get('/', adminAuthMiddleware, async (c) => {
  try {
    const users = await WebUsers.find({}).toArray();
    
    // Filter sensitive information
    const filteredUsers = users.map(user => ({
      username: user.username,
      isLocked: user.isLocked,
      lockReason: user.lockReason,
      lastLoginAttempt: user.lastLoginAttempt,
      failedLoginAttempts: user.failedLoginAttempts,
      isOfficeUser: user.isOfficeUser,
      activeDevice: user.activeDevice ? {
        lastSeen: user.activeDevice.lastSeen,
        ip: user.activeDevice.ip,
        userAgent: user.activeDevice.userAgent
      } : null,
      activityLog: user.activityLog || []
    }));
    
    return c.json({ users: filteredUsers });
  } catch (error) {
    console.error('Error fetching users:', error);
    return c.json({ error: 'Failed to fetch users' }, 500);
  }
});

// Create user (admin only)
app.post('/', adminAuthMiddleware, zValidator('json', createUserSchema), async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const { username, password, isOfficeUser } = await c.req.json();

    const success = await AuthService.createWebUser(username, password, isOfficeUser);
    if (!success) {
      return c.json({ error: 'Username already exists' }, 409);
    }

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.USER_CREATED,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `Created user: ${username}`
      }
    );

    return c.json({ success: true, message: 'User created successfully' });
  } catch (error) {
    console.error('User creation error:', error);
    return c.json({ error: 'Failed to create user' }, 500);
  }
});

// Get user details
app.get('/:userId', adminAuthMiddleware, async (c) => {
  try {
    const username = c.req.param('userId');
    const user = await WebUsers.findOne({ username });
    
    if (!user) {
      return c.json({ error: 'User not found' }, 404);
    }
    
    // Filter sensitive information
    const filteredUser = {
      username: user.username,
      isLocked: user.isLocked,
      lockReason: user.lockReason,
      lastLoginAttempt: user.lastLoginAttempt,
      failedLoginAttempts: user.failedLoginAttempts,
      isOfficeUser: user.isOfficeUser,
      activeDevice: user.activeDevice ? {
        lastSeen: user.activeDevice.lastSeen,
        ip: user.activeDevice.ip,
        userAgent: user.activeDevice.userAgent
      } : null,
      activityLog: user.activityLog || []
    };
    
    return c.json({ user: filteredUser });
  } catch (error) {
    console.error('Error fetching user:', error);
    return c.json({ error: 'Failed to fetch user' }, 500);
  }
});

// Delete user
app.delete('/:userId', adminAuthMiddleware, async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const username = c.req.param('userId');
    
    const success = await AuthService.deleteUser(username);
    if (!success) {
      return c.json({ error: 'User not found or could not be deleted' }, 404);
    }
    
    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.USER_DELETED,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `Deleted user: ${username}`
      }
    );
    
    return c.json({ success: true });
  } catch (error) {
    console.error('Error deleting user:', error);
    return c.json({ error: 'Failed to delete user' }, 500);
  }
});

// Reset password (admin only)
app.put('/:userId/password', adminAuthMiddleware, zValidator('json', resetPasswordSchema), async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const username = c.req.param('userId');
    const { newPassword } = await c.req.json();

    const success = await AuthService.resetUserPasswordAdmin(username, newPassword);
    if (!success) {
      return c.json({ error: 'Failed to reset password or user not found' }, 404);
    }

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.PASSWORD_RESET,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `Reset password for user: ${username}`
      }
    );

    return c.json({ success: true });
  } catch (error) {
    console.error('Error resetting password:', error);
    return c.json({ error: 'Failed to reset password' }, 500);
  }
});

// Lock/unlock user
app.put('/:userId/status', adminAuthMiddleware, zValidator('json', lockUserSchema), async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const username = c.req.param('userId');
    const { reason, action } = await c.req.json();
    
    let success: boolean;
    let logType: SecurityLogType;
    
    if (action === 'lock') {
      success = await AuthService.lockUser(username, reason);
      logType = SecurityLogType.ACCOUNT_LOCKED;
    } else if (action === 'unlock') {
      success = await AuthService.unlockUser(username);
      logType = SecurityLogType.ACCOUNT_UNLOCKED;
    } else {
      return c.json({ error: 'Invalid action. Must be "lock" or "unlock"' }, 400);
    }
    
    if (!success) {
      return c.json({ error: 'Failed to update user status or user not found' }, 404);
    }

    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      logType,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `${action === 'lock' ? 'Locked' : 'Unlocked'} user: ${username}${reason ? ` - Reason: ${reason}` : ''}`
      }
    );

    return c.json({ success: true });
  } catch (error) {
    console.error('Error updating user status:', error);
    return c.json({ error: 'Failed to update user status' }, 500);
  }
});

// Force logout (terminate sessions)
app.delete('/:userId/sessions', adminAuthMiddleware, async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const username = c.req.param('userId');
    
    const success = await AuthService.forceLogoutUser(username);
    if (!success) {
      return c.json({ error: 'Failed to logout user or user not found' }, 404);
    }
    
    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.USER_LOGOUT,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `Forced logout for user: ${username}`
      }
    );
    
    return c.json({ success: true });
  } catch (error) {
    console.error('Error logging out user:', error);
    return c.json({ error: 'Failed to logout user' }, 500);
  }
});

// Get user logs
app.get('/:userId/logs', adminAuthMiddleware, async (c) => {
  try {
    const username = c.req.param('userId');
    const { page = "1", limit = "50" } = c.req.query();
    
    const logs = await SecurityLogService.getSecurityLogs({
      userId: username,
      page: parseInt(page),
      limit: parseInt(limit)
    });
    
    return c.json(logs);
  } catch (error) {
    console.error('Error fetching user logs:', error);
    return c.json({ error: 'Failed to fetch user logs' }, 500);
  }
});

// Update office status
app.put('/:userId/office-status', adminAuthMiddleware, zValidator('json', officeStatusSchema), async (c) => {
  try {
    const adminUser = c.get('adminUser');
    const username = c.req.param('userId');
    const { isOfficeUser } = await c.req.json();
    
    // Update user's office status
    const result = await WebUsers.updateOne(
      { username },
      { $set: { isOfficeUser } }
    );
    
    if (result.matchedCount === 0) {
      return c.json({ error: 'User not found' }, 404);
    }
    
    await SecurityLogService.logSecurityEvent(
      adminUser.username,
      SecurityLogType.USER_UPDATED,
      {
        userAgent: c.req.header('user-agent') || 'unknown',
        ip: c.req.header('x-forwarded-for') || c.req.header('x-real-ip') || 'unknown',
        path: c.req.path,
        additionalInfo: `Updated office status for user: ${username} to ${isOfficeUser ? 'office user' : 'regular user'}`
      }
    );
    
    return c.json({ success: true });
  } catch (error) {
    console.error('Error updating office status:', error);
    return c.json({ error: 'Failed to update office status' }, 500);
  }
});

// Get user's assigned projects
app.get('/:userId/projects', webAuthMiddleware, async (c) => {
  try {
    const username = c.req.param('userId');
    
    // If a user is trying to access another user's projects, check admin access
    const requestUser = c.get('user');
    const requestAdmin = c.get('adminUser');
    
    if (requestUser && requestUser.username !== username && !requestAdmin) {
      return c.json({ error: 'Unauthorized access to other user\'s projects' }, 403);
    }
    
    // Fetch user's projects
    const userProjects = await AuthService.getUserProjects(username);
    
    return c.json({ success: true, projects: userProjects });
  } catch (error) {
    console.error('Error fetching user projects:', error);
    return c.json({ error: 'Failed to fetch user projects' }, 500);
  }
});

export { app as userRoutes };

================
File: src/services/auth.service.ts
================
// src/services/auth.service.ts

import { WebUsers, Admins, Projects } from "../config/mongo.js";
import { CryptoService } from "./crypto.service.js";
import { DeviceService } from "./device.service.js";
import { ScrapingDetectionService } from "./scraping-detection.service.js";
import { SecurityLogService } from "./log.service.js";
import { SecurityLogType } from "../types/log.types.js";
import { type AuthResponse, UserRole } from "../types/auth.types.js";
import { ObjectId } from "mongodb";
import { ProjectService } from "./project.service.js";

export class AuthService {
  static readonly TOKEN_EXPIRY = 30 * 60 * 1000; // 30 minutes
  private static readonly MAX_LOGIN_ATTEMPTS = 5;
  private static readonly LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes

  /**
   * Create a new web user
   */
  static async createWebUser(
    username: string,
    password: string,
    isOfficeUser: boolean
  ): Promise<boolean> {
    const existing = await WebUsers.findOne({ username });
    if (existing) return false;

    const { hash: passwordHash, salt } = await CryptoService.hashPassword(
      password
    );

    await WebUsers.insertOne({
      username,
      passwordHash,
      salt,
      isOfficeUser, // Add this field
      isLocked: false,
      lastLoginAttempt: new Date(),
      failedLoginAttempts: 0,
      activityLog: [],
      rateLimit: {
        count: 0,
        resetAt: new Date(),
      },
    });

    // Create default classes for office users
    // if (isOfficeUser) {
    //   await S3Service.createDefaultOfficeClasses(username);
    // }

    return true;
  }

  /**
   * Create an admin with password
   */
  static async createAdmin(
    username: string,
    password: string,
    isSuperAdmin: boolean = false
  ): Promise<boolean> {
    const existing = await Admins.findOne({ username });
    if (existing) return false;

    const { hash: passwordHash, salt } = await CryptoService.hashPassword(
      password
    );

    await Admins.insertOne({
      username,
      passwordHash,
      salt,
      isSuperAdmin,
      createdAt: new Date(),
      isLocked: false,
      failedLoginAttempts: 0,
      lastLoginAttempt: new Date(),
    });

    return true;
  }

  /**
   * Attempt to log in a web user
   */
  static async loginWebUser(
    username: string,
    password: string,
    ip: string,
    userAgent: string,
    deviceInfo: string = ""
  ): Promise<AuthResponse | null> {
    const user = await WebUsers.findOne({ username });
    if (!user) return null;

    // Check if account is locked
    if (user.isLocked) {
      const lockoutEnd = new Date(
        user.lastLoginAttempt.getTime() + this.LOCKOUT_DURATION
      );
      if (new Date() < lockoutEnd) {
        await this.logSecurityEvent(
          username,
          SecurityLogType.LOGIN_ATTEMPT_LOCKED,
          ip,
          userAgent
        );
        return null;
      }
      // Reset lock if lockout period is over
      await WebUsers.updateOne({ username }, { $set: { isLocked: false } });
    }

    // Verify password
    const isValid = await CryptoService.verifyPassword(
      password,
      user.passwordHash,
      user.salt
    );

    if (!isValid) {
      await this.handleFailedLogin(username, ip, userAgent);
      return null;
    }

    // Generate device fingerprint
    const fingerprint = DeviceService.generateFingerprint(
      userAgent,
      "",
      deviceInfo
    );

    // Check if device changed
    const deviceChanged = !!(
      user.activeDevice && user.activeDevice.fingerprint !== fingerprint
    );

    // Generate token and update device information
    const token = CryptoService.generateToken();
    const expiry = new Date(Date.now() + this.TOKEN_EXPIRY);

    await WebUsers.updateOne(
      { username },
      {
        $set: {
          activeDevice: {
            fingerprint,
            userAgent,
            lastSeen: new Date(),
            ip,
            deviceInfo,
          },
          accessToken: token,
          tokenExpiry: expiry,
          lastLoginAttempt: new Date(),
          failedLoginAttempts: 0,
        },
      }
    );

    await this.logSecurityEvent(
      username,
      SecurityLogType.LOGIN_SUCCESS,
      ip,
      userAgent
    );

    return {
      token,
      expiry,
      role: UserRole.USER,
      redirectTo: "/dashboard",
      deviceChanged,
    };
  }

  /**
   * Attempt to log in an admin
   */
  static async loginAdmin(
    username: string,
    password: string,
    ip: string,
    userAgent: string
  ): Promise<AuthResponse | null> {
    const admin = await Admins.findOne({ username });
    if (!admin) return null;

    // Check if account is locked
    if (admin.isLocked) {
      const lockoutEnd = new Date(
        admin.lastLoginAttempt.getTime() + this.LOCKOUT_DURATION
      );
      if (new Date() < lockoutEnd) {
        await SecurityLogService.logSecurityEvent(
          username,
          SecurityLogType.LOGIN_ATTEMPT_LOCKED,
          { userAgent, ip, path: "/auth/login" }
        );
        return null;
      }
      // Reset lock if lockout period is over
      await this.unlockAdmin(username);
    }

    // Verify password
    const isValid = await CryptoService.verifyPassword(
      password,
      admin.passwordHash,
      admin.salt
    );

    if (!isValid) {
      await this.handleFailedAdminLogin(username, ip, userAgent);
      return null;
    }

    // Reset failed attempts on successful login
    const token = CryptoService.generateToken();
    const expiry = new Date(Date.now() + this.TOKEN_EXPIRY);

    await Admins.updateOne(
      { username },
      {
        $set: {
          accessToken: token,
          tokenExpiry: expiry,
          lastLogin: new Date(),
          failedLoginAttempts: 0,
          lastLoginAttempt: new Date(),
        },
      }
    );

    await SecurityLogService.logSecurityEvent(
      username,
      SecurityLogType.ADMIN_LOGIN,
      { userAgent, ip, path: "/auth/login" }
    );

    return {
      token,
      expiry,
      role: UserRole.ADMIN,
      redirectTo: "/admin",
    };
  }

  /**
   * Verify a request token and device signature
   */
  static async verifyRequest(
    token: string,
    ip: string,
    userAgent: string,
    endpoint: string,
    startTime: number
  ): Promise<boolean> {
    const user = await WebUsers.findOne({ accessToken: token });
    if (!user || !user.tokenExpiry) return false;

    // Check token expiry
    if (new Date() > user.tokenExpiry) {
      await this.invalidateTokens(user._id!);
      return false;
    }

    // Only verify device fingerprint for non-bot requests
    if (!DeviceService.isKnownBot(userAgent)) {
      const storedDeviceInfo = user.activeDevice?.deviceInfo || "";
      const currentDeviceInfo = user.activeDevice?.deviceInfo || "";

      // Generate fingerprints without user agent to avoid middleware mismatches
      const fingerprint = DeviceService.generateFingerprint(
        "browser-client", // Use normalized user agent
        "",
        currentDeviceInfo
      );

      const storedFingerprint = DeviceService.generateFingerprint(
        "browser-client", // Use same normalized user agent
        "",
        storedDeviceInfo
      );

      // Check for major device mismatches
      if (fingerprint !== storedFingerprint) {
        try {
          // Parse device info for more granular comparison
          const stored = JSON.parse(storedDeviceInfo);
          const current = JSON.parse(currentDeviceInfo);

          // Only invalidate for significant changes
          const majorMismatch =
            stored.platform !== current.platform ||
            stored.timezone !== current.timezone;

          if (majorMismatch) {
            await this.invalidateTokens(user._id!);
            await this.logSecurityEvent(
              user.username,
              SecurityLogType.DEVICE_MISMATCH,
              ip,
              userAgent,
              `Platform or timezone mismatch. Stored: ${JSON.stringify(
                stored
              )}, Current: ${JSON.stringify(current)}`
            );
            return false;
          }
        } catch (error) {
          console.error("Error comparing device info:", error);
          // Continue if parsing fails - don't invalidate the session
        }
      }
    }

    // Check for suspicious activity
    const { allowed, reason } = await ScrapingDetectionService.handleRequest(
      user,
      ip,
      userAgent,
      endpoint,
      startTime
    );

    if (!allowed) {
      await this.lockAccount(
        user.username,
        reason || "suspicious_activity",
        ip,
        userAgent
      );
      return false;
    }

    // Update last seen timestamp
    await WebUsers.updateOne(
      { _id: user._id },
      {
        $set: {
          "activeDevice.lastSeen": new Date(),
          "activeDevice.ip": ip,
        },
      }
    );

    return true;
  }

  /**
   * Verify token and device info
   */
  static async verifyToken(
    token: string,
    ip: string,
    userAgent: string,
    deviceInfo: Record<string, unknown>
  ): Promise<{
    valid: boolean;
    role?: UserRole;
    error?: string;
  }> {
    // Log for debugging
    console.log("Verifying token prefix:", token.substring(0, 10) + "...");

    // First check web users
    const webUser = await WebUsers.findOne({ accessToken: token });
    if (webUser) {
      if (!webUser.tokenExpiry || new Date() > webUser.tokenExpiry) {
        return { valid: false, error: "Token expired" };
      }

      // For web users, only verify device fingerprint if not a bot
      if (!DeviceService.isKnownBot(userAgent)) {
        const fingerprint = DeviceService.generateFingerprint(
          userAgent,
          "",
          JSON.stringify(deviceInfo)
        );

        if (webUser.activeDevice?.fingerprint !== fingerprint) {
          return { valid: false, error: "Device mismatch" };
        }
      }

      return { valid: true, role: UserRole.USER };
    }

    // Then check admins - for admin users, don't do device fingerprint checks
    const admin = await Admins.findOne({ accessToken: token });
    if (admin) {
      if (!admin.tokenExpiry || new Date() > admin.tokenExpiry) {
        return { valid: false, error: "Token expired" };
      }
      return { valid: true, role: UserRole.ADMIN };
    }

    console.log("Token not found in either collection");
    return { valid: false, error: "Invalid token" };
  }

  /**
   * Get user info from token
   */
  static async getUserInfo(token: string): Promise<{
    username: string;
    role: UserRole;
    deviceInfo?: any;
    isLocked?: boolean;
    lockReason?: string;
    isOfficeUser?: boolean;
    isSuperAdmin?: boolean;
  } | null> {
    // Check web users first
    const webUser = await WebUsers.findOne({ accessToken: token });
    if (webUser) {
      return {
        username: webUser.username,
        role: UserRole.USER,
        deviceInfo: webUser.activeDevice,
        isLocked: webUser.isLocked,
        lockReason: webUser.lockReason,
        isOfficeUser: webUser.isOfficeUser,
      };
    }

    // Check admins
    const admin = await Admins.findOne({ accessToken: token });
    if (admin) {
      return {
        username: admin.username,
        role: UserRole.ADMIN,
        isLocked: admin.isLocked,
        lockReason: admin.lockReason,
        isSuperAdmin: admin.isSuperAdmin,
      };
    }

    return null;
  }

  /**
   * Handle failed login attempt for web users
   */
  private static async handleFailedLogin(
    username: string,
    ip: string,
    userAgent: string
  ): Promise<void> {
    const user = await WebUsers.findOne({ username });
    if (!user) return;

    const failedAttempts = (user.failedLoginAttempts || 0) + 1;
    const shouldLock = failedAttempts >= this.MAX_LOGIN_ATTEMPTS;

    const updates = {
      failedLoginAttempts: failedAttempts,
      lastLoginAttempt: new Date(),
      isLocked: shouldLock,
      ...(shouldLock && { lockReason: "multiple_failed_attempts" }),
    };

    await WebUsers.updateOne({ username }, { $set: updates });

    await this.logSecurityEvent(
      username,
      shouldLock
        ? SecurityLogType.ACCOUNT_LOCKED
        : SecurityLogType.LOGIN_FAILED,
      ip,
      userAgent
    );
  }

  /**
   * Handle failed admin login attempts
   */
  private static async handleFailedAdminLogin(
    username: string,
    ip: string,
    userAgent: string
  ): Promise<void> {
    const admin = await Admins.findOne({ username });
    if (!admin) return;

    const failedAttempts = (admin.failedLoginAttempts || 0) + 1;
    const shouldLock = failedAttempts >= this.MAX_LOGIN_ATTEMPTS;

    await Admins.updateOne(
      { username },
      {
        $set: {
          failedLoginAttempts: failedAttempts,
          lastLoginAttempt: new Date(),
          isLocked: shouldLock,
          ...(shouldLock && { lockReason: "multiple_failed_attempts" }),
        },
      }
    );

    await SecurityLogService.logSecurityEvent(
      username,
      shouldLock
        ? SecurityLogType.ACCOUNT_LOCKED
        : SecurityLogType.LOGIN_FAILED,
      { userAgent, ip, path: "/auth/login" }
    );
  }

  /**
   * Lock account and log security event
   */
  private static async lockAccount(
    username: string,
    reason: string,
    ip: string,
    userAgent: string
  ): Promise<void> {
    await WebUsers.updateOne(
      { username },
      {
        $set: {
          isLocked: true,
          lockReason: reason,
          lastLoginAttempt: new Date(),
        },
        $unset: {
          accessToken: 1,
          tokenExpiry: 1,
          activeDevice: 1,
        },
      }
    );

    await this.logSecurityEvent(
      username,
      SecurityLogType.ACCOUNT_LOCKED,
      ip,
      userAgent,
      reason
    );
  }

  /**
   * Reset admin password (super admin only)
   */
  static async resetAdminPassword(
    username: string,
    newPassword: string
  ): Promise<boolean> {
    const admin = await Admins.findOne({ username });
    if (!admin) return false;

    const { hash: newHash, salt: newSalt } = await CryptoService.hashPassword(
      newPassword
    );

    const result = await Admins.updateOne(
      { username },
      {
        $set: {
          passwordHash: newHash,
          salt: newSalt,
          isLocked: false,
          failedLoginAttempts: 0,
          lastLoginAttempt: new Date(),
        },
        $unset: {
          lockReason: 1,
          accessToken: 1,
          tokenExpiry: 1,
        },
      }
    );

    return result.modifiedCount > 0;
  }

  /**
   * Unlock admin account
   */
  static async unlockAdmin(username: string): Promise<boolean> {
    const result = await Admins.updateOne(
      { username },
      {
        $set: {
          isLocked: false,
          failedLoginAttempts: 0,
          lastLoginAttempt: new Date(),
        },
        $unset: {
          lockReason: 1,
        },
      }
    );

    return result.modifiedCount > 0;
  }

  /**
   * Revoke admin access (delete admin account)
   */
  static async revokeAdmin(username: string): Promise<boolean> {
    const result = await Admins.deleteOne({ username });
    return result.deletedCount > 0;
  }

  /**
   * Invalidate user tokens
   */
  private static async invalidateTokens(userId: string): Promise<void> {
    await WebUsers.updateOne(
      { _id: userId },
      {
        $unset: {
          accessToken: 1,
          tokenExpiry: 1,
          activeDevice: 1,
        },
      }
    );
  }

  /**
   * Log security event
   */
  private static async logSecurityEvent(
    username: string,
    logType: SecurityLogType,
    ip: string,
    userAgent: string,
    additionalInfo?: string
  ): Promise<void> {
    await SecurityLogService.logSecurityEvent(username, logType, {
      userAgent,
      ip,
      additionalInfo,
    });
  }

  /**
   * Refresh user token
   */
  static async refreshToken(token: string): Promise<{
    token: string;
    expiry: Date;
  } | null> {
    // Check web users first
    const webUser = await WebUsers.findOne({ accessToken: token });
    if (webUser) {
      const newToken = CryptoService.generateToken();
      const expiry = new Date(Date.now() + this.TOKEN_EXPIRY);

      await WebUsers.updateOne(
        { _id: webUser._id },
        { $set: { accessToken: newToken, tokenExpiry: expiry } }
      );

      return { token: newToken, expiry };
    }

    // Check admins
    const admin = await Admins.findOne({ accessToken: token });
    if (admin) {
      const newToken = CryptoService.generateToken();
      const expiry = new Date(Date.now() + this.TOKEN_EXPIRY);

      await Admins.updateOne(
        { _id: admin._id },
        { $set: { accessToken: newToken, tokenExpiry: expiry } }
      );

      return { token: newToken, expiry };
    }

    return null;
  }

  /**
   * Log out user or admin
   */
  static async logout(token: string): Promise<boolean> {
    const webUser = await WebUsers.findOne({ accessToken: token });
    if (webUser) {
      const result = await WebUsers.updateOne(
        { _id: webUser._id },
        {
          $unset: {
            accessToken: 1,
            tokenExpiry: 1,
            activeDevice: 1,
          },
        }
      );
      return result.modifiedCount > 0;
    }

    const admin = await Admins.findOne({ accessToken: token });
    if (admin) {
      const result = await Admins.updateOne(
        { _id: admin._id },
        {
          $unset: {
            accessToken: 1,
            tokenExpiry: 1,
          },
        }
      );
      return result.modifiedCount > 0;
    }

    return false;
  }

  /**
   * Reset password for web user
   */
  static async resetPassword(
    username: string,
    oldPassword: string,
    newPassword: string
  ): Promise<boolean> {
    const user = await WebUsers.findOne({ username });
    if (!user) return false;

    // Verify old password
    const isValid = await CryptoService.verifyPassword(
      oldPassword,
      user.passwordHash,
      user.salt
    );

    if (!isValid) return false;

    // Generate new password hash
    const { hash: newHash, salt: newSalt } = await CryptoService.hashPassword(
      newPassword
    );

    const result = await WebUsers.updateOne(
      { username },
      {
        $set: {
          passwordHash: newHash,
          salt: newSalt,
        },
        $unset: {
          accessToken: 1,
          tokenExpiry: 1,
          activeDevice: 1,
        },
      }
    );

    return result.modifiedCount > 0;
  }

  /**
   * Lock a user account
   */
  static async lockUser(username: string, reason?: string): Promise<boolean> {
    try {
      const result = await WebUsers.updateOne(
        { username },
        {
          $set: {
            isLocked: true,
            lockReason: reason || "manual_lock",
            lastLoginAttempt: new Date(),
          },
          $unset: {
            accessToken: 1,
            tokenExpiry: 1,
            activeDevice: 1,
          },
        }
      );

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error locking user:", error);
      return false;
    }
  }

  /**
   * Unlock a user account
   */
  static async unlockUser(username: string): Promise<boolean> {
    try {
      const result = await WebUsers.updateOne(
        { username },
        {
          $set: {
            isLocked: false,
            failedLoginAttempts: 0,
            lastLoginAttempt: new Date(),
          },
          $unset: {
            lockReason: 1,
          },
        }
      );

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error unlocking user:", error);
      return false;
    }
  }

  /**
   * Force logout a specific user
   */
  static async forceLogoutUser(username: string): Promise<boolean> {
    try {
      const result = await WebUsers.updateOne(
        { username },
        {
          $unset: {
            accessToken: 1,
            tokenExpiry: 1,
            activeDevice: 1,
          },
        }
      );

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error force logging out user:", error);
      return false;
    }
  }

  /**
   * Reset user password (admin version - no old password required)
   */
  static async resetUserPasswordAdmin(
    username: string,
    newPassword: string
  ): Promise<boolean> {
    try {
      const user = await WebUsers.findOne({ username });
      if (!user) return false;

      const { hash: newHash, salt: newSalt } = await CryptoService.hashPassword(
        newPassword
      );

      const result = await WebUsers.updateOne(
        { username },
        {
          $set: {
            passwordHash: newHash,
            salt: newSalt,
          },
          $unset: {
            accessToken: 1,
            tokenExpiry: 1,
            activeDevice: 1,
          },
        }
      );

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error resetting user password:", error);
      return false;
    }
  }

  /**
   * Delete user
   */
  static async deleteUser(username: string): Promise<boolean> {
    try {
      // Delete from MongoDB
      const result = await WebUsers.deleteOne({ username });

      if (result.deletedCount === 0) {
        return false;
      }

      // // Delete from S3 (all user data)
      // await S3Service.deleteUserData(username);

      return true;
    } catch (error) {
      console.error("Error deleting user:", error);
      return false;
    }
  }

  /**
   * Delete Admin
   */
  static async deleteAdmin(
    username: string,
    requestingAdminUsername: string
  ): Promise<boolean> {
    try {
      // Check if attempting to delete super admin
      const targetAdmin = await Admins.findOne({ username });
      if (targetAdmin?.isSuperAdmin) {
        return false; // Cannot delete super admin
      }

      // Check if attempting self-deletion
      if (username === requestingAdminUsername) {
        return false; // Cannot delete self
      }

      const result = await Admins.deleteOne({ username });
      return result.deletedCount > 0;
    } catch (error) {
      console.error("Error deleting admin:", error);
      return false;
    }
  }

  /**
   * Check if user has access to project
   */
  static async hasProjectAccess(
    username: string,
    projectId: string
  ): Promise<boolean> {
    const project = await Projects.findOne({
      _id: new ObjectId(projectId) as unknown as string,
      "members.userId": username,
    });
    return !!project;
  }

  /**
   * Check if admin has project management rights
   */
  static async canManageProject(
    adminUsername: string,
    projectId: string
  ): Promise<boolean> {
    const admin = await Admins.findOne({ username: adminUsername });
    // Super admins can manage all projects
    if (admin?.isSuperAdmin) return true;

    const project = await Projects.findOne({
      _id: new ObjectId(projectId) as unknown as string,
      createdBy: adminUsername,
    });
    return !!project;
  }

  /**
   * Add project access for user
   */
  static async addProjectAccess(
    username: string,
    projectId: string,
    allocationPercentage: number
  ): Promise<boolean> {
    const user = await WebUsers.findOne({ username });
    if (!user) return false;

    const result = await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      {
        $push: {
          members: {
            userId: username,
            allocationPercentage,
            assignedImages: [],
            completedImages: [],
            timeSpent: 0,
            lastActivity: new Date(),
          },
        },
      }
    );

    return result.modifiedCount > 0;
  }

  /**
 * Get projects assigned to a user
 */
static async getUserProjects(username: string): Promise<any[]> {
  try {
    // Find all projects where the user is a member
    const projects = await Projects.find({
      "members.userId": username
    }).toArray();
    
    if (!projects.length) return [];
    
    // Format the response for the frontend with submission status
    const projectsWithSubmissionStatus = await Promise.all(
      projects.map(async (project) => {
        // Find the member data for this user
        const memberData = project.members.find(m => m.userId === username);
        
        // Calculate completion percentage
        const totalAssigned = memberData?.assignedImages.length || 0;
        const totalCompleted = memberData?.completedImages.length || 0;
        
        // Get submission status
        const { isSubmitted, submittedAt } = 
          await ProjectService.getProjectSubmissionStatus(project._id.toString());
        
        return {
          id: project._id.toString(),
          name: project.name,
          totalImages: totalAssigned,
          annotatedImages: totalCompleted,
          remainingImages: totalAssigned - totalCompleted,
          allocationPercentage: memberData?.allocationPercentage || 0,
          timeSpent: memberData?.timeSpent || 0,
          isSubmitted,
          submittedAt
        };
      })
    );
    
    return projectsWithSubmissionStatus;
  } catch (error) {
    console.error('Error fetching user projects:', error);
    return [];
  }
}
}

================
File: src/services/crypto.service.ts
================
// src/services/crypto.service.ts
import { randomBytes, pbkdf2, timingSafeEqual } from 'crypto';
import { promisify } from 'util';

const pbkdf2Async = promisify(pbkdf2);

export class CryptoService {
  private static readonly ITERATIONS = 600000;
  private static readonly KEYLEN = 64;
  private static readonly DIGEST = 'sha512';
  private static readonly TOKEN_LENGTH = 32;

  /**
   * Hash a password with salt
   */
  static async hashPassword(password: string, salt?: string): Promise<{ hash: string; salt: string }> {
    const usedSalt = salt || randomBytes(32).toString('hex');
    const hash = await pbkdf2Async(
      password,
      usedSalt,
      this.ITERATIONS,
      this.KEYLEN,
      this.DIGEST
    );
    
    return { hash: hash.toString('hex'), salt: usedSalt };
  }

  /**
   * Verify a password against stored hash
   */
  static async verifyPassword(password: string, hash: string, salt: string): Promise<boolean> {
    if (!password || !hash || !salt) {
      return false;
    }

    try {
      const { hash: compareHash } = await this.hashPassword(password, salt);
      const hashBuffer = Buffer.from(hash, 'hex');
      const compareHashBuffer = Buffer.from(compareHash, 'hex');
      
      return timingSafeEqual(hashBuffer, compareHashBuffer);
    } catch (error) {
      console.error('Error verifying password:', error);
      return false;
    }
  }

  /**
   * Generate a secure random token
   */
  static generateToken(): string {
    return randomBytes(this.TOKEN_LENGTH).toString('hex');
  }

  /**
   * Create a verification hash
   */
  static createVerificationHash(data: string): string {
    return randomBytes(32).toString('hex') + Buffer.from(data).toString('hex');
  }

  /**
   * Compare two hashes safely
   */
  static compareHashes(hash1: string, hash2: string): boolean {
    try {
      return timingSafeEqual(Buffer.from(hash1, 'hex'), Buffer.from(hash2, 'hex'));
    } catch {
      return false;
    }
  }
}

================
File: src/services/device.service.ts
================
// src/services/device.service.ts
import { createHash } from "crypto";

export class DeviceService {
  static generateFingerprint(userAgent: string, _ip: string, additionalData: string = ''): string {
    // Normalize user agent - ignore it for fingerprinting to avoid middleware/client mismatches
    const normalizedUserAgent = 'browser-client';
    
    // Parse additional device data if available
    let deviceData = '';
    try {
      if (additionalData) {
        const parsed = typeof additionalData === 'string' 
          ? JSON.parse(additionalData)
          : additionalData;

        // Only use stable characteristics
        deviceData = [
          parsed.platform,           // OS/Platform
          parsed.screenResolution,   // Screen resolution
          parsed.language,           // Language setting
          parsed.timezone           // Timezone
        ].filter(Boolean).join('|');
      }
    } catch {
      // If parsing fails, just use empty string
      deviceData = '';
    }

    console.log('Generating fingerprint with:', {
      userAgent: normalizedUserAgent,
      deviceData: deviceData
    });

    // Generate fingerprint using only device data and normalized user agent
    // This makes it more resilient to middleware/client differences
    return createHash('sha256')
      .update(`${deviceData}`)  // Remove userAgent from fingerprint
      .digest('hex');
  }

  static isKnownBot(userAgent: string): boolean {
    if (!userAgent) return false;
    
    const botPatterns = [
      'bot', 'crawler', 'spider', 'headless', 'puppet', 'selenium',
      'chrome-lighthouse', 'googlebot', 'bingbot', 'apache-httpclient',
      'next.js'  // Add Next.js to known patterns
    ];
    return botPatterns.some(pattern => 
      userAgent.toLowerCase().includes(pattern)
    );
  }

  static normalizeDeviceInfo(deviceInfo: any): string {
    if (!deviceInfo) return '';

    try {
      const data = typeof deviceInfo === 'string' 
        ? JSON.parse(deviceInfo)
        : deviceInfo;

      return JSON.stringify({
        platform: data.platform || 'unknown',
        screenResolution: data.screenResolution || 'unknown',
        language: data.language || 'unknown',
        timezone: data.timezone || 'UTC'
      });
    } catch {
      return '';
    }
  }
}

================
File: src/services/log.service.ts
================
// src/services/log.service.ts
import { SecurityLogs } from '../config/mongo.js';
import type { SecurityLog } from '../types/log.types.js';
import { SecurityLogType } from '../types/log.types.js';

export class SecurityLogService {
  // Log security event
  static async logSecurityEvent(
    userId: string,
    logType: SecurityLogType,
    details: {
      userAgent: string;
      ip: string;
      path?: string;
      keyPressed?: string;
      requestCount?: number;
      deviceInfo?: string;
      additionalInfo?: string;
    }
  ): Promise<boolean> {
    try {
      const log: SecurityLog = {
        userId,
        timestamp: new Date(),
        logType,
        details
      };

      await SecurityLogs.insertOne(log);
      return true;
    } catch (error) {
      console.error('Error logging security event:', error);
      return false;
    }
  }

  // Get logs with filtering for admins
  static async getSecurityLogs(filters?: {
    userId?: string;
    logType?: SecurityLogType | SecurityLogType[];  // Update this to accept array
    startDate?: Date;
    endDate?: Date;
    ip?: string;
    page?: number;
    limit?: number;
  }) {
    try {
      const query: any = {};
      const page = filters?.page || 1;
      const limit = filters?.limit || 50;
      const skip = (page - 1) * limit;
  
      if (filters) {
        if (filters.userId) query.userId = filters.userId;
        if (filters.ip) query["details.ip"] = filters.ip;
        
        // Handle both single logType and array of logTypes
        if (filters.logType) {
          if (Array.isArray(filters.logType)) {
            query.logType = { $in: filters.logType };
          } else {
            query.logType = filters.logType;
          }
        }
        
        if (filters.startDate || filters.endDate) {
          query.timestamp = {};
          if (filters.startDate) query.timestamp.$gte = filters.startDate;
          if (filters.endDate) query.timestamp.$lte = filters.endDate;
        }
      }
  
      const [logs, total] = await Promise.all([
        SecurityLogs.find(query)
          .sort({ timestamp: -1 })
          .skip(skip)
          .limit(limit)
          .toArray(),
        SecurityLogs.countDocuments(query)
      ]);
  
      return {
        logs,
        pagination: {
          total,
          page,
          totalPages: Math.ceil(total / limit),
          limit
        }
      };
    } catch (error) {
      console.error('Error fetching security logs:', error);
      throw error;
    }
  }

  // Get user security summary for admins
  static async getUserSecuritySummary(userId: string) {
    try {
      const lastDay = new Date(Date.now() - 24 * 60 * 60 * 1000);

      const [recentLogs, summary] = await Promise.all([
        SecurityLogs.find({ 
          userId, 
          timestamp: { $gte: lastDay } 
        })
          .sort({ timestamp: -1 })
          .toArray(),
        
        SecurityLogs.aggregate([
          { $match: { userId } },
          {
            $group: {
              _id: '$logType',
              count: { $sum: 1 },
              lastOccurrence: { $max: '$timestamp' }
            }
          }
        ]).toArray()
      ]);

      return {
        recentLogs,
        summary,
        totalEvents: summary.reduce((acc, curr) => acc + curr.count, 0)
      };
    } catch (error) {
      console.error('Error getting user security summary:', error);
      throw error;
    }
  }

  // Get overall security statistics for admins
  static async getSecurityStats(timeframe: number = 24) {
    const cutoffDate = new Date();
    cutoffDate.setHours(cutoffDate.getHours() - timeframe);

    try {
      const [
        totalEvents,
        userStats,
        eventTypeStats,
        recentEvents
      ] = await Promise.all([
        SecurityLogs.countDocuments({ timestamp: { $gte: cutoffDate } }),
        
        SecurityLogs.aggregate([
          { $match: { timestamp: { $gte: cutoffDate } } },
          { $group: { _id: '$userId', count: { $sum: 1 } } },
          { $sort: { count: -1 } },
          { $limit: 10 }
        ]).toArray(),
        
        SecurityLogs.aggregate([
          { $match: { timestamp: { $gte: cutoffDate } } },
          { $group: { _id: '$logType', count: { $sum: 1 } } },
          { $sort: { count: -1 } }
        ]).toArray(),
        
        SecurityLogs.find()
          .sort({ timestamp: -1 })
          .limit(10)
          .toArray()
      ]);

      return {
        timeframe,
        totalEvents,
        topUsers: userStats,
        eventDistribution: eventTypeStats,
        recentEvents
      };
    } catch (error) {
      console.error('Error getting security stats:', error);
      throw error;
    }
  }
}

================
File: src/services/project.service.ts
================
// src/services/project.service.ts
import { ObjectId } from "mongodb";
import { Projects, ImageAssignments } from "../config/mongo.js";
import { S3Service } from "./s3.service.js";
import type {
  Project,
  ProjectMember,
  ProjectStats,
  ProjectStatus,
  ImageAssignment,
} from "../types/project.types.js";

export class ProjectService {
  /**
   * Create a new project
   */
  static async createProject(
    adminUsername: string,
    projectData: Omit<Project, "_id" | "createdAt" | "createdBy" | "stats">
  ): Promise<string> {
    // Create project in MongoDB
    const project: Project = {
      ...projectData,
      createdAt: new Date(),
      createdBy: adminUsername,
      stats: {
        assignedImages: 0,
        completedImages: 0,
        approvedImages: 0,
        totalAnnotations: 0,
        lastActivity: new Date(),
      },
    };

    const result = await Projects.insertOne(project);
    const projectId = result.insertedId.toString();

    // Create project structure in S3
    await S3Service.createProjectStructure(projectId);

    // Save initial classes
    if (projectData.classes.length > 0) {
      await S3Service.saveClasses(projectId, projectData.classes);
    }

    return projectId;
  }

  /**
   * Update project details
   */
  static async updateProject(
    projectId: string,
    updates: Partial<Project>
  ): Promise<boolean> {
    const result = await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      { $set: updates }
    );
    return result.modifiedCount > 0;
  }

  /**
   * Add member to project
   */
  static async addProjectMember(
    projectId: string,
    userId: string,
    allocationPercentage: number
  ): Promise<boolean> {
    const member: ProjectMember = {
      userId,
      allocationPercentage,
      assignedImages: [],
      completedImages: [],
      timeSpent: 0,
    };

    const result = await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      { $push: { members: member } }
    );

    if (result.modifiedCount > 0) {
      // Trigger task redistribution
      await this.redistributeTasks(projectId);
      return true;
    }
    return false;
  }

  /**
   * Update member allocation
   */
  static async updateMemberAllocation(
    projectId: string,
    userId: string,
    newPercentage: number
  ): Promise<boolean> {
    const result = await Projects.updateOne(
      {
        _id: new ObjectId(projectId) as unknown as string,
        "members.userId": userId,
      },
      {
        $set: {
          "members.$.allocationPercentage": newPercentage,
        },
      }
    );

    if (result.modifiedCount > 0) {
      // Trigger task redistribution
      await this.redistributeTasks(projectId);
      return true;
    }
    return false;
  }

  /**
   * Remove member from project
   */
  static async removeMember(
    projectId: string,
    userId: string
  ): Promise<boolean> {
    const result = await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      {
        $pull: {
          members: { userId },
        },
      }
    );

    if (result.modifiedCount > 0) {
      // Reassign member's tasks
      await this.redistributeTasks(projectId);
      return true;
    }
    return false;
  }

  /**
   * Get project statistics
   */
  static async getProjectStats(projectId: string): Promise<ProjectStats> {
    const project = await Projects.findOne({
      _id: new ObjectId(projectId) as unknown as string,
    });

    if (!project) throw new Error("Project not found");

    const memberStats = project.members.map((member) => ({
      userId: member.userId,
      assigned: member.assignedImages.length,
      completed: member.completedImages.length,
      approved: 0, // Will be calculated from ImageAssignments
      timeSpent: member.timeSpent,
    }));

    // Get approved counts
    for (const stats of memberStats) {
      const approvedCount = await ImageAssignments.countDocuments({
        projectId,
        assignedTo: stats.userId,
        "review.status": "approved",
      });
      stats.approved = approvedCount;
    }

    return {
      totalImages: project.totalImages,
      assignedImages: project.stats.assignedImages,
      completedImages: project.stats.completedImages,
      approvedImages: project.stats.approvedImages,
      memberStats,
    };
  }

  /**
   * Redistribute tasks based on allocation percentages
   */
  private static async redistributeTasks(projectId: string): Promise<void> {
    const project = await Projects.findOne({
      _id: new ObjectId(projectId) as unknown as string,
    });

    if (!project) return;

    // Get all unassigned and incomplete images
    const assignments = await ImageAssignments.find({
      projectId,
      $or: [{ assignedTo: { $exists: false } }, { status: "pending" }],
    }).toArray();

    // Calculate assignments based on percentages
    const totalImages = assignments.length;
    const memberAllocations = new Map<string, number>();

    for (const member of project.members) {
      const allocation = Math.floor(
        totalImages * (member.allocationPercentage / 100)
      );
      memberAllocations.set(member.userId, allocation);
    }

    // Assign images to members
    for (const assignment of assignments) {
      // Find member with lowest current allocation
      let selectedMember = project.members[0]?.userId;
      let minAllocation = Infinity;

      for (const [userId, allocation] of memberAllocations) {
        if (allocation < minAllocation) {
          minAllocation = allocation;
          selectedMember = userId;
        }
      }

      if (selectedMember) {
        await ImageAssignments.updateOne(
          { _id: assignment._id },
          {
            $set: {
              assignedTo: selectedMember,
              assignedAt: new Date(),
              status: "pending",
            },
          }
        );

        // Update allocation count
        const currentAllocation = memberAllocations.get(selectedMember) || 0;
        memberAllocations.set(selectedMember, currentAllocation - 1);
      }
    }

    // Update project stats
    await this.updateProjectStats(projectId);
  }

  /**
   * Update project statistics
   */
  private static async updateProjectStats(projectId: string): Promise<void> {
    const [totalAssigned, totalCompleted, totalApproved, totalAnnotations] =
      await Promise.all([
        ImageAssignments.countDocuments({
          projectId,
          assignedTo: { $exists: true },
        }),
        ImageAssignments.countDocuments({ projectId, status: "completed" }),
        ImageAssignments.countDocuments({
          projectId,
          "review.status": "approved",
        }),
        ImageAssignments.countDocuments({ projectId }), // Total annotations
      ]);

    await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      {
        $set: {
          "stats.assignedImages": totalAssigned,
          "stats.completedImages": totalCompleted,
          "stats.approvedImages": totalApproved,
          "stats.totalAnnotations": totalAnnotations,
          "stats.lastActivity": new Date(),
        },
      }
    );
  }

  /**
   * Mark project status
   */
  static async updateProjectStatus(
    projectId: string,
    status: ProjectStatus
  ): Promise<boolean> {
    const result = await Projects.updateOne(
      { _id: new ObjectId(projectId) as unknown as string },
      { $set: { status } }
    );
    return result.modifiedCount > 0;
  }

  /**
   * Get member's assigned images
   */
  static async getMemberAssignments(
    projectId: string,
    userId: string,
    page: number = 1,
    limit: number = 20
  ): Promise<{
    assignments: ImageAssignment[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const skip = (page - 1) * limit;

    const [assignments, total] = await Promise.all([
      ImageAssignments.find({
        projectId,
        assignedTo: userId,
      })
        .sort({ assignedAt: -1 })
        .skip(skip)
        .limit(limit)
        .toArray(),
      ImageAssignments.countDocuments({
        projectId,
        assignedTo: userId,
      }),
    ]);

    return {
      assignments,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  /**
   * Update annotation review status
   */
  static async updateAnnotationReview(
    projectId: string,
    imageId: string,
    reviewerUsername: string,
    status: "approved" | "changes_requested",
    feedback?: string
  ): Promise<boolean> {
    try {
      const result = await ImageAssignments.updateOne(
        {
          projectId,
          imageId,
        },
        {
          $set: {
            "review.status": status,
            "review.reviewedBy": reviewerUsername,
            "review.reviewedAt": new Date(),
            "review.feedback": feedback,
          },
          $push: {
            "review.revisionHistory": {
              timestamp: new Date(),
              reviewer: reviewerUsername,
              status,
              feedback,
            },
          },
        }
      );

      if (result.modifiedCount > 0) {
        // Update project stats
        await this.updateProjectStats(projectId);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error updating annotation review:", error);
      return false;
    }
  }

  /**
   * Check if a user has access to a project
   */
  static async userHasAccess(
    username: string,
    projectId: string
  ): Promise<boolean> {
    try {
      const project = await Projects.findOne({
        _id: new ObjectId(projectId) as unknown as string,
        "members.userId": username,
      });

      return !!project;
    } catch (error) {
      console.error("Error checking project access:", error);
      return false;
    }
  }

  /**
   * Submit project for review
   */
  static async submitProject(
    projectId: string,
    username: string
  ): Promise<boolean> {
    try {
      // First verify user has access to the project
      const hasAccess = await this.userHasAccess(username, projectId);
      if (!hasAccess) return false;

      // Update all pending/completed assignments to review_pending status
      const result = await ImageAssignments.updateMany(
        {
          projectId,
          assignedTo: username,
          status: { $in: ["completed", "in_progress"] },
        },
        {
          $set: {
            status: "review_pending",
            "review.reviewedBy": null,
            "review.reviewedAt": null,
            "review.status": "pending",
          },
        }
      );

      // Update project stats
      await this.updateProjectStats(projectId);

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error submitting project:", error);
      return false;
    }
  }

  /**
   * Unmark project submission
   */
  static async unmarkSubmission(projectId: string): Promise<boolean> {
    try {
      // Change status from review_pending back to completed
      const result = await ImageAssignments.updateMany(
        {
          projectId,
          status: "review_pending",
        },
        {
          $set: {
            status: "completed",
            "review.status": "changes_requested",
          },
        }
      );

      // Update project stats
      await this.updateProjectStats(projectId);

      return result.modifiedCount > 0;
    } catch (error) {
      console.error("Error unmarking project submission:", error);
      return false;
    }
  }
  
  /**
   * Get project classes
   */
  static async getClasses(projectId: string): Promise<string[]> {
    try {
      const project = await Projects.findOne({
        _id: new ObjectId(projectId) as unknown as string,
      });

      if (!project) return [];

      return project.classes || [];
    } catch (error) {
      console.error("Error getting project classes:", error);
      return [];
    }
  }

  /**
   * Update project classes
   */
  static async updateClasses(
    projectId: string,
    classes: string[]
  ): Promise<boolean> {
    try {
      const result = await Projects.updateOne(
        { _id: new ObjectId(projectId) as unknown as string },
        { $set: { classes } }
      );

      if (result.modifiedCount > 0) {
        // Also update the classes in S3 to keep them in sync
        await S3Service.saveClasses(projectId, classes);
        return true;
      }

      return false;
    } catch (error) {
      console.error("Error updating project classes:", error);
      return false;
    }
  }

  /**
   * Get project submission status
   */
  static async getProjectSubmissionStatus(
    projectId: string
  ): Promise<{ isSubmitted: boolean; submittedAt?: Date }> {
    try {
      // We need to implement a way to check project submission status
      // Let's check if any submission record exists in a separate collection or field

      // As a workaround, we can check if all assigned images are marked as completed
      const project = await Projects.findOne({
        _id: new ObjectId(projectId) as unknown as string,
      });

      if (!project) {
        return { isSubmitted: false };
      }

      // Check if we already have a separate field for tracking submission
      // This would be a good time to add this field to our schema
      const submissions = await ImageAssignments.find({
        projectId,
        status: "review_pending",
      }).toArray();

      const isSubmitted = submissions.length > 0;
      const submittedAt = isSubmitted
        ? submissions.reduce((latest, sub) => {
            return sub.assignedAt > latest ? sub.assignedAt : latest;
          }, new Date(0))
        : undefined;

      return {
        isSubmitted,
        submittedAt,
      };
    } catch (error) {
      console.error("Error getting project submission status:", error);
      return { isSubmitted: false };
    }
  }
}

================
File: src/services/s3.service.ts
================
// src/services/s3.service.ts
import {
  GetObjectCommand,
  ListObjectsV2Command,
  PutObjectCommand,
  DeleteObjectCommand,
  HeadObjectCommand,
} from "@aws-sdk/client-s3";
import { s3Client, BUCKET_NAME } from "../config/aws.js";
import { TokenService } from "./token.service.js";
import { AnnotationFormat } from "../types/project.types.js";

export interface Annotation {
  class: string;
  x: number;
  y: number;
  width: number;
  height: number;
}

export interface ImageMetadata {
  id: string;
  originalName: string;
  url: string;
  lastModified: Date;
  isAnnotated: boolean;
  annotations: Annotation[];
  dimensions?: {
    width: number;
    height: number;
  };
}

interface ProjectMetadata {
  id: string;
  createdAt: string;
  settings: {
    modelFormat?: AnnotationFormat;
    allowCustomClasses?: boolean;
    requireReview?: boolean;
  };
}

export class S3Service {
  private static readonly DEFAULT_PAGE_SIZE = 30;

  /**
   * Create basic project structure in S3
   */
  static async createProjectStructure(projectId: string): Promise<boolean> {
    try {
      const basePrefix = `projects/${projectId}/`;
      const folders = [
        "metadata/",
        "images/",
        "annotations/",
        "exports/",
        "reviews/",
      ];

      // Create folder structure
      await Promise.all(
        folders.map((folder) =>
          s3Client.send(
            new PutObjectCommand({
              Bucket: BUCKET_NAME,
              Key: basePrefix + folder,
              Body: "",
              ContentType: "application/x-directory",
            })
          )
        )
      );

      // Create initial metadata files
      await Promise.all([
        this.saveProjectMetadata(projectId, {
          id: projectId,
          createdAt: new Date().toISOString(),
          settings: {
            modelFormat: AnnotationFormat.YOLO,
            allowCustomClasses: false,
            requireReview: true,
          },
        }),
        this.saveClasses(projectId, []), // Empty initial classes
      ]);

      return true;
    } catch (error) {
      console.error("Error creating project structure:", error);
      return false;
    }
  }

  /**
   * Save project metadata
   */
  static async saveProjectMetadata(
    projectId: string,
    metadata: ProjectMetadata
  ): Promise<boolean> {
    try {
      await s3Client.send(
        new PutObjectCommand({
          Bucket: BUCKET_NAME,
          Key: `projects/${projectId}/metadata/project.json`,
          Body: JSON.stringify(metadata, null, 2),
          ContentType: "application/json",
        })
      );
      return true;
    } catch (error) {
      console.error("Error saving project metadata:", error);
      return false;
    }
  }

  /**
   * Get project metadata
   */
  static async getProjectMetadata(
    projectId: string
  ): Promise<ProjectMetadata | null> {
    try {
      const command = new GetObjectCommand({
        Bucket: BUCKET_NAME,
        Key: `projects/${projectId}/metadata/project.json`,
      });

      const response = await s3Client.send(command);
      const content = await response.Body?.transformToString();
      return content ? JSON.parse(content) : null;
    } catch (error) {
      console.error("Error getting project metadata:", error);
      return null;
    }
  }

  /**
   * Upload image to project
   */
  static async uploadProjectImage(
    projectId: string,
    filename: string,
    content: Buffer,
    dimensions?: { width: number; height: number }
  ): Promise<boolean> {
    try {
      const metadata: Record<string, string> = {
        "Content-Type": "image/jpeg",
        "original-name": filename,
      };

      if (dimensions) {
        metadata["image-width"] = dimensions.width.toString();
        metadata["image-height"] = dimensions.height.toString();
      }

      await s3Client.send(
        new PutObjectCommand({
          Bucket: BUCKET_NAME,
          Key: `projects/${projectId}/images/${filename}`,
          Body: content,
          Metadata: metadata,
        })
      );

      return true;
    } catch (error) {
      console.error("Error uploading image:", error);
      return false;
    }
  }

  /**
   * Get image data and generate signed URL
   */
  static async getProjectImage(
    projectId: string,
    imageId: string,
    baseUrl: string
  ): Promise<ImageMetadata | null> {
    try {
      const key = `projects/${projectId}/images/${imageId}`;
      const headCommand = new HeadObjectCommand({
        Bucket: BUCKET_NAME,
        Key: key,
      });

      const headResponse = await s3Client.send(headCommand);
      const metadata = headResponse.Metadata || {};

      // Generate token for image access
      const token = TokenService.generateToken(key);
      const url = `${baseUrl}/api/proxy/images/${token}`;

      // Get annotation status
      const annotations = await this.getImageAnnotations(projectId, imageId);

      return {
        id: imageId,
        originalName: metadata["original-name"] || imageId,
        url,
        lastModified: headResponse.LastModified || new Date(),
        isAnnotated: annotations.length > 0,
        annotations,
        dimensions: metadata["image-width"]
          ? {
              width: parseInt(metadata["image-width"]),
              height: parseInt(metadata["image-height"]),
            }
          : undefined,
      };
    } catch (error) {
      console.error("Error getting image:", error);
      return null;
    }
  }

  /**
   * Get image annotations
   */
  static async getImageAnnotations(
    projectId: string,
    imageId: string
  ): Promise<Annotation[]> {
    try {
      const command = new GetObjectCommand({
        Bucket: BUCKET_NAME,
        Key: `projects/${projectId}/annotations/${imageId}.txt`,
      });

      const response = await s3Client.send(command);
      const content = await response.Body?.transformToString();

      if (!content) return [];

      return content
        .split("\n")
        .filter((line) => line.trim())
        .map((line) => {
          const [className, x, y, width, height] = line.split(" ");
          return {
            class: className,
            x: parseFloat(x),
            y: parseFloat(y),
            width: parseFloat(width),
            height: parseFloat(height),
          };
        });
    } catch (error: any) {
      if (error.name === "NoSuchKey") return [];
      console.error("Error getting annotations:", error);
      return [];
    }
  }

  /**
   * Save image annotations
   */
  static async saveImageAnnotations(
    projectId: string,
    imageId: string,
    annotations: Annotation[]
  ): Promise<boolean> {
    try {
      const content = annotations
        .map(
          (ann) => `${ann.class} ${ann.x} ${ann.y} ${ann.width} ${ann.height}`
        )
        .join("\n");

      await s3Client.send(
        new PutObjectCommand({
          Bucket: BUCKET_NAME,
          Key: `projects/${projectId}/annotations/${imageId}.txt`,
          Body: content,
          ContentType: "text/plain",
        })
      );

      return true;
    } catch (error) {
      console.error("Error saving annotations:", error);
      return false;
    }
  }

  /**
   * Save annotation classes
   */
  static async saveClasses(
    projectId: string,
    classes: string[]
  ): Promise<boolean> {
    try {
      await s3Client.send(
        new PutObjectCommand({
          Bucket: BUCKET_NAME,
          Key: `projects/${projectId}/metadata/classes.txt`,
          Body: classes.join("\n"),
          ContentType: "text/plain",
        })
      );
      return true;
    } catch (error) {
      console.error("Error saving classes:", error);
      return false;
    }
  }

  /**
   * Get project classes
   */
  static async getClasses(projectId: string): Promise<string[]> {
    try {
      const command = new GetObjectCommand({
        Bucket: BUCKET_NAME,
        Key: `projects/${projectId}/metadata/classes.txt`,
      });

      const response = await s3Client.send(command);
      const content = await response.Body?.transformToString();

      return content ? content.split("\n").filter(Boolean) : [];
    } catch (error: any) {
      if (error.name === "NoSuchKey") return [];
      console.error("Error getting classes:", error);
      return [];
    }
  }

  /**
   * List project images with pagination
   */
  static async listProjectImages(
    projectId: string,
    baseUrl: string,
    cursor?: string,
    limit: number = this.DEFAULT_PAGE_SIZE
  ): Promise<{
    items: ImageMetadata[];
    nextCursor?: string;
    total: number;
  }> {
    try {
      const command = new ListObjectsV2Command({
        Bucket: BUCKET_NAME,
        Prefix: `projects/${projectId}/images/`,
        MaxKeys: limit,
        ContinuationToken: cursor,
      });

      const response = await s3Client.send(command);
      const items = await Promise.all(
        (response.Contents || [])
          .filter((item) => item.Key?.match(/\.(jpg|jpeg|png)$/i))
          .map(async (item) => {
            const imageId = item.Key!.split("/").pop()!;
            const imageData = await this.getProjectImage(
              projectId,
              imageId,
              baseUrl
            );
            return imageData!;
          })
      );

      return {
        items: items.filter((item): item is ImageMetadata => item !== null),
        nextCursor: response.NextContinuationToken,
        total: response.KeyCount || 0,
      };
    } catch (error) {
      console.error("Error listing images:", error);
      return { items: [], total: 0 };
    }
  }

  /**
   * Delete project and all associated data
   */
  static async deleteProject(projectId: string): Promise<boolean> {
    try {
      const listCommand = new ListObjectsV2Command({
        Bucket: BUCKET_NAME,
        Prefix: `projects/${projectId}/`,
      });

      const response = await s3Client.send(listCommand);
      if (!response.Contents?.length) return true;

      await Promise.all(
        response.Contents.map((item) =>
          s3Client.send(
            new DeleteObjectCommand({
              Bucket: BUCKET_NAME,
              Key: item.Key!,
            })
          )
        )
      );

      return true;
    } catch (error) {
      console.error("Error deleting project:", error);
      return false;
    }
  }

  /**
   * Get raw object from S3
   */
  static async getObject(key: string): Promise<ReadableStream | null> {
    try {
      const command = new GetObjectCommand({
        Bucket: BUCKET_NAME,
        Key: key,
      });

      const response = await s3Client.send(command);
      return response.Body?.transformToWebStream() || null;
    } catch (error) {
      console.error("Error getting object:", error);
      return null;
    }
  }

  /**
   * Delete project image
   */
  static async deleteProjectImage(
    projectId: string,
    imageId: string
  ): Promise<boolean> {
    try {
      // Delete image and its annotation if exists
      const imageKey = `projects/${projectId}/images/${imageId}`;
      const annotationKey = `projects/${projectId}/annotations/${imageId}.txt`;

      // Delete image
      await s3Client.send(
        new DeleteObjectCommand({
          Bucket: BUCKET_NAME,
          Key: imageKey,
        })
      );

      // Try to delete annotation if it exists
      try {
        await s3Client.send(
          new DeleteObjectCommand({
            Bucket: BUCKET_NAME,
            Key: annotationKey,
          })
        );
      } catch (error) {
        // Ignore errors if annotation doesn't exist
        console.log(`No annotation found for ${imageId}`);
      }

      return true;
    } catch (error) {
      console.error("Error deleting image:", error);
      return false;
    }
  }
}

================
File: src/services/scraping-detection.service.ts
================
import type { WebUser } from "../types/auth.types.js";

export class ScrapingDetectionService {
    private static readonly RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute
    private static readonly RATE_LIMIT_MAX_REQUESTS = 60;  // 60 requests per minute
    private static readonly SUSPICIOUS_PATTERNS = {
      minResponseTime: 50,           // Milliseconds
      maxSequentialRequests: 10,     // Number of requests
      timeWindow: 60 * 1000,         // 1 minute
      suspiciousEndpoints: 5         // Unique endpoints
    };
  
    static isSuspiciousActivity(activities: WebUser['activityLog']): boolean {
      if (activities.length < 2) return false;
  
      // Check for too quick sequential requests
      const recentActivities = activities.filter(
        a => a.timestamp.getTime() > Date.now() - this.SUSPICIOUS_PATTERNS.timeWindow
      );
  
      // Too many requests in time window
      if (recentActivities.length > this.SUSPICIOUS_PATTERNS.maxSequentialRequests) {
        return true;
      }
  
      // Check for suspiciously fast response times
      const hasAbnormalSpeed = recentActivities.some(
        a => a.responseTime < this.SUSPICIOUS_PATTERNS.minResponseTime
      );
      if (hasAbnormalSpeed) return true;
  
      // Check for accessing too many different endpoints quickly
      const uniqueEndpoints = new Set(recentActivities.map(a => a.endpoint));
      if (uniqueEndpoints.size > this.SUSPICIOUS_PATTERNS.suspiciousEndpoints) {
        return true;
      }
  
      return false;
    }
  
    static async handleRequest(
      user: WebUser,
      ip: string,
      userAgent: string,
      endpoint: string,
      startTime: number
    ): Promise<{ allowed: boolean; reason?: string }> {
      // Check rate limit
      const now = Date.now();
      if (user.rateLimit.resetAt.getTime() < now) {
        user.rateLimit = { count: 0, resetAt: new Date(now + this.RATE_LIMIT_WINDOW) };
      }
      
      if (user.rateLimit.count >= this.RATE_LIMIT_MAX_REQUESTS) {
        return { allowed: false, reason: 'rate_limit_exceeded' };
      }
  
      // Log activity
      const responseTime = Date.now() - startTime;
      user.activityLog.push({
        timestamp: new Date(),
        action: 'api_request',
        ip,
        userAgent,
        endpoint,
        responseTime
      });
  
      // Trim activity log to keep last 1000 entries
      user.activityLog = user.activityLog.slice(-1000);
  
      // Check for suspicious activity
      if (this.isSuspiciousActivity(user.activityLog)) {
        return { allowed: false, reason: 'suspicious_activity' };
      }
  
      // Increment rate limit counter
      user.rateLimit.count++;
  
      return { allowed: true };
    }
  }

================
File: src/services/slug.service.ts
================
import { randomBytes } from 'crypto'

export class SlugService {
  private static readonly SLUG_LENGTH = 12
  private static readonly SLUG_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
  
  static generateSlug(): string {
    const timestamp = Date.now().toString(36)
    const randomStr = randomBytes(this.SLUG_LENGTH)
      .toString('hex')
      .slice(0, this.SLUG_LENGTH)
    
    return `${timestamp}-${randomStr}`
  }

  // Map to store slug to actual filename mappings
  private static slugMap = new Map<string, string>()

  static setSlugMapping(slug: string, filename: string) {
    this.slugMap.set(slug, filename)
  }

  static getFilenameFromSlug(slug: string): string | undefined {
    return this.slugMap.get(slug)
  }
}

================
File: src/services/token.service.ts
================
// src/services/token.service.ts
import { createHash } from 'crypto'
import { env } from '../config/env.js'

const EXPIRY_TIME = 3600 // 1 hour in seconds

interface TokenData {
  key: string
  timestamp: number
}

export class TokenService {
  private static generateHash(data: string): string {
    return createHash('sha256')
      .update(data + env.AWS_SECRET_ACCESS_KEY) // Using AWS secret as additional entropy
      .digest('hex')
  }

  static generateToken(key: string): string {
    const timestamp = Date.now()
    const data = JSON.stringify({ key, timestamp })
    const hash = this.generateHash(data)
    return Buffer.from(`${data}|${hash}`).toString('base64')
  }

  static verifyToken(token: string): TokenData | null {
    try {
      const decoded = Buffer.from(token, 'base64').toString()
      const [data, hash] = decoded.split('|')
      if (!data || !hash) return null

      const calculatedHash = this.generateHash(data)
      if (calculatedHash !== hash) return null

      const tokenData: TokenData = JSON.parse(data)
      const now = Date.now()
      
      // Check if token is expired (1 hour)
      if (now - tokenData.timestamp > EXPIRY_TIME * 1000) return null

      return tokenData
    } catch {
      return null
    }
  }
}

================
File: src/types/auth.types.ts
================
// src/types/auth.types.ts

export interface WebUser {
  _id?: string;
  username: string;
  passwordHash: string;
  salt: string;
  activeDevice?: {
    fingerprint: string;
    userAgent: string;
    lastSeen: Date;
    ip: string;
    deviceInfo?: string;
  };
  accessToken?: string;
  tokenExpiry?: Date;
  isLocked: boolean;
  isOfficeUser: boolean;
  lockReason?: string;
  lastLoginAttempt: Date;
  failedLoginAttempts: number;
  activityLog: {
    timestamp: Date;
    action: string;
    ip: string;
    userAgent: string;
    endpoint: string;
    responseTime: number;
  }[];
  rateLimit: {
    count: number;
    resetAt: Date;
  };
}

export interface Admin {
  _id?: string;
  username: string;
  passwordHash: string;  // Changed from apiKey
  salt: string;         // Added for password hashing
  accessToken?: string;
  tokenExpiry?: Date;
  isSuperAdmin?: boolean;
  createdAt: Date;
  lastLogin?: Date;
  isLocked: boolean;
  lockReason?: string;
  failedLoginAttempts: number;
  lastLoginAttempt: Date;
}

export enum UserRole {
  USER = 'user',
  ADMIN = 'admin'
}

export interface AuthResponse {
  token: string;
  expiry: Date;
  role: 'user' | 'admin';
  redirectTo: string;
  deviceChanged?: boolean;
}

export interface UserInfo {
  username: string;
  role: 'user' | 'admin';
  deviceInfo?: {
    fingerprint: string;
    userAgent: string;
    lastSeen: Date;
  };
  isLocked?: boolean;
  lockReason?: string;
}

export interface LoginCredentials {
  username: string;
  password: string;
  deviceInfo?: {
    platform: string;
    screenResolution: string;
    language: string;
    timezone: string;
  };
}

================
File: src/types/log.types.ts
================
// src/types/log.types.ts
import { ObjectId } from "mongodb";

export enum SecurityLogType {
  // Authentication events
  LOGIN_SUCCESS = "LOGIN_SUCCESS",
  LOGIN_FAILED = "LOGIN_FAILED",
  LOGIN_ATTEMPT_LOCKED = "LOGIN_ATTEMPT_LOCKED",
  ADMIN_LOGIN = "ADMIN_LOGIN",
  USER_LOGOUT = "USER_LOGOUT",

  // Account events
  ACCOUNT_LOCKED = "ACCOUNT_LOCKED",
  ACCOUNT_UNLOCKED = "ACCOUNT_UNLOCKED",
  PASSWORD_RESET = "PASSWORD_RESET",
  ADMIN_PASSWORD_RESET = "ADMIN_PASSWORD_RESET",
  ADMIN_REVOKED = "ADMIN_REVOKED",
  USER_DELETED = "USER_DELETED",
  ADMIN_DELETED = "ADMIN_DELETED",
  PROJECT_SUBMITTED = "PROJECT_SUBMITTED",
  PROJECT_UNMARKED = "PROJECT_UNMARKED",
  USER_UPDATED = "USER_UPDATED",
  ANNOTATION_UPDATED = "ANNOTATION_UPDATED",
  ANNOTATION_REVIEWED = "ANNOTATION_REVIEWED",

  // Security events
  DEVICE_CHANGE = "DEVICE_CHANGE",
  DEVICE_MISMATCH = "DEVICE_MISMATCH",
  SUSPICIOUS_ACTIVITY = "SUSPICIOUS_ACTIVITY",
  RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED",

  // Client security events
  INSPECT_ELEMENT = "INSPECT_ELEMENT",
  SCREENSHOT_ATTEMPT = "SCREENSHOT_ATTEMPT",
  SCREEN_RECORD_ATTEMPT = "SCREEN_RECORD_ATTEMPT",
  KEYBOARD_SHORTCUT = "KEYBOARD_SHORTCUT",

  // System events
  USER_CREATED = "USER_CREATED",
  ADMIN_CREATED = "ADMIN_CREATED",
  UNAUTHORIZED_ACCESS = "UNAUTHORIZED_ACCESS",
  PROJECT_CREATED = "PROJECT_CREATED",
  PROJECT_UPDATED = "PROJECT_UPDATED",
  PROJECT_MEMBER_ADDED = "PROJECT_MEMBER_ADDED",
  PROJECT_MEMBER_REMOVED = "PROJECT_MEMBER_REMOVED",
}

export interface SecurityLog {
  _id?: string;
  userId: string;
  timestamp: Date;
  logType: SecurityLogType;
  details: {
    userAgent: string;
    ip: string;
    path?: string;
    keyPressed?: string;
    requestCount?: number;
    deviceInfo?: string;
    additionalInfo?: string;
  };
  projectId?: ObjectId; // Add project ID reference
}

export interface LogEntry {
  logType: SecurityLogType;
  timestamp: Date;
  details: string;
}

export interface LogFile {
  logs: LogEntry[];
}

export interface SecurityLogFilters {
  userId?: string;
  logType?: SecurityLogType | SecurityLogType[];
  startDate?: Date;
  endDate?: Date;
  ip?: string;
  page: number;
  limit: number;
  projectId?: string;
  sortConfig?: {
    field: string;
    order: 'asc' | 'desc';
  };
}

export interface LogsResponse {
  logs: SecurityLog[];
  pagination: {
    total: number;
    page: number;
    totalPages: number;
    limit: number;
  };
}

export interface SecurityStatsSummary {
  timeframe: number;
  totalEvents: number;
  topUsers: {
    _id: string;
    count: number;
  }[];
  eventDistribution: {
    _id: SecurityLogType;
    count: number;
  }[];
  topProjects: {
    _id: ObjectId;
    count: number;
  }[];
  recentEvents: SecurityLog[];
}

export interface UserSecuritySummary {
  recentLogs: SecurityLog[];
  summary: {
    _id: SecurityLogType;
    count: number;
    lastOccurrence: Date;
  }[];
  projectActivity: {
    _id: ObjectId;
    count: number;
    lastActivity: Date;
    logTypes: SecurityLogType[];
  }[];
  totalEvents: number;
}

================
File: src/types/project.types.ts
================
export enum ProjectStatus {
    DRAFT = 'draft',
    ACTIVE = 'active',
    COMPLETED = 'completed',
    ARCHIVED = 'archived'
  }
  
  export enum AnnotationFormat {
    YOLO = 'yolo',
    COCO = 'coco',
    PASCAL_VOC = 'pascal_voc'
  }
  
  export interface ProjectSettings {
    allowCustomClasses: boolean;
    requireReview: boolean;
    autoDistribute: boolean;
    modelFormat: AnnotationFormat;
  }
  
  export interface ProjectMember {
    userId: string;
    allocationPercentage: number;
    assignedImages: string[];
    completedImages: string[];
    lastActivity?: Date;
    timeSpent: number; // In minutes
  }
  
  export interface Project {
    _id?: string;
    name: string;
    description?: string;
    status: ProjectStatus;
    createdAt: Date;
    createdBy: string; // Admin username
    settings: ProjectSettings;
    members: ProjectMember[];
    classes: string[];
    totalImages: number;
    stats: {
      assignedImages: number;
      completedImages: number;
      approvedImages: number;
      totalAnnotations: number;
      lastActivity: Date;
    };
  }
  
  export interface ImageAssignment {
    _id?: string;
    projectId: string;
    imageId: string;
    assignedTo: string;
    assignedAt: Date;
    status: 'pending' | 'in_progress' | 'completed' | 'review_pending' | 'changes_requested';
    metadata: {
      originalName: string;
      size: number;
      dimensions: {
        width: number;
        height: number;
      };
    };
    review?: {
      reviewedBy?: string;
      reviewedAt?: Date;
      status: 'approved' | 'changes_requested';
      feedback?: string;
      revisionHistory: {
        timestamp: Date;
        reviewer: string;
        status: 'approved' | 'changes_requested';
        feedback?: string;
      }[];
    };
  }
  
  export interface ProjectStats {
    totalImages: number;
    assignedImages: number;
    completedImages: number;
    approvedImages: number;
    memberStats: {
      userId: string;
      assigned: number;
      completed: number;
      approved: number;
      timeSpent: number;
    }[];
  }

================================================================
End of Codebase
================================================================
